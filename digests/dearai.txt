Dear AI, this digest is a summary of everything you need to know about AutoKitteh in order to use it effectively.

- OVERVIEW.md contains a general overview about what AutoKitteh is.
- MODEL.md explains about AutoKitteh's data model.
- MANIFEST.md details the structure of a manifest which is used to define projects.
- INTEGRATIONS.md gives a list of supported integrations.
- CODE.md explains how to write code for projects.
- pyak/ contains the AutoKitteh Python SDK defintions.
- integrations/ contains files with integration specific instructions.
- samples/ contains important code samples.

With â¤ï¸ and ðŸˆs, The Kittehs.

---
Directory structure:
â””â”€â”€ dearai/
    â”œâ”€â”€ CODE.md
    â”œâ”€â”€ INTEGRATIONS.md
    â”œâ”€â”€ MANIFEST.md
    â”œâ”€â”€ MODEL.md
    â”œâ”€â”€ OVERVIEW.md
    â”œâ”€â”€ integrations/
    â”‚   â”œâ”€â”€ GITHUB.md
    â”‚   â”œâ”€â”€ GMAIL.md
    â”‚   â””â”€â”€ SLACK.md
    â”œâ”€â”€ kittehub/
    â”‚   â”œâ”€â”€ ai_agents/
    â”‚   â”‚   â”œâ”€â”€ langgraph_bot/
    â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â”‚   â”œâ”€â”€ program.py
    â”‚   â”‚   â”‚   â””â”€â”€ requirements.txt
    â”‚   â”‚   â””â”€â”€ openai_agent_researcher/
    â”‚   â”‚       â”œâ”€â”€ README.md
    â”‚   â”‚       â”œâ”€â”€ ai.py
    â”‚   â”‚       â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚       â”œâ”€â”€ data.py
    â”‚   â”‚       â”œâ”€â”€ requirements.txt
    â”‚   â”‚       â”œâ”€â”€ slack.py
    â”‚   â”‚       â”œâ”€â”€ tools.py
    â”‚   â”‚       â””â”€â”€ workflow.py
    â”‚   â”œâ”€â”€ ai_chat_assistant/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ ai.py
    â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â”œâ”€â”€ helpers.py
    â”‚   â”‚   â”œâ”€â”€ prompt.txt
    â”‚   â”‚   â””â”€â”€ repo_scanner.py
    â”‚   â”œâ”€â”€ anthropic_slack_thread_tldr/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â”œâ”€â”€ requirements.txt
    â”‚   â”‚   â””â”€â”€ workflow.py
    â”‚   â”œâ”€â”€ auth0_to_hubspot/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â””â”€â”€ program.py
    â”‚   â”œâ”€â”€ break_glass/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ approval_message.json.txt
    â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â”œâ”€â”€ program.py
    â”‚   â”‚   â””â”€â”€ request_modal.json.txt
    â”‚   â”œâ”€â”€ categorize_emails/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â””â”€â”€ program.py
    â”‚   â”œâ”€â”€ confluence_to_slack/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â””â”€â”€ program.py
    â”‚   â”œâ”€â”€ data_pipeline/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â”œâ”€â”€ bucket_event.json
    â”‚   â”‚   â”œâ”€â”€ example-sns-event.json
    â”‚   â”‚   â”œâ”€â”€ hike.gpx
    â”‚   â”‚   â”œâ”€â”€ Makefile
    â”‚   â”‚   â”œâ”€â”€ pipeline.py
    â”‚   â”‚   â”œâ”€â”€ schema.sql
    â”‚   â”‚   â””â”€â”€ subscription-event.json
    â”‚   â”œâ”€â”€ devops/
    â”‚   â”‚   â”œâ”€â”€ github_issue_alert/
    â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â”‚   â””â”€â”€ program.py
    â”‚   â”‚   â”œâ”€â”€ github_workflows/
    â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â”‚   â””â”€â”€ program.py
    â”‚   â”‚   â”œâ”€â”€ purrr/
    â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â”‚   â”œâ”€â”€ data_helper.py
    â”‚   â”‚   â”‚   â”œâ”€â”€ debug.py
    â”‚   â”‚   â”‚   â”œâ”€â”€ github_helper.py
    â”‚   â”‚   â”‚   â”œâ”€â”€ github_pr.py
    â”‚   â”‚   â”‚   â”œâ”€â”€ github_pr_test.py
    â”‚   â”‚   â”‚   â”œâ”€â”€ markdown_test.py
    â”‚   â”‚   â”‚   â”œâ”€â”€ slack_channel.py
    â”‚   â”‚   â”‚   â”œâ”€â”€ slack_cmd.py
    â”‚   â”‚   â”‚   â”œâ”€â”€ slack_cmd_test.py
    â”‚   â”‚   â”‚   â”œâ”€â”€ slack_helper.py
    â”‚   â”‚   â”‚   â”œâ”€â”€ text_utils.py
    â”‚   â”‚   â”‚   â””â”€â”€ users.py
    â”‚   â”‚   â”œâ”€â”€ reviewkitteh/
    â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â”‚   â””â”€â”€ program.py
    â”‚   â”‚   â””â”€â”€ sftp/
    â”‚   â”‚       â”œâ”€â”€ README.md
    â”‚   â”‚       â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚       â”œâ”€â”€ program.py
    â”‚   â”‚       â””â”€â”€ requirements.txt
    â”‚   â”œâ”€â”€ discord_to_spreadsheet/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â””â”€â”€ program.py
    â”‚   â”œâ”€â”€ github_copilot_seats/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â”œâ”€â”€ message.json
    â”‚   â”‚   â”œâ”€â”€ seats.py
    â”‚   â”‚   â”œâ”€â”€ triggers.py
    â”‚   â”‚   â””â”€â”€ users.py
    â”‚   â”œâ”€â”€ github_marketplace_to_slack/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â””â”€â”€ program.py
    â”‚   â”œâ”€â”€ google_cal_to_asana/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â””â”€â”€ program.py
    â”‚   â”œâ”€â”€ google_forms_to_jira/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â””â”€â”€ program.py
    â”‚   â”œâ”€â”€ hackernews/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â””â”€â”€ program.py
    â”‚   â”œâ”€â”€ invoice_processing/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â”œâ”€â”€ openAI_handling.py
    â”‚   â”‚   â”œâ”€â”€ process_gmails.py
    â”‚   â”‚   â”œâ”€â”€ program.py
    â”‚   â”‚   â”œâ”€â”€ scan_gmails.py
    â”‚   â”‚   â””â”€â”€ schemas.py
    â”‚   â”œâ”€â”€ jenkins_release/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â””â”€â”€ program.py
    â”‚   â”œâ”€â”€ jira_google_calendar/
    â”‚   â”‚   â”œâ”€â”€ assignee_from_schedule/
    â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â”‚   â””â”€â”€ program.py
    â”‚   â”‚   â””â”€â”€ deadline_to_event/
    â”‚   â”‚       â”œâ”€â”€ README.md
    â”‚   â”‚       â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚       â””â”€â”€ program.py
    â”‚   â”œâ”€â”€ quickstart/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â””â”€â”€ program.py
    â”‚   â”œâ”€â”€ reliability/
    â”‚   â”‚   â”œâ”€â”€ aws_health_monitor/
    â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â”‚   â””â”€â”€ program.py
    â”‚   â”‚   â”œâ”€â”€ incidenter/
    â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â”‚   â”œâ”€â”€ height.py
    â”‚   â”‚   â”‚   â”œâ”€â”€ program.py
    â”‚   â”‚   â”‚   â””â”€â”€ zoom.py
    â”‚   â”‚   â”œâ”€â”€ missing_jira_events_monitor/
    â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â”‚   â””â”€â”€ program.py
    â”‚   â”‚   â””â”€â”€ session_errors_monitor/
    â”‚   â”‚       â”œâ”€â”€ README.md
    â”‚   â”‚       â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚       â””â”€â”€ program.py
    â”‚   â”œâ”€â”€ room_reservation/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â”œâ”€â”€ available_rooms.py
    â”‚   â”‚   â”œâ”€â”€ reserve_room.py
    â”‚   â”‚   â”œâ”€â”€ room_status.py
    â”‚   â”‚   â””â”€â”€ util.py
    â”‚   â”œâ”€â”€ samples/
    â”‚   â”‚   â”œâ”€â”€ asana/
    â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â”‚   â””â”€â”€ program.py
    â”‚   â”‚   â”œâ”€â”€ atlassian/
    â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â””â”€â”€ jira/
    â”‚   â”‚   â”‚       â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚       â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â”‚       â””â”€â”€ program.py
    â”‚   â”‚   â”œâ”€â”€ auth0/
    â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â”‚   â””â”€â”€ program.py
    â”‚   â”‚   â”œâ”€â”€ discord/
    â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ discord_client/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ program.py
    â”‚   â”‚   â”‚   â””â”€â”€ events/
    â”‚   â”‚   â”‚       â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚       â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â”‚       â””â”€â”€ program.py
    â”‚   â”‚   â”œâ”€â”€ github/
    â”‚   â”‚   â”‚   â””â”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ google/
    â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ calendar/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ program.py
    â”‚   â”‚   â”‚   â”œâ”€â”€ drive/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ program.py
    â”‚   â”‚   â”‚   â”œâ”€â”€ forms/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ new_question.json
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ program.py
    â”‚   â”‚   â”‚   â”œâ”€â”€ gemini/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ program.py
    â”‚   â”‚   â”‚   â”œâ”€â”€ gmail/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ program.py
    â”‚   â”‚   â”‚   â””â”€â”€ sheets/
    â”‚   â”‚   â”‚       â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚       â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â”‚       â””â”€â”€ program.py
    â”‚   â”‚   â”œâ”€â”€ http/
    â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â”‚   â”œâ”€â”€ basic_auth.py
    â”‚   â”‚   â”‚   â”œâ”€â”€ bearer_token.py
    â”‚   â”‚   â”‚   â”œâ”€â”€ no_auth.py
    â”‚   â”‚   â”‚   â””â”€â”€ webhooks.py
    â”‚   â”‚   â”œâ”€â”€ hubspot/
    â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â”‚   â””â”€â”€ program.py
    â”‚   â”‚   â”œâ”€â”€ openai_chatgpt/
    â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â”‚   â””â”€â”€ program.py
    â”‚   â”‚   â”œâ”€â”€ runtime_events/
    â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â”‚   â””â”€â”€ program.py
    â”‚   â”‚   â”œâ”€â”€ scheduler/
    â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â”‚   â””â”€â”€ program.py
    â”‚   â”‚   â”œâ”€â”€ slack/
    â”‚   â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚   â”œâ”€â”€ approval_message.json.txt
    â”‚   â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â”‚   â”œâ”€â”€ message.json
    â”‚   â”‚   â”‚   â””â”€â”€ program.py
    â”‚   â”‚   â””â”€â”€ twilio/
    â”‚   â”‚       â”œâ”€â”€ README.md
    â”‚   â”‚       â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚       â””â”€â”€ program.py
    â”‚   â”œâ”€â”€ sheets_to_soap/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â”œâ”€â”€ program.py
    â”‚   â”‚   â””â”€â”€ requirements.txt
    â”‚   â”œâ”€â”€ slack_discord_sync/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â””â”€â”€ program.py
    â”‚   â”œâ”€â”€ slack_support/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â”œâ”€â”€ directory.py
    â”‚   â”‚   â”œâ”€â”€ gemini.py
    â”‚   â”‚   â””â”€â”€ main.py
    â”‚   â”œâ”€â”€ task_chain/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ event_driven/
    â”‚   â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â”‚   â”œâ”€â”€ interactive_message.json.txt
    â”‚   â”‚   â”‚   â””â”€â”€ program.py
    â”‚   â”‚   â””â”€â”€ single_workflow/
    â”‚   â”‚       â”œâ”€â”€ advanced/
    â”‚   â”‚       â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚       â”‚   â”œâ”€â”€ interactive_message.json.txt
    â”‚   â”‚       â”‚   â””â”€â”€ program.py
    â”‚   â”‚       â””â”€â”€ basic/
    â”‚   â”‚           â”œâ”€â”€ README.md
    â”‚   â”‚           â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚           â”œâ”€â”€ interactive_message.json.txt
    â”‚   â”‚           â””â”€â”€ program.py
    â”‚   â”œâ”€â”€ tests/
    â”‚   â”‚   â”œâ”€â”€ convention_test.py
    â”‚   â”‚   â””â”€â”€ metadata_definitions.py
    â”‚   â”œâ”€â”€ walkthroughs/
    â”‚   â”‚   â”œâ”€â”€ quickstart/
    â”‚   â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â”‚   â””â”€â”€ program.py
    â”‚   â”‚   â”œâ”€â”€ send_email/
    â”‚   â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â”‚   â””â”€â”€ program.py
    â”‚   â”‚   â”œâ”€â”€ send_slack_message/
    â”‚   â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â”‚   â””â”€â”€ program.py
    â”‚   â”‚   â””â”€â”€ webhook/
    â”‚   â”‚       â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚       â””â”€â”€ program.py
    â”‚   â”œâ”€â”€ webhook_to_jira/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”œâ”€â”€ autokitteh.yaml
    â”‚   â”‚   â””â”€â”€ program.py
    â”‚   â””â”€â”€ .github/
    â”‚       â””â”€â”€ workflows/
    â”‚           â”œâ”€â”€ ci.yml
    â”‚           â”œâ”€â”€ dist.yml
    â”‚           â””â”€â”€ typos.yml
    â”œâ”€â”€ pyak/
    â”‚   â”œâ”€â”€ __init__.py
    â”‚   â”œâ”€â”€ activities.py
    â”‚   â”œâ”€â”€ anthropic.py
    â”‚   â”œâ”€â”€ asana.py
    â”‚   â”œâ”€â”€ atlassian.py
    â”‚   â”œâ”€â”€ attr_dict.py
    â”‚   â”œâ”€â”€ auth0.py
    â”‚   â”œâ”€â”€ aws.py
    â”‚   â”œâ”€â”€ connections.py
    â”‚   â”œâ”€â”€ discord.py
    â”‚   â”œâ”€â”€ errors.py
    â”‚   â”œâ”€â”€ event.py
    â”‚   â”œâ”€â”€ events.py
    â”‚   â”œâ”€â”€ github.py
    â”‚   â”œâ”€â”€ google.py
    â”‚   â”œâ”€â”€ height.py
    â”‚   â”œâ”€â”€ hubspot.py
    â”‚   â”œâ”€â”€ kubernetes.py
    â”‚   â”œâ”€â”€ linear.py
    â”‚   â”œâ”€â”€ microsoft.py
    â”‚   â”œâ”€â”€ oauth2_session.py
    â”‚   â”œâ”€â”€ openai.py
    â”‚   â”œâ”€â”€ packages.py
    â”‚   â”œâ”€â”€ salesforce.py
    â”‚   â”œâ”€â”€ signals.py
    â”‚   â”œâ”€â”€ slack.py
    â”‚   â”œâ”€â”€ store.py
    â”‚   â”œâ”€â”€ twilio.py
    â”‚   â””â”€â”€ zoom.py
    â””â”€â”€ samples/
        â”œâ”€â”€ reviewkitteh/
        â”‚   â”œâ”€â”€ autokitteh.yaml
        â”‚   â””â”€â”€ program.py
        â””â”€â”€ slack/
            â”œâ”€â”€ approval_message.json.txt
            â”œâ”€â”€ autokitteh.yaml
            â”œâ”€â”€ message.json
            â””â”€â”€ program.py

================================================
FILE: CODE.md
================================================


# Code

An AutoKitteh project contains configuration (as described by a manifest) and code.
The code is Python 3 code.

By default, AutoKitteh makes available the following packages for the program:
"""
anthropic ~= 0.54.0
asana ~= 5.0
atlassian-python-api ~= 3.41
auth0-python ~= 4.7
azure-identity ~= 1.19
boto3 ~= 1.35
discord.py ~= 2.5
google-api-python-client ~= 2.155
google-auth-httplib2 ~= 0.2
google-auth-oauthlib ~= 1.2
google-generativeai ~= 0.8
hubspot-api-client ~= 11.1
kubernetes ~= 31.0
msgraph-sdk ~= 1.18
openai ~= 1.57
PyGithub ~= 2.6
simple-salesforce ~= 1.12
slack-sdk ~= 3.33
tenacity ~= 9.0
twilio ~= 9.4
beautifulsoup4 ~= 4.12
grpcio ~= 1.68
grpcio-reflection ~= 1.68
PyYAML ~= 6.0
requests ~= 2.32
tenacity ~= 9.0
"""

If the additional packages are required, they can be specified in a `requirements.txt` file.

The following integration names are supported:
- asana
- auth0
- aws
- chatgpt
- confluence
- discord
- github
- gmail
- googlecalendar
- googledrive
- googleforms
- googlegemini
- googlesheets
- height
- hubspot
- jira
- slack
- twilio
- zoom


## Pitfalls

## Function Return Value Must Be Pickleable

We use pickle to pass function arguments back to AutoKitteh to run as an activity. See What can be pickled and unpickled? for supported types. Most notably, the following can't be pickled:

- Open file handlers (when open returns)
- lambdas
- Dynamically generated functions (e.g. os.environ.get)

```txtar
-- bad.py --
import db

def handler(event):
    mapper = lambda n: n.lower()
    db.apply(mapper)  # BAD

-- good.py --
import db

def mapper(n):
    return n.lower()

def handler(event):
    db.apply(mapper)  # GOOD
```

NOTE: You can use copyreg.pickle in order to support more types.

## Function Timeout

If a function that runs in a workflow context (not in an activity) takes a long time, it might cause a timeout.

Say you have the following code:

```py
from collections.abc import Sequence


class Response(Sequence):
    def __init__(self, count):
        self.count = count

    def __len__(self):
        return self.count

    def __getitem__(self, index):
        if index >= self.count:
            raise IndexError

        print("calling server")  # network call, takes time
        return {
            'id': index,
            'level': 'INFO',
            'message': f'log #{index+1}',
        }


def get_logs(env: str) -> Response:
    # TODO: Actual code
    return Response(3)


def on_event(event):
    logs = get_logs(event.data.env)
    logs = sorted(logs, key=lambda log: log['id'])  # timeout
    ...  # More code
```

When the workflow runs, `sorted(logs)` is not in an activity, and will cause a timeout due to network calls in `__getitem__`.

The solution is to place long running code in an activity:

```py
@autokitteh.activity
def on_event(event):
    logs = get_logs(event.data.env)
    logs = sorted(logs, key=lambda log: log['id'])  # timeout
    ...  # More code
```

## SDK

The AutoKitteh SDK is automatically available for import.
Its documentation can be found at https://autokitteh.readthedocs.io/en/latest/.

### Explicit Activities using the `autokitteh.activity` Decorator

The autokitteh.activity decorator allow you to mark a function that must run as activity. This allows you to run function with arguments or return values that are not compatible with pickle. This is mostly useful when performing IO.

NOTE: The autokitteh module is installed to the default AutoKitteh virtual environment.

Say you have the following code in your handler:

```py
import json
from urllib.request import urlopen


def handler(event):
    login = event['login']
    url = f'https://api.github.com/users/{login}'
    with urlopen(url) as fp:
        resp = json.load(fp)
    print('user name:', resp['name'])
```

Running this handler will fail since the result of urlopen can't be pickled. What you can do is move the code into a function marked as activity:

```py
import json
from urllib.request import urlopen

import autokitteh


def handler(event):
    login = event['login']
    info = user_info(login)
    print('user name:', info['name'])


@autokitteh.activity
def user_info(login):
    url = f'https://api.github.com/users/{login}'
    with urlopen(url) as fp:
        resp = json.load(fp)
    return resp
```

All the code in user_info runs in a single activity. Since user_info accepts a str and returns a dict, both are pickleable, it can run as activity.

### Starting new child sessions using `autokitteh.start`

A session can start a new child session using the `autokitteh.start` function from the SDK.

```
autokitteh.start(loc: str, data: dict = None, memo: dict = None) -> str
```

- `loc` is the code location of the function start, format: "filename:function_name".
- `data` is the payload to present to that function. It could read this from the `event` parameter as `event.data`.
- `memo` is a string to string dictionary for general memo fields that will be displayed in the UI.

The function returns the session ID for the newly created session.

Example:

```txtar
-- main.py --

import autokitteh

def on_whatever(_):
    autokitteh.start("main.py:say", {"sound": "meow"})

def say(event):
    print(event.data.sound) # prints "meow"
```

# Event Structure

Event handler functions receive a single argument of type `autokitteh.Event`. It is recommended this argument to be called `event`:

```py
from autokitteh import Event

def on_some_trigger(event: Event):
    ...
```

The event contains the `session_id` for the session and the event payload in its `data` field.

Each integration has a different event payload format. See details about each integration format in the `integrations/` folder.

---
sidebar_position: 1
description: Programmatic event handling
title: Subscription
---

# Programmatic Event Handling

## Overview

Triggers are static definitions in AutoKitteh projects to start sessions that
run Python workflows when certain events are received.

In addition, workflows can receive events programmatically during runtime.
This page describes how this works.

## Initial Subscription

```py
import autokitteh

subscription_id = autokitteh.subscribe(connection_or_trigger_name, filter)
```

### Subscription ID

The `subscribe` function call returns a UUID string that represents a specific
event source and the exact time of the `subscribe` call. AutoKitteh queues all
the events from the given event source, starting at this point in time. This
UUID is used later as a handle to [consume these events](#consuming-events).

### Connection/Trigger Name

Connection and trigger names are defined in the AutoKitteh project. This name
identifies the desired event source: a specific third-party connection, or an
HTTP webhook.

### Filter

The filter string is a single-line CEL (Common Expression Language)
expression. This is identical to the `filter` field in project triggers.

:::tip

Complete reference:
https://github.com/google/cel-spec/blob/master/doc/langdef.md

:::

CEL conditions may reference `event_type` (same as in project triggers).
Unlike the `event_type` field in project triggers, a `filter` conditions may
check more than simple equality, and filters may contain more than a single
condition. For example:

```js
// Either 'issue_created' or 'issue_updated' events
event_type == 'issue_created' || event_type == 'issue_updated'

// Any issue-related events (e.g. issue_created / issue_updated),
// but not other entities (e.g. page_created / page_updated)
event_type.startsWith('issue_')

// Any event that relates to a created entity (e.g. issue_created,
// page_created), but not other categories (e.g. issue_updated)
event_type.endsWith('_created')

// More sophisticated string checks
event_type.contains('substring')
event_type.matches('regular expression')
```

In addition to event types, filters can also check event payloads. For
example:

```js
data.method in ['GET', 'HEAD'] && data.url.path.endsWith('/meow')

size(data.collection_value) < 5 || size(data.string_value) > 10

data.list_value[0].bar == 'bar value of first element in foo list'

data.dictionary_value['key'] != 'value'
```

:::tip

Data filtering in triggers and subscriptions - when it's possible - is
preferable to Python checks in handler functions, because it prevents the
creation of unnecessary sessions.

:::

## Consuming Events

The `next_event` function receives one or more subscription ID strings, which
were generated by [`subscribe`](#initial-subscription).

This function is blocking, it returns the data of a single event which was
received after the `subscribe` call(s) that generared the given ID(s). You can
call `next_event` any number of times.

Event order is not guaranteed, they are served in the same order they were
received and processed by AutoKitteh.

Example 1 - single subscription ID, without a timeout:

```py
subscription_id = autokitteh.subscribe(connection_or_trigger_name, filter)

event_data = autokitteh.next_event(subscription_id)
```

Example 2 - single subscription ID, with a timeout:

```py
from datetime import timedelta

subscription_id = autokitteh.subscribe(connection_or_trigger_name, filter)

duration = timedelta(seocnds=10)
event_data = autokitteh.next_event(subscription_id, timeout=duration)
```

Example 3 - multiple subscription IDs, without a timeout:

```py
sub_id_1 = autokitteh.subscribe(connection_or_trigger_name, filter)
sub_id_2 = autokitteh.subscribe(connection_or_trigger_name, filter)
sub_id_3 = autokitteh.subscribe(connection_or_trigger_name, filter)

event_data = autokitteh.next_event(sub_id_1, sub_id_2, sub_id_3)
```

Example 4 - multiple subscription IDs, with a timeout:

```py
from datetime import timedelta

sub1 = autokitteh.subscribe(connection_or_trigger_name, filter)
sub2 = autokitteh.subscribe(connection_or_trigger_name, filter)
sub3 = autokitteh.subscribe(connection_or_trigger_name, filter)

duration = timedelta(minutes=1)
event_data = autokitteh.next_event(sub1, sub2, sub3, timeout=duration)
```

### Timeout

This is an optional named parameter.

If you don't specify it, the `next_event` call will block forever and keep the
session running until someone stops the session manually.

When specified, the expected type is a
[timedelta](https://docs.python.org/3/library/datetime.html#timedelta-objects)
object.

## Cleanup

When you're no longer interested in receiving events from a specific
subscription, you may call this function:

```py
autokitteh.unsubscribe(subscription_id)
```

:::note

Calling `unsubscribe` is recommended, but not required. Reasonable amounts of
unused event subscriptions do not burden AutoKitteh, especially when the
sessions they were created in have ended.

:::

## Example

```py
from datetime import timedelta

import autokitteh


def on_trigger(_):
    print("Creating an event subscription")
    filter = "data.method == 'GET' && data.url.path.endswith('/meow')"
    get_sub = autokitteh.subscribe("webhook_name", filter)

    print("Waiting for an HTTP GET request without a timeout")
    event_data = autokitteh.next_event(get_sub)
    print(event_data)

    print("Creating another event subscription")
    filter = "data.method == 'POST' && data.url.path.endswith('/meow')"
    post_sub = autokitteh.subscribe("webhook_name", filter)

    print("Waiting for an HTTP GET or POST request with a 1-minute timeout")
    delta = timedelta(minutes=1)
    event_data = autokitteh.next_event(get_sub, post_sub, timeout=delta)
    print(f"Got an HTTP {event_data.method} request: {event_data}")

    print("Canceling all event subscriptions")
    autokitteh.unsubscribe(get_sub)
    autokitteh.unsubscribe(post_sub)

    print("Done")
```

See also this sample project:
https://github.com/autokitteh/kittehub/tree/main/samples/runtime_events


# TODO


## Tour of AutoKitteh by Projects

All code listings are in txtar format.

### Minimal Projects

```txtar
-- autokitteh.yaml --
version: v1

project:
  name: minimal

-- program.py --
# This can be run using a manual invocation.
def on_trigger(_):
  print("Meow, World!")
```

### Long Running Count

```txtar
-- autokitteh.yaml --
version: v1

project:
  name: minimal

vars:
  - name: N
    value: 10
  - name: T
    value: 1

-- program.py --
from os import getenv
from time import sleep

N = int(getenv("N"))
T = int(getenv("T"))

# This can be run using a manual invocation.
def on_trigger(_):
  for i in range(N):
    print(i)
    # NOTE: Sleep is "hijacked" by AutoKitteh, and if interrupted
    #       (such as by the instance going down), will resume
    #       execution from the same point taking into consideration
    #       the time already spent sleeping.
    sleep(T)
```

### Simple Webhook to Slack

```txtar
-- autokitteh.yaml --
version: v1

project:
  name: webhook_to_slack

  connections:
    - # A single slack connection to authenticate to Slack.
      name: slack_conn
      integration: slack

  triggers:
    - # A webhook to trigger the session.
      # Once applied, AutoKitteh will generate a unique URL for this.
      name: webhook
      type: webhook
      call: program.py:on_webhook

  vars:
    - # Channel to send text to.
      name: CHANNEL
      value: "#general"

-- program.py --
from autokitteh.slack import slack_client

# `slack_client` returns the official slack client.
# The helper function `slack_client` just initializes the client
# according to the manifest.
#
# NOTE: Since this is done in the global scope, AutoKitteh
#       WILL NOT run this as an activity. This is a feature
#       that allows users to make some things always run, even
#       on replay. Useful for ephemeral client initializations, etc.
client = slack_client("slack_conn")

# This is triggered when the webhook is hit.
def on_webhook(event):
    # `event.data` always contain the event data as sent from the connection.

    # The following is specific for Webhook payloads:
    payload = event.data.body.json
    channel = payload.get("channel", CHANNEL)
    text = payload.get("text", "Meow, World!")

    # NOTE: This WILL run as an activity, as this is a method called
    #       on an object that was returned from an external package.
    client.chat_postMessage(channel=channel, text=text)
```

### Explicit Activities

```txtar
-- autokitteh.yaml --
version: v1

project:
  name: explicit_activites

  vars:
    - name: SHEET_ID
      value: <some sheet id>

  connections:
    - name: sheets_conn
      integration: googlesheets

-- program.py --
import autokitteh # The autokitteh module is installed to the default AutoKitteh virtual environment.
from autokitteh.google import google_sheets_client

# google_sheets_client returns the official Google's client.
client = google_sheets_client("sheets_conn").spreadsheets().values()

SHEET_ID = getenv("SHEET_ID")

def on_trigger(_):
  _write()


# The autokitteh.activity decorator allow you to mark a function that must run as activity.
# This allows you to run function with arguments or return values that are not compatible with pickle.
#
# The reason why this is neccessary here is that client.update returns
# an object that is not serializable (or "pickleable"), so we cannot have `update`
# and `execute` run in separate activities since the data will need to be serialized
# between their invocations, and thus fail.
@autokitteh.activity
def _write():
   resp = client.update(
        spreadsheetId=SHEET_ID,
        range="Sheet1!A1:B7",
        valueInputOption="USER_ENTERED",
        body={
            "values": [
                ["String", "Hello, world!"],
                ["Number", -123.45],
                ["Formula", "=B2*B3"],
            ]
        },
    ).execute()

    print(f"Updated range: {resp['updatedRange']!r}")
```


## General Guidelines

- Each session is running isolated from other sessions:
  - You cannot, for example, store state in memory and expect another session to access it.
  - Environment variables are not shared among different sessions as well.
- For logging, use `print` functions. Currently the `logging` package is not supported.
- NEVER "invent" new AutoKitteh functions that are not explicitly exist in AutoKitteh's SDK (pyak).
- AutoKitteh will display uncaught exceptions to the user. Only catch and translate the exception if absolutely neccessary for the user to understand it.
- When using `autokitteh.subscribe`, no need to `autokitteh.unsubscribe` at the end of the program. These will be done automatically.



================================================
FILE: INTEGRATIONS.md
================================================
The following integration names are supported:
- asana
- auth0
- aws
- chatgpt
- confluence
- discord
- github
- gmail
- googlecalendar
- googledrive
- googleforms
- googlegemini
- googlesheets
- height
- hubspot
- jira
- slack
- twilio
- zoom




================================================
FILE: MANIFEST.md
================================================


## Manifest

An AutoKitteh manifest is a yaml or json file that defines how a project is configured.
It defines the PROJECT, CONNECTIONs, TRIGGERs, and VARIABLEs.

A manifest is "applied" by the user (via CLI, or automatically by the Web Application). When it is applied, it creates or updates the project configuration accordingly.

The manifest is defined according to this schema:
```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://go.autokitteh.dev/autokitteh/internal/manifest/manifest",
  "$ref": "#/$defs/Manifest",
  "$defs": {
    "Connection": {
      "properties": {
        "name": {
          "type": "string"
        },
        "integration": {
          "type": "string"
        },
        "vars": {
          "items": {
            "$ref": "#/$defs/Var"
          },
          "type": "array"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "required": [
        "name",
        "integration"
      ]
    },
    "Manifest": {
      "properties": {
        "version": {
          "type": "string"
        },
        "project": {
          "$ref": "#/$defs/Project"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "required": [
        "version"
      ]
    },
    "Project": {
      "properties": {
        "name": {
          "type": "string"
        },
        "connections": {
          "items": {
            "$ref": "#/$defs/Connection"
          },
          "type": "array"
        },
        "triggers": {
          "items": {
            "$ref": "#/$defs/Trigger"
          },
          "type": "array"
        },
        "vars": {
          "items": {
            "$ref": "#/$defs/Var"
          },
          "type": "array"
        }
      },
      "additionalProperties": false,
      "type": "object"
    },
    "Trigger": {
      "properties": {
        "name": {
          "type": "string"
        },
        "event_type": {
          "type": "string"
        },
        "filter": {
          "type": "string"
        },
        "type": {
          "type": "string",
          "enum": [
            "schedule",
            "webhook",
            "connection"
          ]
        },
        "schedule": {
          "type": "string"
        },
        "webhook": {
          "properties": {},
          "additionalProperties": false,
          "type": "object"
        },
        "connection": {
          "type": "string"
        },
        "call": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "required": [
        "name"
      ]
    },
    "Var": {
      "properties": {
        "name": {
          "type": "string"
        },
        "value": {
          "type": "string"
        },
        "secret": {
          "type": "boolean"
        }
      },
      "additionalProperties": false,
      "type": "object",
      "required": [
        "name",
        "value"
      ]
    }
  }
}
```

### Examples



```yaml
# This YAML file is a declarative manifest that describes the setup
# of an AutoKitteh project that demonstrates integration with Auth0.

version: v1

project:
  name: auth0_sample

  vars:
    - name: ROLE_ID
      value:
    - name: TIME_INTERVAL
      value: 7d

  connections:
    - name: auth_conn
      integration: auth0

  triggers:
    - name: weekly
      schedule: 0 0 * * 1
      call: program.py:weekly_user_growth
    - name: assign_role_webhook
      type: webhook
      event_type: post
      call: program.py:assign_role
```

```yaml
# This YAML file defines a manifest for an AutoKitteh project that
# creates a Langgraph bot.

version: v1

project:
  name: Langgraph_Bot

  connections:
    - name: slack_conn
      integration: slack
    - name: sheets_conn
      integration: googlesheets

  triggers:
    - name: on_message
      event_type: app_mention
      connection: slack_conn
      call: program.py:on_app_mention

  vars:
    - name: GOOGLE_API_KEY
      value: ""
    - name: TAVILY_API_KEY
      value: ""
```

```yaml
# This YAML file is a declarative manifest that describes the setup
# of an AutoKitteh project that monitors comments on GitHub issues.

version: v1

project:
  name: github_issue_alert

  vars:
    - name: SLACK_CHANNEL_NAME_OR_ID
      value: github-issues

  connections:
    - name: slack_conn
      integration: slack
    - name: github_conn
      integration: github

  triggers:
    - name: on_issue_comment
      event_type: issue_comment
      connection: github_conn
      call: program.py:on_issue_comment
    - name: on_issue_event
      event_type: issues
      connection: github_conn
      call: program.py:on_issue_event
```

```yaml
# This YAML file is a declarative manifest that describes the setup
# of an AutoKitteh project that logs messages from Discord to a
# Google Sheets document.

version: v1

project:
  name: discord_to_spreadsheet

  vars:
    - name: RANGE_NAME
      value: Sheet1!A1
    - name: SPREADSHEET_ID
      value:

  connections:
    - name: discord_conn
      integration: discord
    - name: googlesheets_conn
      integration: googlesheets

  triggers:
    - name: on_discord_message
      connection: discord_conn
      event_type: message_create
      call: program.py:on_discord_message
```




================================================
FILE: MODEL.md
================================================
# Model: Entities & Relationships

- PROJECT has RESOURCEs, CONNECTIONs, TRIGGERs, and VARIABLEs as configuration.
- AutoKitteh supports a number of native INTEGRATIONs.
- an INTEGRATION is a native implementation of an interface to an external system, such as Linear, Slack, etc.
- CONNECTION is a connection to a third-party service using an INTEGRATION, such as Slack, JIRA, Linear, etc.
  a CONNECTION is always associated with an INTEGRATION.
  a CONNECTION can have mutliple TRIGGERs defined on it.
- a DEPLOYMENT is a deployed version of a PROJECT.
- EVENTs are sent by CONNECTIONs. TRIGGERs define what to do with EVENTs. An EVENT consists on JSON formatted data.
- a SESSION starts when a DEPLOYMENT is triggered by a TRIGGER. a SESSION a workflow being run.
- RESOURCE is a source code file, but can be also any file type, like a yaml or json files.
- TRIGGER is a trigger to start a workflow, such as a CONNECTION event, webhook or a SCHEDULE.
  - WEBHOOK and SCHEDULE triggers do not require a CONNECTION.
  - CONNECTION event triggers require a CONNECTION.
- VARIABLE is a key-value pair that is defined in the project and can be used in the workflow.

## Connections

A CONNECTION is created in order to either receive events from an external application (such as Slack, JIRA, etc) or to perform some operation on an external service.

Certain CONNECTIONs need to be initialized after creation in order for them to function. Often, the initialization means establishing authentication with the external application. For example, if creating either a Slack or GitHub connection, the user is expected to initialize the connection using OAuth, which AutoKitteh supplies a UI for for. Another authentication method, in case of Slack or GitHub, can be using a PAT, which AutoKitteh allows to fill in the connection view.

## Triggers

A TRIGGER can be of one of several types.

- Webhook Trigger: when it is created, AutoKitteh generates a unique URL that when it is hit, the trigger will be invoked.
- Schedule Trigger: runs on a schedule, defined by a cronspec.
- Connection Trigger: A third party service sends an event, which when the trigger matches the event - it is invoked.

A TRIGGER can include a FILTER defintion in its `filter` field. The FILTER is specified as a Google CEL expression. The CEL expression takes as input the EVENT payload, under the name `data`. The event type will be under the name `event_type`.

A TRIGGER points to a function execute once is is hit and matches optional filter. The method is specified in the format: "filename:method_name", when `filename` is a name of a RESOURCE in the PROJECT.

### Example: Webhook: Only match with POST JSON requests

```
name: receive_http_post_json
type: webhook
event_type: post
filter: data.headers["Content-Type"].startsWith("application/json")
call: webhooks.py:on_http_post_json
```

### Example: Webhook: Only match with GET or POST requests

```
name: receive_http_get_or_head
type: webhook
filter: data.method in ["GET", "HEAD"]
call: webhooks.py:on_http_get_or_head
```

### Example: Slack: Only match `interaction` from a specific user id

```
name: slack_interaction_from_specific_id
connection: slack_connection
filter: event_type == 'interaction' && data.user.id == 'SOME_SLACK_ID'
```

### Example: Slack: Slack command where its text is "break-glass"

```
name: break_glass_slack_command
connection: slack_connection
event_type: slash_command
call: program.py:on_slack_slash_command
filter: data.text == "break-glass"
```

### Example: GitHub: PR action is either "opened" or "reopened"

```
name: github_pull_request
connection: github_conn
event_type: pull_request
filter: data.action == "opened" || data.action == "reopened"
call: program.py:on_github_pull_request
```

### Example: Schedule Triggers

```
name: weekly
schedule: "0 0 * * 1"
call: program.py:weekly_user_growth
```

```
name: weekly
schedule: @every 1w
call: program.py:weekly_user_growth
```

# Sessions

SESSIONs are created as a result of a TRIGGER. A session runs the code in the project, according to the TRIGGER defintion. When a SESSION is being ran, a specific function in its code is being invoked. That function receives the EVENT that triggered it via its argument. If the trigger is a schedule trigger, that event is empty.

IMPORTANT: Session invocation is asynchronic. The CONNECTION or TRIGGER invoking the session do not wait for the result of the session. For example, if a WEBHOOK trigger is invoked, it will ALWAYS return a 202 response, regardless what the session does.

NOTE: A Session is running under the hood as a Temporal Workflow. AutoKitteh knows how to break down the project code running in a session into separate Temporal Activities.



================================================
FILE: OVERVIEW.md
================================================
# AutoKitteh Overview

AutoKitteh is a "serverless" platform to build and deploy durable workflows.
Durable workflows are long-running processes that automatically resume after interruptions.

Important Sites:

- https://autokitteh.com for general information about AutoKitteh.
- https://autokitteh.cloud, a SaaS deployment of autokitteh that is publicly available.

# Durability

AutoKitteh projects run code in a durable, fault-tolerant manner using Temporal (https://temporal.io) under the hood. Temporal ensures reliability by designating non-deterministic code as ACTIVITIES, which cache their results once completed.

When a project fails due to infrastructure issuesâ€”such as instance crashes or network problemsâ€”Temporal uses a REPLAY mechanism. It reruns the entire workflow from the beginning, but leverages the cached activity results to skip re-executing those parts, allowing them to return immediately.
AutoKitteh analyzes the Abstract Syntax Tree (AST) of project code to intelligently determine which function calls should run as ACTIVITIES and which should not.

# Operation

There are three ways to configure a project:

1. Using an autokitteh.yaml, which is also known as "the project manifest".
2. Using the CLI.
3. Using the Web UI.

# Documentation Adherence Rules

- Only reference commands, APIs, syntax, or procedures that are explicitly mentioned in the provided documentation
- If specific CLI commands or API calls are not documented, say "the documentation doesn't specify the exact command" rather than inferring or assuming
- When documentation mentions something exists (like "CLI" or "API") but doesn't provide details, acknowledge the gap rather than filling it with assumptions
- If you need to reference external knowledge not in the docs, clearly label it as "based on general knowledge, not the provided documentation"
- Always cite specific sections of the documentation when making claims about how something works



================================================
FILE: integrations/GITHUB.md
================================================
# GitHub Integration

## Event Payload

See https://docs.github.com/en/rest/using-the-rest-api/github-event-types?apiVersion=2022-11-28.



================================================
FILE: integrations/GMAIL.md
================================================
# gmail Integration

Reacting on gmail state change can be done in either of two ways:

- Polling using a schedule trigger and checking the state, or -
- Triggering on gmail events.



================================================
FILE: integrations/SLACK.md
================================================
# Slack Integration

## Event Payload

See https://api.slack.com/events.



================================================
FILE: kittehub/ai_agents/langgraph_bot/README.md
================================================
title: LangGraph Bot with Tavily, and Google Sheets
description: Slack bot built with LangGraph and powered by Gemini LLM that can search information and update Google Sheets
integrations: ["slack", "sheets"]
categories: ["AI", "Productivity"]



================================================
FILE: kittehub/ai_agents/langgraph_bot/autokitteh.yaml
================================================
# This YAML file defines a manifest for an AutoKitteh project that
# creates a Langgraph bot.

version: v1

project:
  name: Langgraph_Bot

  connections:
    - name: slack_conn
      integration: slack
    - name: sheets_conn
      integration: googlesheets

  triggers:
    - name: on_message
      event_type: app_mention
      connection: slack_conn
      call: program.py:on_app_mention

  vars:
    - name: GOOGLE_API_KEY
      value: ""
    - name: TAVILY_API_KEY
      value: ""



================================================
FILE: kittehub/ai_agents/langgraph_bot/program.py
================================================
"""LangGraph Bot for Slack using LangGraph, Google Gemini LLM, and Google Sheet API."""

from typing import Annotated, TypedDict

from autokitteh.google import google_sheets_client
from autokitteh.slack import slack_client
from langchain_core.tools import tool
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain_tavily import TavilySearch
from langgraph.graph import END
from langgraph.graph import START
from langgraph.graph import StateGraph
from langgraph.graph.message import add_messages
from langgraph.prebuilt import ToolNode
from langgraph.prebuilt import tools_condition


slack = slack_client("slack_conn")
sheet = google_sheets_client("sheets_conn").spreadsheets().values()


SYSTEM_ROLE = (
    "You are a helpful assistant. Answer the user's questions clearly and concisely. "
    "If you don't know something, you may use a search engine to find "
    "reliable information."
)


@tool
def write_to_sheet(sheet_id: str, table: str):
    """Write into a specified Google Sheet. Provide rows as a CSV-style string."""
    rows = [row.strip().split(",") for row in table.strip().split("\n")]

    sheet.update(
        spreadsheetId=sheet_id,
        range="Sheet1!A1:B7",
        valueInputOption="USER_ENTERED",
        body={"values": rows},
    ).execute()

    return {"status": "success", "message": "wrote to sheet successfully!"}


class State(TypedDict):
    """State of the LangGraph bot."""

    messages: Annotated[list, add_messages]


llm = ChatGoogleGenerativeAI(model="gemini-1.5-flash")
search_tool = TavilySearch(max_results=2)
tools = [search_tool, write_to_sheet]
llm_with_tools = llm.bind_tools(tools)


def chatbot(state: State):
    """Chat interaction using the LLM and available tools."""
    messages = [{"role": "system", "content": SYSTEM_ROLE}] + state["messages"]
    return {"messages": [llm_with_tools.invoke(messages)]}


# Compile the LangGraph here instead of inside an autokitteh activity.
# Returning builder.compile() directly from an activity causes a pickle error
# due to non-deterministic objects.

builder = StateGraph(State)
builder.add_node("chatbot", chatbot)

tool_node = ToolNode(tools=tools)
builder.add_node("tools", tool_node)

builder.add_edge(START, "chatbot")
builder.add_conditional_edges("chatbot", tools_condition)
builder.add_edge("tools", "chatbot")
builder.add_edge("chatbot", END)

graph = builder.compile()


def on_app_mention(event):
    """Handle incoming Slack messages and respond using the LangGraph bot."""
    initial_state = {"messages": [{"role": "user", "content": event.data.text}]}
    result = graph.invoke(initial_state)

    ai_message = result["messages"][-1]

    slack.chat_postMessage(channel=event.data.channel, text=ai_message.content)



================================================
FILE: kittehub/ai_agents/langgraph_bot/requirements.txt
================================================
langgraph
langchain
typing
langchain_google_genai
langchain-core
langchain-tavily



================================================
FILE: kittehub/ai_agents/openai_agent_researcher/README.md
================================================
title: OpenAI Agent Researcher
description: A Slack-based research agent workflow.
integrations: ["chatgpt", "slack"]
categories: ["AI"]



================================================
FILE: kittehub/ai_agents/openai_agent_researcher/ai.py
================================================
"""AI Agents definitions."""

import asyncio
from time import sleep

from agents import Agent
from agents import Runner
from agents import WebSearchTool
from agents.model_settings import ModelSettings
from agents.run import RunConfig
from autokitteh import activity
from openai import RateLimitError

from data import Report
from data import ResearchPlan
from data import SearchResearchItem
from slack import next_input
from slack import send
from tools import send_slack_report


_plan_agent = Agent(
    name="PlannerAgent",
    instructions="""
You are a helpful research assistant. Given a query, come up with a set of tasks
to perform to best answer the query. Output between 3 and 10 tasks to perform.
A task can be either:
- A search task: search the web for a specific term and summarize the results.
- An ask someone task: ask a specific person a question and summarize the answer.
  If a user explicitly specifies a time limit for a specific user, set it as such.
  Do this only if the user explicitly specifies a person to ask.
For each task result, if applicable, default max tokens to None, unless user explicitly
specified otherwise. User cannot be allowed to specify max tokens below 16.
You can also modify an existing plan, by adding or removing searches.
Always provide the complete plan as output along with an indication if the user
considers it final.
Consider the plan as final only if the user explicitly specifies so.
""",
    model="gpt-4o",
    output_type=ResearchPlan,
)

_search_agent = Agent(
    name="SearchAgent",
    instructions="""
You are a research assistant. Given a search term, you search the web for that term and
produce a concise summary of the results. The summary must 2-3 paragraphs and less than
300 words. Capture the main points. Write succinctly, no need to have complete sentences
or good grammar. This will be consumed by someone synthesizing a report, so its vital
you capture the essence and ignore any fluff. Do not include any additional commentary
other than the summary itself.
""",
    tools=[WebSearchTool()],
    model_settings=ModelSettings(tool_choice="required"),
    output_type=str,
)

_report_agent = Agent(
    name="ReporterAgent",
    instructions="""
Given a question and a set of search results, write a short summary of the findings.
Refine the report per user's feedback.
If the user wishes to send a slack report, use the appropriate tools to send the slack
report to the desired user.
""",
    model="gpt-4o",
    tools=[send_slack_report],
    output_type=Report | str,
)


@activity
def _run(agent: Agent, history: list, q: str, rc: RunConfig) -> tuple[str, list]:
    """Run the agent with the given query and history."""
    send("ðŸ¤”")

    while True:
        try:
            response = asyncio.run(
                Runner.run(
                    agent,
                    history + [{"role": "user", "content": q}],
                    run_config=rc,
                )
            )

            return response.final_output, response.to_input_list()
        except RateLimitError as e:
            # In case of a rate limit error, retry after waiting for 5 seconds.
            send(f"Rate limit error: {e}\n\nWaiting 5 seconds and retrying...")
            sleep(5)


def _chat(agent, is_final, q: str):
    """Chat with the agent until the response is final.

    An interaction using this function can span some back and forth
    between the user and the agent.

    Args:
        agent: The agent to chat with.
        is_final: A function to check if the response is final.
        q: The initial query.
    """
    history = []
    response = None

    while not (response and is_final(response)):
        if not q:
            q = next_input()

        response, history = _run(agent, history, q, RunConfig())

        send(response)

        q = None

    return response


def plan(q: str) -> ResearchPlan:
    """Plan agent driver."""
    return _chat(_plan_agent, lambda x: x.is_final, q)


def search(q: SearchResearchItem) -> str:
    """Search agent driver."""
    return _run(
        _search_agent,
        [],
        q.query,
        RunConfig(
            model_settings=ModelSettings(
                tool_choice="required",
                max_tokens=q.max_tokens,
            ),
        ),
    )[0]


def report(q: str, tasks: dict[str, str]):
    """Report agent driver."""
    q = f"Question: {q}\n\n\nTasks results: \n"
    for key, value in tasks.items():
        q += f"- {key}: {value}\n\n"

    return _chat(_report_agent, lambda _: False, q)



================================================
FILE: kittehub/ai_agents/openai_agent_researcher/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup of
# an AutoKitteh project that monitors comments on GitHub issues.

version: v1

project:
  name: openai_agent_researcher

  vars:
    - # The invocation command to trigger the agent from slack.
      # It will always be prefixed with '!'.
      name: INVOCATION_CMD
      value: "research"
    - name: OPENAI_API_KEY
      secret: true
      # Put here your Open AI API key.
      value: "sk-..."

  connections:
    # We use Slack to interact with the users.
    - name: slack_conn
      integration: slack

  triggers:
    # workflow.py:on_slack message will be triggered on every `message` event
    # that is not a reply to a thread and starts with `!`.
    - name: slack_message
      connection: slack_conn
      event_type: message
      filter: "data.thread_ts == '' && data.text.startsWith('!')"
      call: workflow.py:on_slack_message



================================================
FILE: kittehub/ai_agents/openai_agent_researcher/data.py
================================================
"""AI Agents data definitions."""

from pydantic import BaseModel


class ResearchItemCommon(BaseModel):
    """Common fields for research items.

    This is not use as a base class since there are some issues with
    openai agents and polymorphism.
    """

    id: int
    "The id of the search item"

    reason: str
    "Your reasoning for why this search is important to the query."

    def __str__(self):
        return f"ðŸ” {self.id}. {self.reason.removesuffix('.')}:\n"


class SearchResearchItem(BaseModel):
    """Search the web for a specific query."""

    max_tokens: int | None
    "The maximum number of tokens to generate for the search result."

    query: str
    "The search term to use for the web search."

    common: ResearchItemCommon
    "Common fields for research items"

    def __str__(self):
        return f"""{self.common}Search Query: "{self.query}"
{f"Max Tokens: {self.max_tokens}" if self.max_tokens else ""}"""


class AskSomeoneResearchItem(BaseModel):
    """Ask someone for additional information."""

    wait_time_in_seconds: int
    "The time to wait for a response from the person."

    question: str
    "The question to ask someone."

    who: str
    "Who to ask the question to."

    common: ResearchItemCommon
    "Common fields for research items"

    def __str__(self):
        time_limit = ""
        if self.wait_time_in_seconds:
            time_limit = f"Time Limit: {self.wait_time_in_seconds} seconds"

        return f"""{self.common}Person: {self.who}
Question: "{self.question}"
{time_limit}"""


class ResearchPlan(BaseModel):
    """A plan for a research report."""

    question: str
    """What is the question the report needs to answer."""

    tasks: list[SearchResearchItem | AskSomeoneResearchItem]
    """A list of tasks to perform to best answer the query."""

    is_final: bool
    """If the plan is final or not"""

    explanation: str
    """Explanation of the plan"""

    def __str__(self):
        text = f"""{self.explanation}

Q: {self.question}

{"Final" if self.is_final else "Draft"} Plan:
"""
        for task in self.tasks:
            text += f"{task}\n"

        return text


class Report(BaseModel):
    """A report summarizing the findings of the research."""

    question: str
    """The question the report is answering."""

    result: str
    """The result of the report."""

    def __str__(self):
        return f"""\nFinal Report:
Q: {self.question}
A: {self.result}
"""



================================================
FILE: kittehub/ai_agents/openai_agent_researcher/requirements.txt
================================================
openai-agents
pydantic



================================================
FILE: kittehub/ai_agents/openai_agent_researcher/slack.py
================================================
"""Entrypoint when using from AutoKitteh with Slack."""

from autokitteh import next_event, subscribe
from autokitteh.slack import slack_client
from slack_sdk.errors import SlackApiError


slack = slack_client("slack_conn")

_ch = None
_ts = None
_subscription = None


def init(ch: str, ts: str):
    """Initialize the Slack channel and thread timestamp."""
    global _ch, _ts, _subscription

    _subscription = subscribe(
        "slack_conn",
        f"data.type == 'message' && data.bot_id == '' && data.thread_ts == '{ts}'",
    )

    _ch = ch
    _ts = ts


def _lookup_user(who: str) -> dict[str, any]:
    user_id = who
    if who.startswith("<@"):
        user_id = who[2:-1]
    elif who.startswith("@"):
        user_id = who[1:]
    elif "@" in who:
        try:
            user_id = slack.users_lookupByEmail(email=who)["user"]["id"]
        except SlackApiError as e:
            print(f"error: {e}")
            return None
    else:
        return None

    try:
        user = slack.users_info(user=user_id).get("user")
    except SlackApiError as e:
        print(f"error: {e}")
        return None

    print(f"lookup: {who} -> {user}")

    return user


def _post(text: str, user_id: str | None = None):
    ch, ts = _ch, _ts
    if user_id:
        ch, ts = user_id, None

    print(f"{ch}{(',' + ts) if ts else ''}: {text}")
    slack.chat_postMessage(channel=ch, text=text, thread_ts=ts)


def send(content: any, who: str | None = None):
    print(f"send: {who} <- {content}")
    if who:
        who = _lookup_user(who)
        if not who:
            _post(f"Sorry, I couldn't find the user {who}.")
            return

        who = who.get("id")

    _post(str(content), who)


def next_input():
    event = next_event(_subscription)
    if event is None:
        raise EOFError

    print(f"Q: {event.text}")

    return event.text


def ask(what: str, who: str, t: int | None = None) -> tuple[str, str]:
    user = _lookup_user(who)
    if not user:
        _post(f"Sorry, I couldn't find the user {who}.")
        return None, None

    user_id = user.get("id")

    send(f"â“ <@{user_id}>: {what}")

    while True:
        event = next_event(_subscription, timeout=t)
        if not event:
            return user, None

        if event.user == user_id:
            return user, event.text

        _post("Sorry, only the person mentioned can respond.")



================================================
FILE: kittehub/ai_agents/openai_agent_researcher/tools.py
================================================
"""Agent tools for the OpenAI agent."""

from agents import function_tool

import data
import slack


@function_tool
async def send_slack_report(r: data.Report, user: str) -> None:
    """Send a Slack report to the given user."""
    slack.send(r, user)



================================================
FILE: kittehub/ai_agents/openai_agent_researcher/workflow.py
================================================
"""Main workflow logic."""

from os import getenv

import ai
import data
import slack


_prefix = f"!{getenv('INVOCATION_CMD', 'research')} "


def workflow(q: str):
    """Run the entire interaction with the user.

    There are three phases:
    1. Plan the search.
    2. Execute the search.
    3. Report the results.
    """
    # Plan the search.
    search_plan = ai.plan(q)

    # Iterate over all tasks in the plan and execute them.
    slack.send("Now I will execute on the plan.\n")
    tasks: dict[str, data.ResearchItem] = {}
    for t in search_plan.tasks:
        match type(t):
            case data.SearchResearchItem:
                slack.send(f"ðŸ” Searching for: {t.query}...")
                tasks[f"Search query result for {t.query}"] = ai.search(t)
            case data.AskSomeoneResearchItem:
                slack.send(f"ðŸ’¬ Asking {t.who} the question: {t.question}...")
                who, answer = slack.ask(t.question, t.who, t.wait_time_in_seconds)
                if who:
                    if not answer:
                        slack.send(f"{who['real_name']} did not answer the question.")
                        answer = "No answer"

                    tasks[f"According to the user {who['real_name']}"] = answer
                else:
                    tasks[f"According to the user {t.who}"] = (
                        f"could not figure out which user is {t.who}"
                    )

    # Summarize and report the results.
    slack.send("All tasks complete, summarizing results...")
    ai.report(search_plan.question, tasks)


def on_slack_message(event):
    text = event.data.text

    if not text.startswith(_prefix):
        print("irrelevant")
        return

    slack.init(event.data.channel, event.data.ts)

    q = text.removeprefix(_prefix)
    print(f"Q: {q}")

    workflow(q)



================================================
FILE: kittehub/ai_chat_assistant/README.md
================================================
title: AI chat assistant
description: A Slack-based automation assistant that leverages ChatGPT to manage and respond to messages by integrating with GitHub and Google Sheets.
integrations: ["chatgpt", "github", "sheets", "slack"]
categories: ["AI"]



================================================
FILE: kittehub/ai_chat_assistant/ai.py
================================================
"""This module provides the main functionality for the AI chatbot assistant.

It integrates with Slack and uses OpenAI's GPT model to generate responses based
on user messages. It also interacts with Google Sheets to store and retrieve data.
"""

import json
import os
from pathlib import Path

import autokitteh
from autokitteh.openai import openai_client
from autokitteh.slack import slack_client

import helpers
from repo_scanner import find_unanswered_comments


REPO_NAME = os.getenv("REPO_NAME")
SHEET_ID = os.getenv("SHEET_ID")
SHEET_NAME = os.getenv("SHEET_NAME")
SYSTEM_PROMPT = Path("prompt.txt").read_text()

chatgpt = openai_client("chatgpt_conn")
slack = slack_client("slack_conn")


def on_activate(_):
    """Entrypoint for the AI chatbot assistant."""
    while True:
        print("Waiting for a message...")
        subs = autokitteh.subscribe("slack_conn", "event_type == 'message'")
        data = autokitteh.next_event(subs)
        if data:
            on_slack_message(data)


def on_slack_message(data):
    """Determine the action to take based on an incoming Slack message.

    Args:
        data: The data from the Slack event.
    """
    user, user_text = data["user"], data["text"]
    response = get_chatgpt_response(user_text)

    # Always send initial response.
    slack.chat_postMessage(channel=user, text=response["message"])

    match response["action"]:
        case "list":
            rows = helpers.get_sheets_data(SHEET_NAME)
            message = helpers.format_messages_for_slack(rows)
            slack.chat_postMessage(channel=user, text=message)
        case "scan":
            comments = find_unanswered_comments(REPO_NAME, user)
            helpers.append_row_to_sheet(SHEET_NAME, comments)
            rows = helpers.get_sheets_data(SHEET_NAME)
            message = helpers.format_messages_for_slack(rows)
            slack.chat_postMessage(channel=user, text=message)


def get_chatgpt_response(user_text):
    response = chatgpt.chat.completions.create(
        model="gpt-4o-mini",
        response_format={"type": "json_object"},
        messages=[
            {"role": "system", "content": SYSTEM_PROMPT},
            {"role": "user", "content": user_text},
        ],
    )
    return json.loads(response.choices[0].message.content)



================================================
FILE: kittehub/ai_chat_assistant/autokitteh.yaml
================================================
version: v1

project:
  name: ai_chatbot_assistant

  vars:
    - name: SHEET_ID
      value:
    - name: SHEET_NAME
      value:
    - name: REPO_NAME
      value:

  connections:
    - name: chatgpt_conn
      integration: chatgpt
    - name: github_conn
      integration: github
    - name: sheets_conn
      integration: googlesheets
    - name: slack_conn
      integration: slack



================================================
FILE: kittehub/ai_chat_assistant/helpers.py
================================================
"""Helper functions for Google Sheets and Slack."""

import os

import autokitteh
from autokitteh.google import google_sheets_client


sheets = google_sheets_client("sheets_conn")

SHEET_ID = os.getenv("SHEET_ID")


@autokitteh.activity
def get_sheets_data(sheet_name: str) -> dict:
    """Get data from the specified Google Sheet.

    Args:
        sheet_name (str): The name of the sheet (tab).

    Returns:
        dict: The data from the sheet.
    """
    range_name = f"{sheet_name}!A:D"
    return (
        sheets.spreadsheets()
        .values()
        .get(spreadsheetId=SHEET_ID, range=range_name)
        .execute()
    )


@autokitteh.activity
def append_row_to_sheet(sheet_name: str, values: list):
    """Appends a row to the specified Google Sheet.

    Args:
        spreadsheet_id (str): The Google Spreadsheet ID.
        sheet_name (str): The name of the sheet (tab).
        values (list): List of tuples containing (pr_number, author, body, url).
    """
    range_name = f"{sheet_name}!A:D"  # Use columns A-D for the 4 values.
    # Transform list of tuples into list of lists for the API.
    formatted_values = [
        [str(comment_id), author, body, url] for comment_id, author, body, url in values
    ]
    body = {"values": formatted_values}

    sheets.spreadsheets().values().append(
        spreadsheetId=SHEET_ID,
        range=range_name,
        valueInputOption="RAW",
        insertDataOption="INSERT_ROWS",
        body=body,
    ).execute()


def format_messages_for_slack(rows):
    if not rows or "values" not in rows:
        return "No messages found."

    formatted_messages = []
    for row in rows["values"]:
        comment_id, author, body, url = row
        message = (
            f"*Comment ID:* {comment_id}\n"
            f"*Author:* {author}\n"
            f"*Message:* {body}\n"
            f"*URL:* {url}\n"
            "---"  # Add separator between messages.
        )
        formatted_messages.append(message)

    return "\n".join(formatted_messages)



================================================
FILE: kittehub/ai_chat_assistant/prompt.txt
================================================
You are an automation assistant that interprets plain-English requests into a structured JSON response.

Your response must be a JSON object with exactly two fields:
- "action": One of the following single-word responses: "list", "schedule", "track", "scan", "error", or "help".
- "message": A short, natural-sounding explanation of why the action was chosen or an error message. The message should be addressed to the user.

### Key Rules:
1. The "action" field must contain exactly one of the approved values.
2. The "message" field should be clear, concise, and slightly conversational to make responses feel more natural.
3. **Implemented actions**: "list", "scan".
   - Respond with the correct action and an appropriate message.
   - Example for "scan":
     {
       "action": "scan",
       "message": "Got it! I'll start scanning now. This might take up to a minute."
     }
   - Example for "list":
     {
       "action": "list",
       "message": "Sure! Here's what I found for you."
     }
   - If the request implies listing or scanning (e.g., "check for unresponded messages" â†’ "scan", "show me what I haven't responded to" â†’ "list"), interpret it accordingly.
4. **Not implemented actions**: "schedule", "track".
   - Respond with an "error" action:
     {
       "action": "error",
       "message": "Sorry, that feature isn't available yet."
     }
5. **Unrecognized requests**:
   - If the input doesnâ€™t match a known action or a reasonable variation, respond with:
     {
       "action": "error",
       "message": "I didnâ€™t quite get that. Try asking for 'list', 'scan', or 'help'."
     }
6. **Help requests**:
   - If the user asks for help, respond with "help" and provide an overview of the available actions:
     {
       "action": "help",
       "message": "I can list items, scan for updates, or provide help. Let me know what you need!"
     }
7. Always return **valid JSON**. Do not include any additional text outside the JSON response.



================================================
FILE: kittehub/ai_chat_assistant/repo_scanner.py
================================================
"""Find unanswered GitHub PR comments older than 24 hours.

It tracks processed comments with Google Sheets,
and retrieves user information from Slack.
"""

import datetime
import os

from autokitteh import github, google
from autokitteh.slack import slack_client

import helpers


g = github.github_client("github_conn")
slack = slack_client("slack_conn")
sheets = google.google_sheets_client("sheets_conn")


SHEET_ID = os.getenv("SHEET_ID")
SHEET_NAME = os.getenv("SHEET_NAME")


def find_unanswered_comments(
    repo_name: str, user: str
) -> list[tuple[str, str, str, str]]:
    """Entrypoint for finding unanswered comments."""
    print("Finding unanswered messages...")
    sheets_data = helpers.get_sheets_data(SHEET_NAME)
    comment_ids_set = set()
    if "values" in sheets_data:
        for row in sheets_data["values"]:
            comment_ids_set.add(int(row[0]))
    return get_github_comments(comment_ids_set, repo_name, user)


def get_github_comments(
    comment_ids_set: set,
    repo_name: str,
    user: str,
) -> list[tuple[str, str, str, str]]:
    """Get all comments from GitHub that haven't been responded to in over 24 hours."""
    repo = g.get_repo(repo_name)
    pulls = repo.get_pulls(state="open")

    user_email = get_email_by_slack_user_id(user)
    github_user_id = get_github_user_id_by_email(user_email)

    unresponded = []

    # Process each pull request.
    for pr in pulls:
        # Combine issue and inline comments.
        issue_comments = list(pr.get_issue_comments())
        inline_comments = list(pr.get_comments())
        for comments, is_inline in [(issue_comments, False), (inline_comments, True)]:
            process_comments(
                comments,
                comment_ids_set,
                unresponded,
                github_user_id,
                is_inline=is_inline,
            )

    return unresponded


def process_comments(
    comments: list,
    comment_ids_set: set,
    unresponded: list,
    github_user_id: str,
    is_inline: bool = False,
):
    """Process either issue comments (PR discussion) or inline review comments."""
    for comment in comments:
        if should_skip_comment(comment, github_user_id):
            continue

        if has_been_responded_to(comment, comments, is_inline, github_user_id):
            continue

        if comment.id not in comment_ids_set:
            unresponded.append(
                (comment.id, comment.user.login, comment.body, comment.html_url)
            )
            comment_ids_set.add(comment.id)


def has_been_responded_to(
    target_comment, potential_responses, is_inline, github_user_id
):
    # Skip if comment is less than 24 hours old.
    now = datetime.datetime.now(datetime.UTC)
    if now - target_comment.created_at < datetime.timedelta(hours=24):
        return True

    # Check for emoji reactions.
    for reaction in target_comment.get_reactions():
        if reaction.user.login == github_user_id:
            return True

    # Check for comment responses.
    for response in potential_responses:
        if (
            response.created_at > target_comment.created_at
            and response.user.login == github_user_id
        ):
            if is_inline:
                return True

            # For issue comments, check for @ mentions or quotes.
            if has_mention_or_quote(response, target_comment):
                return True

    return False


def should_skip_comment(comment, github_user_id: str):
    return comment.user.login == github_user_id or github_user_id not in comment.body


def has_mention_or_quote(response, original_comment):
    if "@" + original_comment.user.login in response.body:
        return True

    # Check for quote.
    for line in response.body.splitlines():
        if line.strip().startswith(">") and original_comment.body[:30] in line:
            return True

    return False


def get_email_by_slack_user_id(user_id: str):
    return (
        slack.users_info(user=user_id)
        .get("user", {})
        .get("profile", {})
        .get("email", "")
    )


def get_github_user_id_by_email(email: str):
    return g.search_users(query=email)[0].login



================================================
FILE: kittehub/anthropic_slack_thread_tldr/README.md
================================================
title: Anthropic Slack Thread TLDR
description: Summarizes a Slack thread using Claude
integrations: ["slack"]
categories: ["AI"]



================================================
FILE: kittehub/anthropic_slack_thread_tldr/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup
# of an AutoKitteh sample project that demonstrates integration with
# Gmail, ChatGPT, and Slack.

version: v1

project:
  name: anthropic_slack_thread_tldr

  vars:
    - name: ANTHROPIC_API_KEY
      secret: true
      # Put here your Anthropic API key.
      value: <your_anthropic_api_key_here>
    - # Maximum number of tokens to use per invocation.
      name: MAX_TOKENS
      value: "1000"
    - # The model to use for the Anthropic API.
      name: MODEL
      value: "claude-3-5-haiku-20241022"

  connections:
    # We use Slack to interact with the users.
    - name: slack
      integration: slack

  triggers:
    # Triggered when a Slack message event is a reply in a thread and begins with an exclamation mark (!).
    - name: slack_message
      connection: slack
      event_type: message
      filter: "data.thread_ts != '' && data.text == '!tldr'"
      call: workflow.py:on_slack_thread_message



================================================
FILE: kittehub/anthropic_slack_thread_tldr/requirements.txt
================================================
anthropic



================================================
FILE: kittehub/anthropic_slack_thread_tldr/workflow.py
================================================
"""Main workflow logic."""

from os import getenv

from anthropic import Anthropic
from autokitteh.slack import slack_client


slack_client = slack_client("slack")

anthropic_client = Anthropic(api_key=getenv("ANTHROPIC_API_KEY"))

_MAX_TOKENS = int(getenv("MAX_TOKENS", 1000))
_MODEL = getenv("MODEL", "claude-3-5-haiku-20241022")


def on_slack_thread_message(event):
    """Run the entire interaction with the user."""
    # `ts` is the timestamp of the message that triggered this event.
    # `thread_ts` is the timestamp of the parent message.
    ch, ts, thread_ts = event.data.channel, event.data.ts, event.data.thread_ts

    # give an immediate feedback.
    slack_client.reactions_add(
        channel=ch,
        timestamp=ts,
        name="thinking_face",
    )

    # get the entire thread.
    resp = slack_client.conversations_replies(channel=ch, ts=thread_ts)
    msgs = resp.get("messages", [])

    print(f"in: {len(msgs)} messages")

    # ask claude to summarize the thread.
    message = anthropic_client.messages.create(
        max_tokens=_MAX_TOKENS,
        messages=[
            {
                "role": "user",
                "content": (
                    "Compose a summary of the Slack conversation in this thread "
                    "using Slack mentions and markdown."
                    "Be concise - just emit bullet points."
                    "Here are the messages in the thread:\n"
                    "\n".join(f"\n- {msg['user']} said: {msg['text']}" for msg in msgs)
                ),
            }
        ],
        model=_MODEL,
    )

    print(f"claude: {message}")

    content = "".join(item.text for item in message.content if item.type == "text")

    print(f"tl;dr: {content}")

    # post the summary.
    slack_client.chat_postMessage(
        channel=ch,
        thread_ts=thread_ts,
        text=f"{content}",
    )

    # remove the thinking_face and add ok_hand, to indicate completion.
    slack_client.reactions_remove(channel=ch, timestamp=ts, name="thinking_face")
    slack_client.reactions_add(channel=ch, timestamp=ts, name="ok_hand")



================================================
FILE: kittehub/auth0_to_hubspot/README.md
================================================
title: Copy Auth0 Users to HubSpot
description: Periodically add new Auth0 users to HubSpot as contacts
integrations: ["auth0", "hubspot"]
categories: ["CRM"]



================================================
FILE: kittehub/auth0_to_hubspot/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup of
# an AutoKitteh project that adds new Auth0 users to HubSpot as contacts.

version: v1

project:
  name: auth0_to_hubspot

  vars:
    - name: HOURS
      value: 24

  connections:
    - name: auth0_conn
      integration: auth0
    - name: hubspot_conn
      integration: hubspot

  triggers:
    - name: daily
      schedule: "@every 24h"
      call: program.py:check_for_new_users



================================================
FILE: kittehub/auth0_to_hubspot/program.py
================================================
"""This program adds new Auth0 users to HubSpot as contacts."""

from datetime import datetime, timedelta, UTC
import os

from autokitteh.auth0 import auth0_client
from autokitteh.hubspot import hubspot_client
from hubspot.crm.contacts import SimplePublicObjectInput
from hubspot.crm.contacts.exceptions import ApiException


LOOKUP_HOURS = int(os.getenv("HOURS", "24"))

auth0 = auth0_client("auth0_conn")
hubspot = hubspot_client("hubspot_conn")


def check_for_new_users(event):
    """Workflow entrypoint.

    Looks up new Auth0 users in the last `HOURS` hours,
    and adds them to HubSpot as contacts.
    """
    start, end = _get_time_range(LOOKUP_HOURS)
    query = f"created_at:[{start} TO {end}]"
    response = auth0.users.list(q=query, search_engine="v3")
    add_new_users(response["users"])


def _get_time_range(hours):
    """Calculate start and end times for user lookup."""
    now = datetime.now(UTC)
    start_time = now - timedelta(hours=hours)

    start_formatted = start_time.strftime("%Y-%m-%dT%H:%M:%SZ")
    end_formatted = now.strftime("%Y-%m-%dT%H:%M:%SZ")
    return (start_formatted, end_formatted)


def add_new_users(users):
    """Add new Auth0 users to HubSpot as contacts."""
    for user in users:
        contact = _create_hubspot_contact(user)
        try:
            hubspot.crm.contacts.basic_api.create(contact)
            print(f"Added to HubSpot: {user['email']}")
        except ApiException as e:
            if e.status == 409:
                print(f"Contact already exists in HubSpot: {user['email']}")
            else:
                print(f"Failed to add {user['email']} to HubSpot: {e}")
            continue


def _create_hubspot_contact(user):
    """Convert Auth0 user data to HubSpot contact format."""
    first_name, last_name = _extract_name(user)

    user_data = {
        "email": user["email"],
        "firstname": first_name,
        "lastname": last_name,
    }
    return SimplePublicObjectInput(properties=user_data)


def _extract_name(user):
    """Extracts first and last name from user."""
    if "given_name" in user and "family_name" in user:
        return user["given_name"], user["family_name"]

    name_parts = user.get("name", "").split()
    first = name_parts[0] if len(name_parts) > 0 else ""
    last = " ".join(name_parts[1:]) if len(name_parts) > 1 else ""
    return first, last



================================================
FILE: kittehub/break_glass/README.md
================================================
title: Manage emergency AWS access requests via Slack
description: Submit emergency AWS access requests via Slack, which are then approved or denied based on a set of predefined conditions
integrations: ["aws", "slack"]
categories: ["DevOps"]



================================================
FILE: kittehub/break_glass/approval_message.json.txt
================================================
[
    {
        "type": "header",
        "text": {
            "type":  "plain_text",
            "emoji": true,
            "text":  "Break-Glass Request"
        }
    },
    {
        "type": "divider"
    },
    {
        "type": "section",
        "text": {
            "type": "mrkdwn",
            "text": "RequestFromMessage"
        }
    },
    {
        "type": "section",
        "text": {
            "type": "mrkdwn",
            "text": "Ticket"
        }
    },
    {
        "type": "divider"
    },
    {
        "type": "section",
        "text": {
            "type": "mrkdwn",
            "text": "Reason"
        }
    },
    {
        "type": "divider"
    },
    {
        "type": "actions",
        "elements": [
            {
                "type":  "button",
                "style": "primary",
                "text": {
                    "type":  "plain_text",
                    "emoji": true,
                    "text":  "Approve"
                },
                "value":     "Approve",
                "action_id": "Approve RequesterId IssueKey"
            },
            {
                "type":  "button",
                "style": "danger",
                "text": {
                    "type":  "plain_text",
                    "emoji": true,
                    "text":  "Deny"
                },
                "value":     "Deny",
                "action_id": "Deny RequesterId IssueKey"
            }
        ]
    }
]



================================================
FILE: kittehub/break_glass/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup
# of an AutoKitteh project that orchestrates the request and approval
# process for break glass scenarios.

version: v1

project:
  name: break_glass

  vars:
    - name: APPROVAL_CHANNEL
      value:

  connections:
    - name: jira_connection
      integration: jira
    - name: slack_connection
      integration: slack

  triggers:
    - name: slack_slash_command
      connection: slack_connection
      event_type: slash_command
      call: program.py:on_slack_slash_command
      filter: data.text == "break-glass"
    - name: form_submission
      connection: slack_connection
      event_type: interaction
      filter: data.type == "view_submission"
      call: program.py:on_form_submit
    - name: approve_deny
      connection: slack_connection
      event_type: interaction
      filter: data.type == "block_actions"
      call: program.py:on_approve_deny



================================================
FILE: kittehub/break_glass/program.py
================================================
"""This program orchestrates the request and approval process for break glass scenarios.

Break glass scenarios occur when a developer needs to access sensitive data or perform
a critical operation that requires elevated permissions beyond their usual access.

Workflow:
    1. A developer initiates the process by using a Slack slash command to request
       break glass approval.
    2. AutoKitteh sends a form to the developer, requesting details about the reason
       for the elevated access.
    3. The developer fills out and submits the form, providing the necessary information
       and justification for the request.
    4. AutoKitteh sends a notification to the SRE (Site Reliability Engineering) team
       with an approve/deny message, including the details of the request.
    5. The SRE team reviews the request and makes a decision to approve or deny the
       request.
    6. AutoKitteh sends a message to the developer with the decision, notifying them
       whether the request was approved or denied.

The program integrates with Jira to verify ticket existence and ensure the requester
is the assignee of the ticket. It also uses Slack for communication and notifications
throughout the process.
"""

import os
from pathlib import Path

import autokitteh
from autokitteh.atlassian import get_base_url, jira_client
from autokitteh.slack import slack_client
from requests.exceptions import HTTPError


APPROVAL_CHANNEL = os.getenv("APPROVAL_CHANNEL")
jira = jira_client("jira_connection")
slack = slack_client("slack_connection")


def on_slack_slash_command(event):
    """Sends a form to request approval for a ticket."""
    trigger_id = event.data["trigger_id"]
    request_modal = Path("request_modal.json.txt").read_text()
    slack.views_open(trigger_id=trigger_id, view=request_modal)


@autokitteh.activity
def on_form_submit(event):
    reason, issue_key, base_url, requester_id = parse_event_data(event)

    if not check_issue_exists(issue_key):
        message = f"Ticket `{issue_key}` does not exist. Please try again."
        slack.chat_postMessage(channel=requester_id, text=message)
        return

    email = slack.users_info(user=requester_id)["user"]["profile"]["email"]
    if not validate_requester(issue_key, email):
        issue_link = f"<{base_url}/browse/{issue_key}|{issue_key}>"
        message = f"You are not the assignee in ticket {issue_link}. Please try again."
        slack.chat_postMessage(channel=requester_id, text=message)
        return

    send_approval_request(reason, issue_key, base_url, requester_id)
    slack.chat_postMessage(channel=requester_id, text="Request sent for approval.")


@autokitteh.activity
def on_approve_deny(event):
    action_id = event.data["actions"][0]["action_id"]
    _, requester, issue_key = action_id.split(" ")
    approver_id = event.data["user"]["id"]
    approver_info = slack.users_info(user=approver_id)

    if event.data["actions"][0]["value"] == "Approve":
        approver_email = approver_info["user"]["profile"]["email"]
        jira.issue_add_comment(issue_key, f"Request approved by: {approver_email}")
        message = f"Request approved by: <@{approver_info['user']['name']}>"
        slack.chat_postMessage(channel=requester, text=message)
    else:
        print(f"Requester: {requester}")
        message = f"Request denied by: <@{approver_info['user']['name']}>"
        slack.chat_postMessage(channel=requester, text=message)


def send_approval_request(reason, issue_key, base_url, requester_id):
    blocks = Path("approval_message.json.txt").read_text()
    changes = [
        ("RequestFromMessage", f"*Request from*: <@{requester_id}>"),
        ("Ticket", f"*Ticket*: <{base_url}/browse/{issue_key}|{issue_key}>"),
        ("Reason", "*Reason for request*: " + reason),
        ("RequesterId", requester_id),
        ("IssueKey", issue_key),
    ]
    for old, new in changes:
        blocks = blocks.replace(old, new)
    slack.chat_postMessage(channel=APPROVAL_CHANNEL, blocks=blocks)


def parse_event_data(event):
    form_data = event.data["view"]["state"]["values"]
    reason = form_data["block_reason"]["reason"]["value"]
    issue_key = form_data["block_issue_key"]["issue_key"]["value"]
    base_url = get_base_url("jira_connection")
    requester_id = event.data["user"]["id"]
    return reason, issue_key, base_url, requester_id


def check_issue_exists(issue_key):
    try:
        jira.issue(issue_key)
        return True
    except HTTPError as e:
        print(f"Error retrieving issue: {e}")
        return False


def validate_requester(issue_key, requester):
    issue = jira.issue(issue_key)
    assignee = issue.get("fields", {}).get("assignee") or {}
    assignee = assignee.get("emailAddress")
    return assignee == requester



================================================
FILE: kittehub/break_glass/request_modal.json.txt
================================================
{
  "title": {
    "type": "plain_text",
    "text": "My App",
    "emoji": true
  },
  "submit": {
    "type": "plain_text",
    "text": "Submit",
    "emoji": true
  },
  "type": "modal",
  "close": {
    "type": "plain_text",
    "text": "Cancel",
    "emoji": true
  },
  "blocks": [
    {
      "type": "input",
      "block_id": "block_issue_key",
      "element": {
        "type": "plain_text_input",
        "action_id": "issue_key"
      },
      "label": {
        "type": "plain_text",
        "text": "Reference Ticket ID",
        "emoji": true
      }
    },
    {
      "type": "input",
      "block_id": "block_reason",
      "element": {
        "type": "plain_text_input",
        "multiline": true,
        "action_id": "reason"
      },
      "label": {
        "type": "plain_text",
        "text": "Reason",
        "emoji": true
      }
    }
  ]
}



================================================
FILE: kittehub/categorize_emails/README.md
================================================
title: Email categorization and notification
description: Categorize incoming emails and notify relevant Slack channels
integrations: ["gmail", "chatgpt", "slack"]
categories: ["AI", "Productivity"]



================================================
FILE: kittehub/categorize_emails/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup
# of an AutoKitteh sample project that demonstrates integration with 
# Gmail, ChatGPT, and Slack.

version: v1

project:
  name: categorize_emails

  vars:
    - name: POLL_INTERVAL
      value: 10

  connections:
    - name: my_chatgpt
      integration: chatgpt
    - name: my_gmail
      integration: gmail
    - name: my_slack
      integration: slack

  triggers:
    - name: receive_http_get
      type: webhook
      call: program.py:on_http_get



================================================
FILE: kittehub/categorize_emails/program.py
================================================
"""A real-life workflow that integrates Gmail, ChatGPT, and Slack:

1. Trigger: Detect a new email in Gmail.
2. Categorize: Use ChatGPT to read and categorize the email
   (e.g., technical work, marketing, sales).
3. Notify: Send a message to the corresponding Slack channel based on the category.
4. Label: Add a label to the email in Gmail.
"""

import base64
from datetime import datetime, UTC
import os
import time

import autokitteh
from autokitteh.google import gmail_client
from autokitteh.openai import openai_client
from autokitteh.slack import slack_client


POLL_INTERVAL = float(os.getenv("POLL_INTERVAL"))
SLACK_CHANNELS = ["demos", "engineering", "ui"]


gmail = gmail_client("my_gmail").users()
slack = slack_client("my_slack")
processed_message_ids = set()
start_time = datetime.now(UTC).timestamp()


def on_http_get(event):
    while True:
        _poll_inbox()
        time.sleep(POLL_INTERVAL)


def _poll_inbox():
    current_message_ids = set()
    results = get_new_inbox_messages()
    current_message_ids.update({msg["id"] for msg in results.get("messages", [])})
    new_message_ids = current_message_ids - processed_message_ids

    for message_id in new_message_ids:
        _process_email(message_id, start_time)

    processed_message_ids.update(new_message_ids)


def _process_email(message_id: str, start_time: datetime):
    message = gmail.messages().get(userId="me", id=message_id).execute()
    email_timestamp = float(message["internalDate"]) / 1000

    if email_timestamp < start_time:
        return

    email_content = _parse_email(message)

    if not email_content:
        print("Email content not found.")
        return

    channel = _categorize_email(email_content)

    if not channel:
        print("Could not categorize email.")
        return

    slack.chat_postMessage(channel=channel, text=email_content)

    # Add label to email
    label_id = _get_label_id(channel) or _create_label(channel)
    if not label_id:
        return

    body = {"addLabelIds": [label_id]}
    gmail.messages().modify(userId="me", id=message_id, body=body).execute()


def _parse_email(message: dict):
    payload = message["payload"]
    parts = payload.get("parts", [])
    for part in parts:
        if part.get("mimeType") == "text/plain":
            email_body = base64.urlsafe_b64decode(part["body"]["data"]).decode("utf-8")
            return email_body
    return None


def _create_label(label_name: str) -> str:
    """Create a new label in the user's gmail account.

    https://developers.google.com/gmail/api/reference/rest/v1/users.labels#Label
    """
    label = {
        "labelListVisibility": "labelShow",
        "messageListVisibility": "show",
        "name": label_name,
    }
    created_label = gmail.labels().create(userId="me", body=label).execute()
    return created_label.get("id", None)


def _get_label_id(label_name: str) -> str:
    labels_response = gmail.labels().list(userId="me").execute()
    labels = labels_response.get("labels", [])
    for label in labels:
        if label["name"] == label_name:
            return label["id"]
    return None


def get_new_inbox_messages():
    query = "in:inbox -in:drafts"
    return gmail.messages().list(userId="me", q=query, maxResults=10).execute()


@autokitteh.activity
def _categorize_email(email_content: str) -> str:
    """Prompt ChatGPT to categorize an email based on its content.

    Returns:
        The name of the Slack channel to send a message to as a string.
        If the channel is not in the provided list, returns None.
    """
    client = openai_client("my_chatgpt")
    response = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[
            {"role": "system", "content": "You are a helpful assistant."},
            {
                "role": "user",
                "content": (
                    "Categorize the following email based on its topic and suggest a "
                    "channel to post it in from the provided list. The output should "
                    "be one of the channels in {SLACK_CHANNELS} and nothing else, "
                    "for example: {SLACK_CHANNELS[0]}\n\nEmail content: {email_content}"
                ),
            },
        ],
    )
    channel = response.choices[0].message.content
    return channel if channel in SLACK_CHANNELS else None



================================================
FILE: kittehub/confluence_to_slack/README.md
================================================
title: Slack notify on Confluence page created
description: When Confluence page is created the user will be notified on Slack
integrations: ["confluence", "slack"]
categories: ["DevOps"]



================================================
FILE: kittehub/confluence_to_slack/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup of
# an AutoKitteh project that announces new Confluence pages in Slack.

version: v1

project:
  name: confluence_to_slack

  vars:
    - name: FILTER_LABEL
      value:
    - name: SLACK_CHANNEL_NAME_OR_ID
      value:
    - name: SNIPPET_LENGTH
      value: 150

  connections:
    - name: confluence_connection
      integration: confluence
    - name: slack_connection
      integration: slack

  triggers:
    - name: confluence_page_created
      connection: confluence_connection
      event_type: page_created
      filter: data.page.spaceKey == "CONFLUENCE_SPACE_KEY"
      call: program.py:on_confluence_page_created



================================================
FILE: kittehub/confluence_to_slack/program.py
================================================
"""A real-life workflow that integrates Confluence and Slack.

Workflow:
    1. Trigger: a new page is created in Confluence
    2. Static filter: the page is in a specific Confluence space
       (specified in the "autokitteh.yaml" manifest file)
    3. Runtime filter: check if the page has a specific label
    4. Notify: send a message to a Slack channel with a snippet of the page
"""

import os

from autokitteh.atlassian import confluence_client
from autokitteh.slack import slack_client


def on_confluence_page_created(event):
    """Workflow's entry-point."""
    confluence = confluence_client("confluence_connection")
    page_id = event.data.page.id

    # Ignore pages without the filter label, if specified.
    page_labels = confluence.get_page_labels(page_id)["results"]
    label_names = [label["name"] for label in page_labels]
    if os.getenv("FILTER_LABEL") not in label_names + [""]:
        print(f"Filter label not found in page: {label_names}")
        return

    # Read the page body.
    res = confluence.get_page_by_id(page_id, expand="body.view")
    html_body = res["body"]["view"]["value"]

    _send_slack_message(event.data.page, html_body)


def _send_slack_message(page, html_body):
    snippet_length = int(os.getenv("SNIPPET_LENGTH"))
    message = f"""
    A new page has been created in the `{page.spaceKey}` space.
    *Title*: {page.title}
    *Snippet*: ```{html_body[:snippet_length]}\n```
    <{page.self}|Link to page>
    """

    slack = slack_client("slack_connection")
    channel = os.getenv("SLACK_CHANNEL_NAME_OR_ID", "")
    slack.chat_postMessage(channel=channel, text=message)



================================================
FILE: kittehub/data_pipeline/README.md
================================================
title: ETL Pipeline From S3 to SQLite
description: Processes GPX files from S3 and inserts them into a SQLite database, creating a data pipeline from cloud to structured data
integrations: ["aws", "http", "sqlite3"]
categories: ["DevOps"]



================================================
FILE: kittehub/data_pipeline/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup
# of an AutoKitteh project that parses GPX files when uploaded to
# an S3 bucket, and inserts the data into a SQLite database.

version: v1

project:
  name: pipeline

  vars:
    - name: CREATE_DB
      value: false
    - name: DB_DSN
      secret: true
      value:

  connections:
    - name: aws_conn
      integration: aws

  triggers:
    - name: new_s3_object
      type: webhook
      event_type: post
      call: pipeline.py:on_new_s3_object



================================================
FILE: kittehub/data_pipeline/bucket_event.json
================================================
{
  "Records": [
    {
      "eventVersion": "2.1",
      "eventSource": "aws:s3",
      "awsRegion": "us-west-2",
      "eventTime": "1970-01-01T00:00:00.000Z",
      "eventName": "ObjectCreated:Put",
      "userIdentity": {
        "principalId": "AIDAJDPLRKLG7UEXAMPLE"
      },
      "requestParameters": {
        "sourceIPAddress": "127.0.0.1"
      },
      "responseElements": {
        "x-amz-request-id": "C3D13FE58DE4C810",
        "x-amz-id-2": "FMyUVURIY8/IgAtTv8xRjskZQpcIZ9KG4V5Wp6S7S/JRWeUWerMUE5JgHvANOjpD"
      },
      "s3": {
        "s3SchemaVersion": "1.0",
        "configurationId": "testConfigRule",
        "bucket": {
          "name": "mybucket",
          "ownerIdentity": {
            "principalId": "A3NL1KOZZKExample"
          },
          "arn": "arn:aws:s3:::mybucket"
        },
        "object": {
          "key": "HappyFace.jpg",
          "size": 1024,
          "eTag": "d41d8cd98f00b204e9800998ecf8427e",
          "versionId": "096fKKXTRTtl3on89fVO.nfljtsv6qko",
          "sequencer": "0055AED6DCD90281E5"
        }
      }
    }
  ]
}



================================================
FILE: kittehub/data_pipeline/example-sns-event.json
================================================
{
  "Type": "Notification",
  "MessageId": "7db2e638-a87f-5e63-8faa-b8cc6d8b294d",
  "TopicArn": "arn:aws:sns:eu-north-1:975050051518:hikes",
  "Subject": "Amazon S3 Notification",
  "Message": "{\"Records\":[{\"eventVersion\":\"2.1\",\"eventSource\":\"aws:s3\",\"awsRegion\":\"eu-north-1\",\"eventTime\":\"2024-06-25T13:18:43.193Z\",\"eventName\":\"ObjectCreated:Put\",\"userIdentity\":{\"principalId\":\"AWS:AROA6GBMDB67DH6QBEE75:miki\"},\"requestParameters\":{\"sourceIPAddress\":\"62.0.134.40\"},\"responseElements\":{\"x-amz-request-id\":\"396RJHM7A05CBDFX\",\"x-amz-id-2\":\"le/wihJ5KVdyKCdYy91HNlBerbBaTtOIEnUFvnWBIUyFRmy75S4IB3IX9dIHZ033RE+mOOMWzN4OwcVBvbZw3jpVYiT6uDiYvTUaXewfDwk=\"},\"s3\":{\"s3SchemaVersion\":\"1.0\",\"configurationId\":\"new\",\"bucket\":{\"name\":\"ak-miki-hikes\",\"ownerIdentity\":{\"principalId\":\"A3RBVIBHMVQI0T\"},\"arn\":\"arn:aws:s3:::ak-miki-hikes\"},\"object\":{\"key\":\"simple.tar.gz\",\"size\":758,\"eTag\":\"d6805ceca3d89e3f784a5c6ec9a5a483\",\"sequencer\":\"00667AC3B32730E451\"}}}]}",
  "Timestamp": "2024-06-25T13:18:44.098Z",
  "SignatureVersion": "1",
  "Signature": "WJUHeHE5DIvKDRkSIe0mjHBCbt4WdAdR68s72w5GOUI4/G5Me1r1ZI1KWYLYPbMECucH6PKFW2XfgSERlOtpUdZkFkf0gdy3TqVB+Jmrm1x4MjLTrEHGQ27GFApj3MRTLiFOBJFUNo1KE9hNpJuZKcX3g0VjD7+xFc3uYqJT4KHTBY+2rpt3BnKBfIZEswhajFBWZ9Ro1izfXBYl2NYPBvGMC1xd2l6IQqMDfjev0pkIUcq9lAFXbwpCWW+SV5kW4Tut0Pso8EHzu2lGzmbBSlpQXC8ZCHBz07PtuVL5Cy0Uc5KvEd2XepVmu4OtzZwRNye9C1mQKh2WRQLuDEB/5A==",
  "SigningCertURL": "https://sns.eu-north-1.amazonaws.com/SimpleNotificationService-60eadc530605d63b8e62a523676ef735.pem",
  "UnsubscribeURL": "https://sns.eu-north-1.amazonaws.com/?Action=Unsubscribe&SubscriptionArn=arn:aws:sns:eu-north-1:975050051518:hikes:18b9ba01-43f1-4a6f-a5a1-95c76a68f760"
}



================================================
FILE: kittehub/data_pipeline/hike.gpx
================================================
ï»¿<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<gpx xmlns="http://www.topografix.com/GPX/1/1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.1" creator="IsraelHikingMap" xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd">
  <metadata>
    <bounds maxlat="32.680672" maxlon="35.550432" minlat="32.66142" minlon="35.527852"></bounds>
  </metadata>
  <trk>
    <name>Track 1</name>
    <desc></desc>
    <extensions>
      <Color xmlns="">#0000FF</Color>
      <Opacity xmlns="">0.4</Opacity>
      <Weight xmlns="">9</Weight>
    </extensions>
    <trkseg>
      <trkpt lat="32.66429557567092" lon="35.5502878042069">
        <ele>-169.07609930747446</ele>
      </trkpt>
      <trkpt lat="32.66429557567092" lon="35.5502878042069">
        <ele>-169.07609930747446</ele>
      </trkpt>
      <extensions>
        <RoutingType xmlns="">Hike</RoutingType>
      </extensions>
    </trkseg>
    <trkseg>
      <trkpt lat="32.664127" lon="35.550432">
        <ele>-172.5</ele>
      </trkpt>
      <trkpt lat="32.664127" lon="35.550432">
        <ele>-172.5</ele>
      </trkpt>
      <extensions>
        <RoutingType xmlns="">Hike</RoutingType>
      </extensions>
    </trkseg>
    <trkseg>
      <trkpt lat="32.664127" lon="35.550432">
        <ele>-172.5</ele>
      </trkpt>
      <trkpt lat="32.664014" lon="35.550246">
        <ele>-170</ele>
      </trkpt>
      <trkpt lat="32.663985" lon="35.550159">
        <ele>-169</ele>
      </trkpt>
      <trkpt lat="32.663981" lon="35.550029">
        <ele>-168</ele>
      </trkpt>
      <trkpt lat="32.663914" lon="35.549831">
        <ele>-165</ele>
      </trkpt>
      <trkpt lat="32.663727" lon="35.54982">
        <ele>-164</ele>
      </trkpt>
      <trkpt lat="32.663713" lon="35.549789">
        <ele>-163</ele>
      </trkpt>
      <trkpt lat="32.663687" lon="35.549805">
        <ele>-163</ele>
      </trkpt>
      <trkpt lat="32.663529" lon="35.549685">
        <ele>-163</ele>
      </trkpt>
      <trkpt lat="32.663217" lon="35.549144">
        <ele>-160</ele>
      </trkpt>
      <trkpt lat="32.662975" lon="35.54895">
        <ele>-160</ele>
      </trkpt>
      <trkpt lat="32.662924" lon="35.548875">
        <ele>-158</ele>
      </trkpt>
      <trkpt lat="32.662839" lon="35.548468">
        <ele>-152</ele>
      </trkpt>
      <trkpt lat="32.662707" lon="35.548324">
        <ele>-151</ele>
      </trkpt>
      <trkpt lat="32.662543" lon="35.547956">
        <ele>-148</ele>
      </trkpt>
      <trkpt lat="32.662536" lon="35.547759">
        <ele>-146</ele>
      </trkpt>
      <trkpt lat="32.662345" lon="35.5475">
        <ele>-148</ele>
      </trkpt>
      <trkpt lat="32.662309" lon="35.547241">
        <ele>-145</ele>
      </trkpt>
      <trkpt lat="32.662241" lon="35.547111">
        <ele>-145</ele>
      </trkpt>
      <trkpt lat="32.662244" lon="35.546742">
        <ele>-142</ele>
      </trkpt>
      <trkpt lat="32.662313" lon="35.546494">
        <ele>-140</ele>
      </trkpt>
      <trkpt lat="32.66227" lon="35.546274">
        <ele>-138</ele>
      </trkpt>
      <trkpt lat="32.662103" lon="35.545903">
        <ele>-138</ele>
      </trkpt>
      <trkpt lat="32.661961" lon="35.545805">
        <ele>-137</ele>
      </trkpt>
      <trkpt lat="32.661917" lon="35.545658">
        <ele>-136</ele>
      </trkpt>
      <trkpt lat="32.661999" lon="35.545512">
        <ele>-135</ele>
      </trkpt>
      <trkpt lat="32.661929" lon="35.545321">
        <ele>-133</ele>
      </trkpt>
      <trkpt lat="32.661946" lon="35.545113">
        <ele>-130</ele>
      </trkpt>
      <trkpt lat="32.662031" lon="35.54501">
        <ele>-129</ele>
      </trkpt>
      <trkpt lat="32.662115" lon="35.544978">
        <ele>-129</ele>
      </trkpt>
      <trkpt lat="32.662165" lon="35.544836">
        <ele>-127</ele>
      </trkpt>
      <trkpt lat="32.662046" lon="35.544463">
        <ele>-123</ele>
      </trkpt>
      <trkpt lat="32.661959" lon="35.544326">
        <ele>-119</ele>
      </trkpt>
      <trkpt lat="32.662033" lon="35.544208">
        <ele>-119</ele>
      </trkpt>
      <trkpt lat="32.662091" lon="35.543883">
        <ele>-114</ele>
      </trkpt>
      <trkpt lat="32.662015" lon="35.543746">
        <ele>-113</ele>
      </trkpt>
      <trkpt lat="32.661911" lon="35.54363">
        <ele>-111</ele>
      </trkpt>
      <trkpt lat="32.661797" lon="35.543608">
        <ele>-108</ele>
      </trkpt>
      <trkpt lat="32.661737" lon="35.543517">
        <ele>-108</ele>
      </trkpt>
      <trkpt lat="32.661815" lon="35.543176">
        <ele>-105</ele>
      </trkpt>
      <trkpt lat="32.661773" lon="35.542971">
        <ele>-104</ele>
      </trkpt>
      <trkpt lat="32.661622" lon="35.54283">
        <ele>-101</ele>
      </trkpt>
      <trkpt lat="32.661553" lon="35.542532">
        <ele>-101</ele>
      </trkpt>
      <trkpt lat="32.661546" lon="35.542338">
        <ele>-96</ele>
      </trkpt>
      <trkpt lat="32.661626" lon="35.542215">
        <ele>-96</ele>
      </trkpt>
      <trkpt lat="32.661588" lon="35.542106">
        <ele>-94</ele>
      </trkpt>
      <trkpt lat="32.661562" lon="35.5418">
        <ele>-88</ele>
      </trkpt>
      <trkpt lat="32.661512" lon="35.54157">
        <ele>-85</ele>
      </trkpt>
      <trkpt lat="32.661575" lon="35.541434">
        <ele>-83</ele>
      </trkpt>
      <trkpt lat="32.661626" lon="35.541153">
        <ele>-80</ele>
      </trkpt>
      <trkpt lat="32.661573" lon="35.540903">
        <ele>-78</ele>
      </trkpt>
      <trkpt lat="32.661442" lon="35.540574">
        <ele>-74</ele>
      </trkpt>
      <trkpt lat="32.66142" lon="35.540324">
        <ele>-71</ele>
      </trkpt>
      <trkpt lat="32.661504" lon="35.540137">
        <ele>-70</ele>
      </trkpt>
      <trkpt lat="32.661622" lon="35.540019">
        <ele>-69</ele>
      </trkpt>
      <trkpt lat="32.661697" lon="35.539837">
        <ele>-66</ele>
      </trkpt>
      <trkpt lat="32.661739" lon="35.53945">
        <ele>-61</ele>
      </trkpt>
      <trkpt lat="32.661967" lon="35.539182">
        <ele>-57</ele>
      </trkpt>
      <trkpt lat="32.662109" lon="35.539046">
        <ele>-54</ele>
      </trkpt>
      <trkpt lat="32.662269" lon="35.538802">
        <ele>-52</ele>
      </trkpt>
      <trkpt lat="32.662356" lon="35.538588">
        <ele>-51</ele>
      </trkpt>
      <trkpt lat="32.662532" lon="35.538391">
        <ele>-48</ele>
      </trkpt>
      <trkpt lat="32.662582" lon="35.538052">
        <ele>-45</ele>
      </trkpt>
      <trkpt lat="32.662552" lon="35.537822">
        <ele>-41</ele>
      </trkpt>
      <trkpt lat="32.662456" lon="35.53769">
        <ele>-42</ele>
      </trkpt>
      <trkpt lat="32.662439" lon="35.537408">
        <ele>-35</ele>
      </trkpt>
      <trkpt lat="32.662501" lon="35.537249">
        <ele>-34</ele>
      </trkpt>
      <trkpt lat="32.662698" lon="35.53703">
        <ele>-26</ele>
      </trkpt>
      <trkpt lat="32.662826" lon="35.536767">
        <ele>-18</ele>
      </trkpt>
      <trkpt lat="32.662819" lon="35.536571">
        <ele>-15</ele>
      </trkpt>
      <trkpt lat="32.662747" lon="35.536375">
        <ele>-13</ele>
      </trkpt>
      <trkpt lat="32.662764" lon="35.536226">
        <ele>-10</ele>
      </trkpt>
      <trkpt lat="32.662869" lon="35.536058">
        <ele>-7</ele>
      </trkpt>
      <trkpt lat="32.662898" lon="35.535845">
        <ele>-4</ele>
      </trkpt>
      <trkpt lat="32.663032" lon="35.535714">
        <ele>-2</ele>
      </trkpt>
      <trkpt lat="32.663394" lon="35.535653">
        <ele>6</ele>
      </trkpt>
      <trkpt lat="32.66351" lon="35.535359">
        <ele>7</ele>
      </trkpt>
      <trkpt lat="32.66386" lon="35.53504">
        <ele>17</ele>
      </trkpt>
      <trkpt lat="32.663908" lon="35.534654">
        <ele>26</ele>
      </trkpt>
      <trkpt lat="32.664087" lon="35.534147">
        <ele>43</ele>
      </trkpt>
      <trkpt lat="32.664077" lon="35.533937">
        <ele>46</ele>
      </trkpt>
      <trkpt lat="32.664127" lon="35.533762">
        <ele>49</ele>
      </trkpt>
      <trkpt lat="32.664055" lon="35.533478">
        <ele>50</ele>
      </trkpt>
      <trkpt lat="32.664116" lon="35.533422">
        <ele>52</ele>
      </trkpt>
      <trkpt lat="32.664202" lon="35.53341">
        <ele>53</ele>
      </trkpt>
      <trkpt lat="32.66427" lon="35.53343">
        <ele>55</ele>
      </trkpt>
      <trkpt lat="32.664406" lon="35.533008">
        <ele>58</ele>
      </trkpt>
      <trkpt lat="32.66453" lon="35.532744">
        <ele>61</ele>
      </trkpt>
      <trkpt lat="32.664566" lon="35.532538">
        <ele>62</ele>
      </trkpt>
      <trkpt lat="32.664632" lon="35.532389">
        <ele>63</ele>
      </trkpt>
      <trkpt lat="32.664794" lon="35.532264">
        <ele>65</ele>
      </trkpt>
      <trkpt lat="32.665046" lon="35.532298">
        <ele>69</ele>
      </trkpt>
      <trkpt lat="32.665161" lon="35.532246">
        <ele>72</ele>
      </trkpt>
      <trkpt lat="32.665259" lon="35.532147">
        <ele>73</ele>
      </trkpt>
      <trkpt lat="32.665397" lon="35.531922">
        <ele>74</ele>
      </trkpt>
      <trkpt lat="32.665601" lon="35.531805">
        <ele>79</ele>
      </trkpt>
      <trkpt lat="32.665886" lon="35.531675">
        <ele>84</ele>
      </trkpt>
      <trkpt lat="32.665912" lon="35.531516">
        <ele>83</ele>
      </trkpt>
      <trkpt lat="32.666173" lon="35.531488">
        <ele>89</ele>
      </trkpt>
      <trkpt lat="32.666404" lon="35.531198">
        <ele>106</ele>
      </trkpt>
      <trkpt lat="32.666586" lon="35.53103">
        <ele>115</ele>
      </trkpt>
      <trkpt lat="32.666675" lon="35.530718">
        <ele>122</ele>
      </trkpt>
      <trkpt lat="32.666854" lon="35.530315">
        <ele>133</ele>
      </trkpt>
      <extensions>
        <RoutingType xmlns="">Hike</RoutingType>
      </extensions>
    </trkseg>
    <trkseg>
      <trkpt lat="32.666854" lon="35.530315">
        <ele>133</ele>
      </trkpt>
      <trkpt lat="32.666969" lon="35.530055">
        <ele>144</ele>
      </trkpt>
      <trkpt lat="32.666939" lon="35.529779">
        <ele>153</ele>
      </trkpt>
      <trkpt lat="32.666952" lon="35.529501">
        <ele>161</ele>
      </trkpt>
      <trkpt lat="32.667031" lon="35.529383">
        <ele>163</ele>
      </trkpt>
      <trkpt lat="32.667145" lon="35.529354">
        <ele>164</ele>
      </trkpt>
      <trkpt lat="32.667305" lon="35.52956">
        <ele>162</ele>
      </trkpt>
      <trkpt lat="32.667453" lon="35.529548">
        <ele>162</ele>
      </trkpt>
      <trkpt lat="32.667745" lon="35.52958">
        <ele>165</ele>
      </trkpt>
      <trkpt lat="32.667836" lon="35.529642">
        <ele>165</ele>
      </trkpt>
      <trkpt lat="32.668244" lon="35.530026">
        <ele>167</ele>
      </trkpt>
      <trkpt lat="32.668433" lon="35.530294">
        <ele>168</ele>
      </trkpt>
      <trkpt lat="32.668586" lon="35.530451">
        <ele>171</ele>
      </trkpt>
      <trkpt lat="32.668934" lon="35.530619">
        <ele>173</ele>
      </trkpt>
      <trkpt lat="32.669336" lon="35.530719">
        <ele>180</ele>
      </trkpt>
      <trkpt lat="32.66943" lon="35.5307">
        <ele>183</ele>
      </trkpt>
      <trkpt lat="32.669587" lon="35.530812">
        <ele>184</ele>
      </trkpt>
      <trkpt lat="32.669817" lon="35.530835">
        <ele>186</ele>
      </trkpt>
      <trkpt lat="32.669978" lon="35.530823">
        <ele>187</ele>
      </trkpt>
      <trkpt lat="32.670098" lon="35.530726">
        <ele>188</ele>
      </trkpt>
      <trkpt lat="32.670201" lon="35.530476">
        <ele>192</ele>
      </trkpt>
      <trkpt lat="32.67053" lon="35.530172">
        <ele>189</ele>
      </trkpt>
      <trkpt lat="32.670708" lon="35.529824">
        <ele>197</ele>
      </trkpt>
      <trkpt lat="32.671189" lon="35.529469">
        <ele>202</ele>
      </trkpt>
      <trkpt lat="32.671535" lon="35.52943">
        <ele>195</ele>
      </trkpt>
      <trkpt lat="32.671726" lon="35.529387">
        <ele>197</ele>
      </trkpt>
      <trkpt lat="32.671864" lon="35.529161">
        <ele>205</ele>
      </trkpt>
      <trkpt lat="32.671901" lon="35.528562">
        <ele>221</ele>
      </trkpt>
      <trkpt lat="32.672301" lon="35.528128">
        <ele>227</ele>
      </trkpt>
      <trkpt lat="32.67246" lon="35.527895">
        <ele>229</ele>
      </trkpt>
      <trkpt lat="32.672502" lon="35.527922">
        <ele>229</ele>
      </trkpt>
      <trkpt lat="32.672567" lon="35.527921">
        <ele>228</ele>
      </trkpt>
      <trkpt lat="32.672725" lon="35.527852">
        <ele>226</ele>
      </trkpt>
      <trkpt lat="32.672964" lon="35.527867">
        <ele>226</ele>
      </trkpt>
      <trkpt lat="32.673452" lon="35.528077">
        <ele>225</ele>
      </trkpt>
      <trkpt lat="32.673608" lon="35.528186">
        <ele>222</ele>
      </trkpt>
      <trkpt lat="32.673692" lon="35.528189">
        <ele>220</ele>
      </trkpt>
      <trkpt lat="32.673856" lon="35.528148">
        <ele>220</ele>
      </trkpt>
      <trkpt lat="32.674167" lon="35.528015">
        <ele>218</ele>
      </trkpt>
      <trkpt lat="32.674636" lon="35.527922">
        <ele>213</ele>
      </trkpt>
      <extensions>
        <RoutingType xmlns="">Hike</RoutingType>
      </extensions>
    </trkseg>
    <trkseg>
      <trkpt lat="32.674636" lon="35.527922">
        <ele>213</ele>
      </trkpt>
      <trkpt lat="32.674907" lon="35.527963">
        <ele>207</ele>
      </trkpt>
      <trkpt lat="32.675039" lon="35.527959">
        <ele>205</ele>
      </trkpt>
      <trkpt lat="32.675282" lon="35.527902">
        <ele>202</ele>
      </trkpt>
      <trkpt lat="32.675601" lon="35.52787">
        <ele>199</ele>
      </trkpt>
      <trkpt lat="32.675733" lon="35.527886">
        <ele>197</ele>
      </trkpt>
      <trkpt lat="32.675879" lon="35.527928">
        <ele>193</ele>
      </trkpt>
      <trkpt lat="32.67606" lon="35.52801">
        <ele>188</ele>
      </trkpt>
      <trkpt lat="32.676283" lon="35.528026">
        <ele>186</ele>
      </trkpt>
      <trkpt lat="32.676488" lon="35.528122">
        <ele>182</ele>
      </trkpt>
      <trkpt lat="32.676786" lon="35.528352">
        <ele>171</ele>
      </trkpt>
      <trkpt lat="32.677215" lon="35.528771">
        <ele>162</ele>
      </trkpt>
      <trkpt lat="32.677467" lon="35.528936">
        <ele>153</ele>
      </trkpt>
      <trkpt lat="32.677561" lon="35.529031">
        <ele>150</ele>
      </trkpt>
      <trkpt lat="32.67763" lon="35.529135">
        <ele>147</ele>
      </trkpt>
      <trkpt lat="32.677769" lon="35.529238">
        <ele>143</ele>
      </trkpt>
      <trkpt lat="32.678105" lon="35.529579">
        <ele>132</ele>
      </trkpt>
      <trkpt lat="32.678276" lon="35.529889">
        <ele>125</ele>
      </trkpt>
      <trkpt lat="32.678362" lon="35.529973">
        <ele>122</ele>
      </trkpt>
      <trkpt lat="32.678451" lon="35.53012">
        <ele>119</ele>
      </trkpt>
      <trkpt lat="32.678689" lon="35.530301">
        <ele>113</ele>
      </trkpt>
      <trkpt lat="32.678873" lon="35.530483">
        <ele>108</ele>
      </trkpt>
      <trkpt lat="32.67895" lon="35.530527">
        <ele>106</ele>
      </trkpt>
      <trkpt lat="32.679143" lon="35.530507">
        <ele>102</ele>
      </trkpt>
      <trkpt lat="32.679251" lon="35.53053">
        <ele>97</ele>
      </trkpt>
      <trkpt lat="32.679491" lon="35.53069">
        <ele>94</ele>
      </trkpt>
      <trkpt lat="32.679626" lon="35.530717">
        <ele>89</ele>
      </trkpt>
      <trkpt lat="32.679754" lon="35.530686">
        <ele>86</ele>
      </trkpt>
      <trkpt lat="32.679859" lon="35.530695">
        <ele>83</ele>
      </trkpt>
      <trkpt lat="32.679948" lon="35.530738">
        <ele>80</ele>
      </trkpt>
      <trkpt lat="32.680049" lon="35.530816">
        <ele>77</ele>
      </trkpt>
      <trkpt lat="32.680217" lon="35.530867">
        <ele>71</ele>
      </trkpt>
      <trkpt lat="32.680467" lon="35.531095">
        <ele>60</ele>
      </trkpt>
      <trkpt lat="32.680599" lon="35.531155">
        <ele>54</ele>
      </trkpt>
      <trkpt lat="32.680625" lon="35.531343">
        <ele>54</ele>
      </trkpt>
      <extensions>
        <RoutingType xmlns="">Hike</RoutingType>
      </extensions>
    </trkseg>
    <trkseg>
      <trkpt lat="32.680625" lon="35.531343">
        <ele>54</ele>
      </trkpt>
      <trkpt lat="32.680654" lon="35.531549">
        <ele>54</ele>
      </trkpt>
      <trkpt lat="32.680672" lon="35.531697">
        <ele>54</ele>
      </trkpt>
      <trkpt lat="32.680643" lon="35.531826">
        <ele>53</ele>
      </trkpt>
      <trkpt lat="32.680372" lon="35.532314">
        <ele>57</ele>
      </trkpt>
      <trkpt lat="32.680137" lon="35.532876">
        <ele>60</ele>
      </trkpt>
      <trkpt lat="32.679921" lon="35.533294">
        <ele>59</ele>
      </trkpt>
      <trkpt lat="32.679871" lon="35.53343">
        <ele>58</ele>
      </trkpt>
      <trkpt lat="32.679848" lon="35.533597">
        <ele>57</ele>
      </trkpt>
      <trkpt lat="32.679858" lon="35.533681">
        <ele>56</ele>
      </trkpt>
      <trkpt lat="32.679933" lon="35.533954">
        <ele>53</ele>
      </trkpt>
      <trkpt lat="32.679943" lon="35.534059">
        <ele>52</ele>
      </trkpt>
      <trkpt lat="32.679933" lon="35.534142">
        <ele>51</ele>
      </trkpt>
      <trkpt lat="32.679861" lon="35.5343">
        <ele>50</ele>
      </trkpt>
      <trkpt lat="32.679493" lon="35.534738">
        <ele>41</ele>
      </trkpt>
      <trkpt lat="32.679456" lon="35.534838">
        <ele>39</ele>
      </trkpt>
      <extensions>
        <RoutingType xmlns="">Hike</RoutingType>
      </extensions>
    </trkseg>
    <trkseg>
      <trkpt lat="32.679456" lon="35.534838">
        <ele>39</ele>
      </trkpt>
      <trkpt lat="32.679433" lon="35.5349">
        <ele>37</ele>
      </trkpt>
      <trkpt lat="32.67943" lon="35.534984">
        <ele>37</ele>
      </trkpt>
      <trkpt lat="32.679351" lon="35.535055">
        <ele>35</ele>
      </trkpt>
      <trkpt lat="32.679068" lon="35.534815">
        <ele>36</ele>
      </trkpt>
      <trkpt lat="32.67888" lon="35.534337">
        <ele>37</ele>
      </trkpt>
      <trkpt lat="32.678659" lon="35.533919">
        <ele>34</ele>
      </trkpt>
      <trkpt lat="32.678604" lon="35.533769">
        <ele>34</ele>
      </trkpt>
      <trkpt lat="32.678552" lon="35.533456">
        <ele>37</ele>
      </trkpt>
      <trkpt lat="32.678501" lon="35.533269">
        <ele>35</ele>
      </trkpt>
      <trkpt lat="32.678404" lon="35.533156">
        <ele>33</ele>
      </trkpt>
      <trkpt lat="32.6783" lon="35.533109">
        <ele>32</ele>
      </trkpt>
      <trkpt lat="32.678072" lon="35.533109">
        <ele>30</ele>
      </trkpt>
      <trkpt lat="32.677955" lon="35.533162">
        <ele>31</ele>
      </trkpt>
      <trkpt lat="32.67776" lon="35.533352">
        <ele>28</ele>
      </trkpt>
      <trkpt lat="32.6777" lon="35.533393">
        <ele>27</ele>
      </trkpt>
      <trkpt lat="32.677625" lon="35.533418">
        <ele>27</ele>
      </trkpt>
      <trkpt lat="32.677537" lon="35.533417">
        <ele>27</ele>
      </trkpt>
      <trkpt lat="32.677421" lon="35.533369">
        <ele>27</ele>
      </trkpt>
      <trkpt lat="32.677225" lon="35.533222">
        <ele>24</ele>
      </trkpt>
      <trkpt lat="32.677129" lon="35.533184">
        <ele>24</ele>
      </trkpt>
      <trkpt lat="32.677053" lon="35.533197">
        <ele>22</ele>
      </trkpt>
      <trkpt lat="32.676678" lon="35.533458">
        <ele>23</ele>
      </trkpt>
      <trkpt lat="32.676463" lon="35.533509">
        <ele>23</ele>
      </trkpt>
      <trkpt lat="32.676386" lon="35.533491">
        <ele>23</ele>
      </trkpt>
      <trkpt lat="32.676322" lon="35.533454">
        <ele>24</ele>
      </trkpt>
      <trkpt lat="32.676147" lon="35.533301">
        <ele>24</ele>
      </trkpt>
      <trkpt lat="32.675928" lon="35.533059">
        <ele>24</ele>
      </trkpt>
      <trkpt lat="32.675837" lon="35.533005">
        <ele>24</ele>
      </trkpt>
      <trkpt lat="32.675752" lon="35.533014">
        <ele>24</ele>
      </trkpt>
      <trkpt lat="32.675482" lon="35.533227">
        <ele>24</ele>
      </trkpt>
      <trkpt lat="32.675408" lon="35.533239">
        <ele>25</ele>
      </trkpt>
      <trkpt lat="32.675368" lon="35.533226">
        <ele>25</ele>
      </trkpt>
      <trkpt lat="32.675245" lon="35.533125">
        <ele>27</ele>
      </trkpt>
      <extensions>
        <RoutingType xmlns="">Hike</RoutingType>
      </extensions>
    </trkseg>
    <trkseg>
      <trkpt lat="32.675245" lon="35.533125">
        <ele>27</ele>
      </trkpt>
      <trkpt lat="32.675194" lon="35.533083">
        <ele>29</ele>
      </trkpt>
      <trkpt lat="32.675096" lon="35.533067">
        <ele>30</ele>
      </trkpt>
      <trkpt lat="32.675026" lon="35.533121">
        <ele>29</ele>
      </trkpt>
      <trkpt lat="32.674942" lon="35.533271">
        <ele>30</ele>
      </trkpt>
      <trkpt lat="32.674809" lon="35.533592">
        <ele>30</ele>
      </trkpt>
      <trkpt lat="32.674775" lon="35.533756">
        <ele>28</ele>
      </trkpt>
      <trkpt lat="32.674681" lon="35.534058">
        <ele>25</ele>
      </trkpt>
      <trkpt lat="32.674662" lon="35.534192">
        <ele>23</ele>
      </trkpt>
      <trkpt lat="32.674664" lon="35.534287">
        <ele>23</ele>
      </trkpt>
      <trkpt lat="32.674691" lon="35.534429">
        <ele>23</ele>
      </trkpt>
      <trkpt lat="32.67479" lon="35.534731">
        <ele>21</ele>
      </trkpt>
      <trkpt lat="32.674826" lon="35.534905">
        <ele>20</ele>
      </trkpt>
      <trkpt lat="32.674829" lon="35.535008">
        <ele>19</ele>
      </trkpt>
      <trkpt lat="32.674801" lon="35.535117">
        <ele>17</ele>
      </trkpt>
      <trkpt lat="32.67476" lon="35.535185">
        <ele>15</ele>
      </trkpt>
      <trkpt lat="32.674698" lon="35.535244">
        <ele>16</ele>
      </trkpt>
      <trkpt lat="32.67459" lon="35.535277">
        <ele>13</ele>
      </trkpt>
      <trkpt lat="32.674457" lon="35.535258">
        <ele>9</ele>
      </trkpt>
      <trkpt lat="32.674281" lon="35.535195">
        <ele>7</ele>
      </trkpt>
      <trkpt lat="32.674104" lon="35.535196">
        <ele>5</ele>
      </trkpt>
      <trkpt lat="32.673775" lon="35.535283">
        <ele>4</ele>
      </trkpt>
      <trkpt lat="32.673693" lon="35.535322">
        <ele>5</ele>
      </trkpt>
      <trkpt lat="32.673622" lon="35.535383">
        <ele>4</ele>
      </trkpt>
      <trkpt lat="32.673487" lon="35.535575">
        <ele>5</ele>
      </trkpt>
      <trkpt lat="32.673198" lon="35.535877">
        <ele>3</ele>
      </trkpt>
      <trkpt lat="32.673099" lon="35.536061">
        <ele>4</ele>
      </trkpt>
      <trkpt lat="32.673028" lon="35.536152">
        <ele>4</ele>
      </trkpt>
      <trkpt lat="32.672805" lon="35.536287">
        <ele>4</ele>
      </trkpt>
      <trkpt lat="32.672775" lon="35.536335">
        <ele>3</ele>
      </trkpt>
      <trkpt lat="32.672757" lon="35.536426">
        <ele>6</ele>
      </trkpt>
      <trkpt lat="32.672783" lon="35.53679">
        <ele>8</ele>
      </trkpt>
      <trkpt lat="32.672905" lon="35.536925">
        <ele>7</ele>
      </trkpt>
      <trkpt lat="32.673118" lon="35.53712">
        <ele>5</ele>
      </trkpt>
      <trkpt lat="32.673723" lon="35.53779">
        <ele>-3</ele>
      </trkpt>
      <trkpt lat="32.673831" lon="35.537942">
        <ele>-4</ele>
      </trkpt>
      <trkpt lat="32.673984" lon="35.538225">
        <ele>-6</ele>
      </trkpt>
      <trkpt lat="32.674024" lon="35.538266">
        <ele>-6</ele>
      </trkpt>
      <trkpt lat="32.674089" lon="35.538292">
        <ele>-8</ele>
      </trkpt>
      <trkpt lat="32.674179" lon="35.538271">
        <ele>-9</ele>
      </trkpt>
      <trkpt lat="32.674223" lon="35.538217">
        <ele>-11</ele>
      </trkpt>
      <trkpt lat="32.674242" lon="35.538129">
        <ele>-11</ele>
      </trkpt>
      <trkpt lat="32.674223" lon="35.537977">
        <ele>-12</ele>
      </trkpt>
      <trkpt lat="32.674189" lon="35.537868">
        <ele>-10</ele>
      </trkpt>
      <trkpt lat="32.674059" lon="35.537544">
        <ele>-13</ele>
      </trkpt>
      <trkpt lat="32.673965" lon="35.537355">
        <ele>-14</ele>
      </trkpt>
      <trkpt lat="32.673878" lon="35.537119">
        <ele>-16</ele>
      </trkpt>
      <trkpt lat="32.673868" lon="35.537056">
        <ele>-16</ele>
      </trkpt>
      <trkpt lat="32.673883" lon="35.536981">
        <ele>-17</ele>
      </trkpt>
      <trkpt lat="32.673915" lon="35.536932">
        <ele>-19</ele>
      </trkpt>
      <trkpt lat="32.674007" lon="35.536855">
        <ele>-21</ele>
      </trkpt>
      <trkpt lat="32.674222" lon="35.537108">
        <ele>-24</ele>
      </trkpt>
      <trkpt lat="32.674323" lon="35.537286">
        <ele>-25</ele>
      </trkpt>
      <trkpt lat="32.674543" lon="35.537594">
        <ele>-26</ele>
      </trkpt>
      <trkpt lat="32.674637" lon="35.537757">
        <ele>-28</ele>
      </trkpt>
      <trkpt lat="32.675045" lon="35.538651">
        <ele>-38</ele>
      </trkpt>
      <trkpt lat="32.675131" lon="35.538893">
        <ele>-39</ele>
      </trkpt>
      <trkpt lat="32.675183" lon="35.539114">
        <ele>-39</ele>
      </trkpt>
      <trkpt lat="32.675229" lon="35.539408">
        <ele>-42</ele>
      </trkpt>
      <trkpt lat="32.675187" lon="35.540616">
        <ele>-47</ele>
      </trkpt>
      <trkpt lat="32.67511" lon="35.54132">
        <ele>-52</ele>
      </trkpt>
      <trkpt lat="32.674965" lon="35.542127">
        <ele>-59</ele>
      </trkpt>
      <trkpt lat="32.674859" lon="35.542534">
        <ele>-62</ele>
      </trkpt>
      <trkpt lat="32.674778" lon="35.542717">
        <ele>-63</ele>
      </trkpt>
      <trkpt lat="32.67461" lon="35.54287">
        <ele>-64</ele>
      </trkpt>
      <trkpt lat="32.674121" lon="35.542572">
        <ele>-69</ele>
      </trkpt>
      <trkpt lat="32.673742" lon="35.542296">
        <ele>-71</ele>
      </trkpt>
      <trkpt lat="32.673609" lon="35.542248">
        <ele>-71</ele>
      </trkpt>
      <trkpt lat="32.673452" lon="35.542219">
        <ele>-75</ele>
      </trkpt>
      <trkpt lat="32.673329" lon="35.542231">
        <ele>-76</ele>
      </trkpt>
      <trkpt lat="32.673197" lon="35.542292">
        <ele>-78</ele>
      </trkpt>
      <trkpt lat="32.672962" lon="35.542441">
        <ele>-79</ele>
      </trkpt>
      <trkpt lat="32.672663" lon="35.542528">
        <ele>-80</ele>
      </trkpt>
      <trkpt lat="32.672574" lon="35.542592">
        <ele>-82</ele>
      </trkpt>
      <trkpt lat="32.672487" lon="35.542697">
        <ele>-84</ele>
      </trkpt>
      <trkpt lat="32.672346" lon="35.542948">
        <ele>-86</ele>
      </trkpt>
      <trkpt lat="32.672248" lon="35.543065">
        <ele>-87</ele>
      </trkpt>
      <trkpt lat="32.672141" lon="35.543096">
        <ele>-89</ele>
      </trkpt>
      <trkpt lat="32.672064" lon="35.54307">
        <ele>-88</ele>
      </trkpt>
      <trkpt lat="32.671971" lon="35.54299">
        <ele>-90</ele>
      </trkpt>
      <trkpt lat="32.671717" lon="35.542571">
        <ele>-92</ele>
      </trkpt>
      <trkpt lat="32.671648" lon="35.542489">
        <ele>-94</ele>
      </trkpt>
      <trkpt lat="32.671533" lon="35.542413">
        <ele>-94</ele>
      </trkpt>
      <trkpt lat="32.671466" lon="35.5424">
        <ele>-95</ele>
      </trkpt>
      <trkpt lat="32.671368" lon="35.54245">
        <ele>-96</ele>
      </trkpt>
      <trkpt lat="32.671316" lon="35.542538">
        <ele>-96</ele>
      </trkpt>
      <trkpt lat="32.671295" lon="35.542611">
        <ele>-96.5</ele>
      </trkpt>
      <extensions>
        <RoutingType xmlns="">Hike</RoutingType>
      </extensions>
    </trkseg>
    <trkseg>
      <trkpt lat="32.671295" lon="35.542611">
        <ele>-96.5</ele>
      </trkpt>
      <trkpt lat="32.671115" lon="35.543515">
        <ele>-101</ele>
      </trkpt>
      <trkpt lat="32.67109" lon="35.543604">
        <ele>-103</ele>
      </trkpt>
      <trkpt lat="32.671017" lon="35.543749">
        <ele>-104</ele>
      </trkpt>
      <trkpt lat="32.670849" lon="35.543952">
        <ele>-105</ele>
      </trkpt>
      <trkpt lat="32.670386" lon="35.544364">
        <ele>-110</ele>
      </trkpt>
      <trkpt lat="32.670171" lon="35.544597">
        <ele>-114</ele>
      </trkpt>
      <trkpt lat="32.67006" lon="35.544761">
        <ele>-115</ele>
      </trkpt>
      <trkpt lat="32.669924" lon="35.545008">
        <ele>-116</ele>
      </trkpt>
      <trkpt lat="32.669793" lon="35.545316">
        <ele>-116</ele>
      </trkpt>
      <trkpt lat="32.669734" lon="35.545421">
        <ele>-118</ele>
      </trkpt>
      <trkpt lat="32.669646" lon="35.545525">
        <ele>-118</ele>
      </trkpt>
      <trkpt lat="32.669569" lon="35.545577">
        <ele>-118</ele>
      </trkpt>
      <trkpt lat="32.669164" lon="35.545738">
        <ele>-123</ele>
      </trkpt>
      <trkpt lat="32.669026" lon="35.545828">
        <ele>-125</ele>
      </trkpt>
      <trkpt lat="32.668882" lon="35.545989">
        <ele>-126</ele>
      </trkpt>
      <trkpt lat="32.668544" lon="35.546421">
        <ele>-129</ele>
      </trkpt>
      <trkpt lat="32.668412" lon="35.546525">
        <ele>-131</ele>
      </trkpt>
      <trkpt lat="32.668255" lon="35.546556">
        <ele>-131</ele>
      </trkpt>
      <trkpt lat="32.668142" lon="35.546534">
        <ele>-132</ele>
      </trkpt>
      <trkpt lat="32.667916" lon="35.54645">
        <ele>-134</ele>
      </trkpt>
      <trkpt lat="32.667819" lon="35.546437">
        <ele>-135</ele>
      </trkpt>
      <trkpt lat="32.66765" lon="35.546453">
        <ele>-135</ele>
      </trkpt>
      <trkpt lat="32.667185" lon="35.546621">
        <ele>-140</ele>
      </trkpt>
      <trkpt lat="32.667045" lon="35.546642">
        <ele>-140</ele>
      </trkpt>
      <trkpt lat="32.666754" lon="35.546616">
        <ele>-144</ele>
      </trkpt>
      <trkpt lat="32.666613" lon="35.546633">
        <ele>-145</ele>
      </trkpt>
      <trkpt lat="32.666473" lon="35.546702">
        <ele>-146</ele>
      </trkpt>
      <trkpt lat="32.666393" lon="35.546767">
        <ele>-147</ele>
      </trkpt>
      <trkpt lat="32.666175" lon="35.547108">
        <ele>-147</ele>
      </trkpt>
      <trkpt lat="32.66598" lon="35.547354">
        <ele>-148</ele>
      </trkpt>
      <trkpt lat="32.665897" lon="35.547433">
        <ele>-148</ele>
      </trkpt>
      <trkpt lat="32.665546" lon="35.54766">
        <ele>-148</ele>
      </trkpt>
      <trkpt lat="32.665279" lon="35.54787">
        <ele>-148</ele>
      </trkpt>
      <trkpt lat="32.664778" lon="35.548335">
        <ele>-152</ele>
      </trkpt>
      <trkpt lat="32.66468" lon="35.548455">
        <ele>-153</ele>
      </trkpt>
      <trkpt lat="32.664353" lon="35.549004">
        <ele>-159</ele>
      </trkpt>
      <trkpt lat="32.664206" lon="35.549351">
        <ele>-161</ele>
      </trkpt>
      <trkpt lat="32.664071" lon="35.549744">
        <ele>-164.5</ele>
      </trkpt>
      <extensions>
        <RoutingType xmlns="">Hike</RoutingType>
      </extensions>
    </trkseg>
  </trk>
</gpx>

<!-- Hike info from https://www.yeledteva.com/ -->



================================================
FILE: kittehub/data_pipeline/Makefile
================================================
# Automation of some common operations for local development

all:
	$(error please pick a target)

init-db:
	sqlite3 hikes.db < schema.sql

deploy:
	ak deploy --manifest ./autokitteh.yaml --file pipeline.py

logs:
	ak session log --prints-only



================================================
FILE: kittehub/data_pipeline/pipeline.py
================================================
"""Parse GPX files when uploaded to an S3 bucket, and insert into a SQLite database."""

from contextlib import closing
from io import BytesIO
import json
import os
from pathlib import Path
import sqlite3
import xml.etree.ElementTree as Xml

import autokitteh
from autokitteh.aws import boto3_client


DB_DSN = os.getenv("DB_DSN", "")  # Secret
CREATE_DB = os.getenv("CREATE_DB", "no").lower() in {"y", "yes", "true"}

INSERT_SQL = """
INSERT INTO points
	(track_id, n, lat, lng, height)
VALUES
	(:track_id, :n, :lat, :lng, :height)
;
"""


def on_new_s3_object(event):
    if not event.data.body.json:
        print("Unexpected (non-JSON) content type:", event)
        return

    if CREATE_DB:
        create_db(DB_DSN)

    event = event.data.body.json
    print("event:", event)
    if url := event.get("SubscribeURL"):
        print("SNS Subscribe URL:", url)
        return

    # SNS events encode the `Message` field in JSON
    s3_event = json.loads(event.get("Message", {}))
    for record in s3_event.get("Records", []):
        bucket = record["s3"]["bucket"]["name"]
        key = record["s3"]["object"]["key"]
        print(f"getting {bucket}/{key}")
        data = get_s3_object(bucket, key)
        records = parse_gpx(key, data)
        count = insert_records(DB_DSN, records)
        print(f"inserted {count} records")


@autokitteh.activity
def get_s3_object(bucket, key):
    response = boto3_client("aws_conn", "s3").get_object(Bucket=bucket, Key=key)
    return response["Body"].read()


@autokitteh.activity
def insert_records(db_dsn, records):
    with closing(sqlite3.connect(db_dsn)) as conn:
        cur = conn.executemany(INSERT_SQL, records)
        conn.commit()
    return cur.rowcount


@autokitteh.activity
def create_db(db_dsn):
    code_dir = Path(__file__).absolute().parent
    schema_file = code_dir / "schema.sql"
    schema_sql = schema_file.read_text()

    with closing(sqlite3.connect(db_dsn)) as conn, conn:
        conn.executescript(schema_sql)


trkpt_tag = "{http://www.topografix.com/GPX/1/1}trkpt"


@autokitteh.activity
def parse_gpx(track_id, data):
    io = BytesIO(data)
    root = Xml.parse(io).getroot()
    records = []

    for i, elem in enumerate(root.findall(".//" + trkpt_tag)):
        records.append(
            {
                "track_id": track_id,
                "n": i,
                "lat": float(elem.get("lat", "0")),
                "lng": float(elem.get("lon", "0")),
                "height": float(elem.findtext(".//") or "0"),
            }
        )

    return records



================================================
FILE: kittehub/data_pipeline/schema.sql
================================================
-- Schema for the points table

CREATE TABLE IF NOT EXISTS points (
	track_id VARCHAR(255) NOT NULL,
	n INTEGER NOT NULL,
	lat REAL NOT NULL,
	lng REAL NOT NULL,
	height REAL NOT NULL
);

CREATE INDEX IF NOT EXISTS points_track_id_idx ON points(track_id);




================================================
FILE: kittehub/data_pipeline/subscription-event.json
================================================
{
  "Type": "SubscriptionConfirmation",
  "MessageId": "XXXXXXXX-1ee3-4de3-9c69-XXXXXXXXXXXX",
  "Token": "SECRET_TOKEN",
  "TopicArn": "arn:aws:sns:us-west-2:XXXXXXXXXXXX:ses-test",
  "Message": "You have chosen to subscribe to the topic arn:aws:sns:us-west-2:XXXXXXXXXXXX:ses-test. To confirm the subscription, visit the SubscribeURL included in this message.",
  "SubscribeURL": "https://sns.us-west-2.amazonaws.com/?Action=ConfirmSubscription&TopicArn=arn:aws:sns:us-west-2:XXXXXXXXXXXX:ses-test&Token=SECRET_TOKEN",
  "Timestamp": "2018-11-21T19:48:08.170Z",
  "SignatureVersion": "1",
  "Signature": "SECRET",
  "SigningCertURL": "https://sns.us-west-2.amazonaws.com/SimpleNotificationService-XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.pem"
}



================================================
FILE: kittehub/devops/github_issue_alert/README.md
================================================
title: GitHub issue alert
description: Send GitHub issue comments to Slack
integrations: ["github", "slack"]
categories: ["DevOps"]



================================================
FILE: kittehub/devops/github_issue_alert/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup
# of an AutoKitteh project that monitors comments on GitHub issues.

version: v1

project:
  name: github_issue_alert

  vars:
    - name: SLACK_CHANNEL_NAME_OR_ID
      value: github-issues

  connections:
    - name: slack_conn
      integration: slack
    - name: github_conn
      integration: github

  triggers:
    - name: on_issue_comment
      event_type: issue_comment
      connection: github_conn
      call: program.py:on_issue_comment
    - name: on_issue_event
      event_type: issues
      connection: github_conn
      call: program.py:on_issue_event



================================================
FILE: kittehub/devops/github_issue_alert/program.py
================================================
"""Monitors GitHub issue creation and comment activity."""

import os

from autokitteh.slack import slack_client


SLACK_CHANNEL = os.getenv("SLACK_CHANNEL_NAME_OR_ID", "")

slack = slack_client("slack_conn")


def on_issue_comment(event):
    """Processes a GitHub issue comment event and sends a message to Slack.

    Supported actions: created, edited, deleted

    For more details on the payload structure, visit:
    https://docs.github.com/en/webhooks/webhook-events-and-payloads#issue_comment
    """
    comment_url = event.data.comment.html_url
    comment_body = event.data.comment.body
    comment_action = event.data.action
    comment_author = event.data.comment.user.login or "Unknown user"
    issue_title = event.data.issue.title

    text = (
        f"{comment_author} {comment_action} a comment on issue '{issue_title}': "
        f"{comment_body}\n. "
    )
    text += f"View the comment here: {comment_url}."

    slack.chat_postMessage(channel=SLACK_CHANNEL, text=text)


def on_issue_event(event):
    """Processes a GitHub issue event and sends a message to Slack.

    Supported actions: opened, reopened, closed

    For more details on the payload structure, visit:
    https://docs.github.com/en/webhooks/webhook-events-and-payloads#issues
    """
    issue_title = event.data.issue.title
    issue_author = event.data.issue.user.login
    issue_action = event.data.action
    issue_url = event.data.issue.html_url

    text = f"{issue_author} {issue_action} an issue: '{issue_title}', "
    text += f"View the issue here: {issue_url}."

    slack.chat_postMessage(channel=SLACK_CHANNEL, text=text)



================================================
FILE: kittehub/devops/github_workflows/README.md
================================================
title: GitHub workflow orchestration
description: Orchestrate GitHub workflows using advanced scenarios across multiple repositories
integrations: ["github"]
categories: ["DevOps"]



================================================
FILE: kittehub/devops/github_workflows/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup
# of an AutoKitteh project that orchestrates GitHub workflows using
# advanced scenarios across multiple repositories.

version: v1

project:
  name: github_actions

  vars:
    - name: REPO_A
      value: owner/repo-1
    - name: REPO_B
      value: owner/repo-2
    - name: REPO_C
      value: owner/repo-3

    - name: WORKFLOW_A
      value: .github/workflows/workflow-1.yml
    - name: WORKFLOW_B
      value: .github/workflows/workflow-2.yml
    - name: WORKFLOW_C
      value: .github/workflows/workflow-3.yml

  connections:
    - name: github_conn
      integration: github

  triggers:
    - name: cross_repo
      type: webhook
      event_type: get
      call: program.py:cross_repo

    - name: fan_out
      type: webhook
      event_type: get
      call: program.py:fan_out

    - name: or_reduction
      type: webhook
      event_type: get
      call: program.py:or_reduction

    - name: fan_in
      type: webhook
      event_type: get
      call: program.py:fan_in

    - name: long_sequence
      type: webhook
      event_type: get
      call: program.py:long_sequence



================================================
FILE: kittehub/devops/github_workflows/program.py
================================================
"""Orchestrate GitHub workflows using advanced scenarios across repositories.

See the configuration and deployment instructions in the README.md file.
"""

import os

import autokitteh
from autokitteh.github import github_client
import github


# Indexes in the following lists, used throughout this module.
A = 0
B = 1
C = 2

# GitHub repositories (e.g. "autokitteh/kittehub").
REPOS = [
    os.getenv("REPO_A", ""),
    os.getenv("REPO_B", ""),
    os.getenv("REPO_C", ""),
]

# GitHub workflow file paths (e.g. ".github/workflows/ci.yml").
WORKFLOWS = [
    os.getenv("WORKFLOW_A", ""),
    os.getenv("WORKFLOW_B", ""),
    os.getenv("WORKFLOW_C", ""),
]

gh = github_client("github_conn")


def dispatch_workflow_manually(event: dict[str, str]) -> None:
    """Dispatch a workflow manually, for testing purposes.

    You may specify an optional index (default = 0 = workflow A).
    """
    _dispatch_workflow(int(event.get("index", A)))


def cross_repo(_) -> None:
    """Cross-repo demo (A --> B)."""
    sub = _subscribe_to_events(A)
    print("Waiting until workflow A completes")
    autokitteh.next_event(sub)
    print("Workflow A completed")
    _dispatch_workflow(B)


def fan_out(_) -> None:
    """Fan-out demo (A --> B and C in parallel)."""
    sub = _subscribe_to_events(A)
    print("Waiting until workflow A completes")
    autokitteh.next_event(sub)
    print("Workflow A completed")
    _dispatch_workflow(B)
    _dispatch_workflow(C)


def or_reduction(_) -> None:
    """Any-to-one reduction demo (first of A or B --> C)."""
    subs = [_subscribe_to_events(A), _subscribe_to_events(B)]
    print("Waiting until either workflow A or B complete (whichever comes first)")
    data = autokitteh.next_event(subs)
    print(f"Workflow completed: {data.repository.name}/{data.workflow.path}")
    _dispatch_workflow(C)


def fan_in(_) -> None:
    """All-to-one fan-in demo (A and B --> C)."""
    subs = [_subscribe_to_events(A), _subscribe_to_events(B)]

    # Wait until both workflows A and B complete.
    completed_workflows = set()
    while len(completed_workflows) < 2:
        data = autokitteh.next_event(subs)
        path = f"{data.repository.name}/{data.workflow.path}"
        print(f"Workflow completed: {path}")
        completed_workflows.add(path)

    _dispatch_workflow(C)


def long_sequence(_) -> None:
    """Long sequence demo (A --> B --> C --> A --> B --> C).

    Note: GitHub cannot chain more than 4 workflows (when using `workflow_run` events),
    so this AutoKitteh demo is useful even within a single repository. See details here:
    https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows#workflow_run
    """
    sub = _subscribe_to_events(A)
    print("Waiting until workflow A completes")
    autokitteh.next_event(sub)
    autokitteh.unsubscribe(sub)
    print("Workflow A completed")

    for wf in [B, C, A, B, C]:
        sub = _subscribe_to_events(wf)
        _dispatch_workflow(wf)
        print(f"Waiting until workflow {_index2char(wf)(wf)} completes")
        autokitteh.next_event(sub)
        autokitteh.unsubscribe(sub)
        print(f"Workflow {_index2char(wf)(wf)} completed")


def _subscribe_to_events(wf: int, conclusion: str = "success") -> str:
    """Intercept specific GitHub "workflow_run" events.

    API documentation:
    - https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows#workflow_run
    - https://docs.github.com/en/webhooks/webhook-events-and-payloads#workflow_run

    Args:
        wf: Workflow index (0-2).
        conclusion: Workflow completion result: "action_required",
            "cancelled", "failure", "neutral", "skipped", "stale",
            "success", "timed_out", "startup_failure", or None.

    Returns:
        AutoKitteh event subscription UUID.
    """
    conditions = [
        "event_type == 'workflow_run'",
        "data.action == 'completed'",
        f"data.workflow_run.conclusion == '{conclusion}'",
        f"data.repository.full_name == '{REPOS[wf]}'",
        f"data.workflow.path == '{WORKFLOWS[wf]}'",
    ]
    return autokitteh.subscribe("github_conn", " && ".join(conditions))


def _dispatch_workflow(wf: int, ref: str = "main", inputs: dict = None) -> None:
    """Start a specific GitHub workflow.

    API documentation:
    - https://docs.github.com/en/rest/actions/workflows#create-a-workflow-dispatch-event
    - https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows#workflow_dispatch

    Args:
        wf: Workflow index (0-2).
        ref: Git reference, should be the default branch (e.g. "main").
        inputs: Keys and values configured in the workflow file. The maximum
            number of properties is 10. Any default properties configured in
            the workflow file will be used when inputs are omitted.
    """
    repo = gh.get_repo(REPOS[wf])
    workflow = _get_workflow(repo, WORKFLOWS[wf])
    if workflow.create_dispatch(ref, inputs or {}):
        print(f"Workflow {_index2char(wf)(wf)} dispatched")
    else:
        print("Failed to create a 'workflow_dispatch' event")


def _get_workflow(repo: github.Repository, path: str) -> github.Workflow:
    """Return the GitHub workflow instance with the given file path."""
    for workflow in repo.get_workflows():
        if workflow.path == path:
            return workflow

    raise RuntimeError(f"Workflow file not found: {path}")


def _index2char(index: int) -> str:
    """Convert an index (0-2) to a workflow identifier (A-C)."""
    return chr(65 + index)



================================================
FILE: kittehub/devops/purrr/README.md
================================================
title: Pull Request Review Reminder (Purrr)
description: Streamline code reviews and cut down turnaround time to merge pull requests
integrations: ["github", "sheets", "slack"]
categories: ["DevOps"]



================================================
FILE: kittehub/devops/purrr/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup
# of the AutoKitteh project "Pull Request Review Reminder" (Purrr).
# Purrr integrates GitHub and Slack seamlessly, to streamline code
# reviews and cut down the turnaround time to merge pull requests.

version: v1

project:
  name: purrr

  vars:
    # Temporary (easy to debug, but not scalable) replacement for Redis/Valkey.
    - name: DATA_SHEET_URL
      value: TODO
    # PR channel names in Slack: "<prefix>_<number>_<title>".
    - name: SLACK_CHANNEL_PREFIX
      value: _pr
    # Visibility of PR channels in Slack: "public" (default) or "private".
    - name: SLACK_CHANNEL_VISIBILITY
      value: public
    # Create this channel / replace with your own / set to "" to disable it.
    - name: SLACK_DEBUG_CHANNEL
      value: purrr-debug
    # TTL for GitHub/Slack mappings = 30 days (to forget stale PRs).
    - name: STATE_TTL
      value: 720h

  connections:
    - name: github_conn
      integration: github
    - name: sheets_conn
      integration: googlesheets
    - name: slack_conn
      integration: slack

  triggers:
    # - name: github_issue_comment
    #   connection: github_conn
    #   event_type: issue_comment
    #   call: github_issue_comment.py:on_github_issue_comment
    - name: github_pull_request
      connection: github_conn
      event_type: pull_request
      call: github_pr.py:on_github_pull_request
    # - name: github_pull_request_review
    #   connection: github_conn
    #   event_type: pull_request_review
    #   call: github_pr_review.py:on_github_pull_request_review
    # - name: github_pull_request_review_comment
    #   connection: github_conn
    #   event_type: pull_request_review_comment
    #   call: github_review_comment.py:on_github_pull_request_review_comment
    # - name: github_pull_request_review_thread
    #   connection: github_conn
    #   event_type: pull_request_review_thread
    #   call: github_thread.py:on_github_pull_request_review_thread

    # - name: slack_message
    #   connection: slack_conn
    #   event_type: message
    #   call: slack_message.py:on_slack_message
    # - name: slack_reaction_added
    #   connection: slack_conn
    #   event_type: reaction_added
    #   call: slack_reaction.py:on_slack_reaction_added
    - name: slack_slash_command
      connection: slack_conn
      event_type: slash_command
      call: slack_cmd.py:on_slack_slash_command



================================================
FILE: kittehub/devops/purrr/data_helper.py
================================================
"""Thin wrapper over the Google Sheets API for data management and caching.

Redis/Valkey would be a better choice, but are not available at this time.
"""

from datetime import datetime


# Some read functions wait up to 5 seconds for data to exist,
# because GitHub events are asynchronous. For example: when a
# PR review is submitted with file/line comments, some "child"
# comment events may arrive before the "parent" review event.
_GET_TIMEOUT = 5

# Cache user lookup results for a day, to reduce the amount
# of API calls (especially to Slack), to avoid throttling.
_USER_CACHE_TTL = "24h"


def cache_github_reference(slack_user_id: str, github_ref: str) -> None:
    """Map a Slack user ID to a GitHub user reference/name, for a day.

    This helps reduce the amount of lookup API calls, to avoid throttling.
    """
    return  # TODO: Implement this function.


def cached_github_reference(slack_user_id: str) -> str:
    """Return the GitHub user reference/name mapped to a Slack user ID, or "".

    This helps reduce the amount of lookup API calls, to avoid throttling.
    """
    return ""  # TODO: Implement this function.


def cache_slack_user_id(github_username: str, slack_user_id: str) -> None:
    """Map a GitHub username to a Slack user ID, for a day.

    This helps reduce the amount of Slack lookup API calls, to avoid throttling.
    """
    return  # TODO: Implement this function.


def cached_slack_user_id(github_username: str) -> str:
    """Return the Slack user ID mapped to a GitHub user, or "" if not cached yet.

    This helps reduce the amount of Slack lookup API calls, to avoid throttling.
    """
    return ""  # TODO: Implement this function.


def lookup_github_link_details(github_link: str) -> str | None:
    """Return the Slack message thread timestamp mapped to a GitHub PR link, or None.

    This function waits up to a few seconds for the mapping to exist, because
    GitHub events are asynchronous. For example: when a PR review is submitted
    with file/line comments, some "child" comment events may arrive before the
    "parent" review event.
    """
    if not github_link:
        return None

    return None  # TODO: Implement this function (with "wait=True").


def slack_opt_in(user_id: str) -> None:
    """Delete the opt-out timestamp for a Slack user."""
    return  # TODO: Implement this function.


def slack_opt_out(user_id: str) -> None:
    """Return the opt-out timestamp for a Slack user, or None if they're opted-in."""
    return  # TODO: Implement this function.


def slack_opted_out(user_id: str) -> datetime | None:
    """Return the opt-out timestamp for a Slack user, or None if they're opted-in."""
    return None  # TODO: Implement this function.



================================================
FILE: kittehub/devops/purrr/debug.py
================================================
"""Simple utility functions for debugging and reporting errors in Slack.

Decoupled from the "slack_helper" module, to avoid circular imports.
"""

import os
import re
import traceback

from autokitteh.slack import slack_client
from slack_sdk.errors import SlackApiError


_DEBUG_CHANNEL = os.getenv("SLACK_DEBUG_CHANNEL")

slack = slack_client("slack_conn")


def log(msg: str) -> None:
    """Post a debug message to a predefined Slack channel, if defined.

    Also post a filtered traceback, as replies to that message.
    """
    if not _DEBUG_CHANNEL or not msg:
        return

    print("DEBUG:", msg)
    try:
        resp = slack.chat_postMessage(channel=_DEBUG_CHANNEL, text=msg)
        ts = resp["ts"]

        for msg in _stack_messages():
            slack.chat_postMessage(channel=_DEBUG_CHANNEL, thread_ts=ts, text=msg)

    except SlackApiError as e:
        print(f"DEBUG ERROR: {e}")


def _stack_messages() -> list[str]:
    msgs = []
    for file, line, func, text in traceback.extract_stack():
        # Log only frame summaries relating to this project, up to this function.
        if "/ak-user-" not in file:
            continue

        # Display shorter and cleaner paths.
        file = re.sub(r"^.+/ak-user-.+?/", "", file)
        msgs.append(f"```File: {file}, line {line}\nFunc: {func}\n{text}```")

    return msgs[:-2]  # Skip the last 2 frames (i.e. this module).



================================================
FILE: kittehub/devops/purrr/github_helper.py
================================================
"""Thin layer of logic on top of the GitHub API."""

import os

from autokitteh.github import github_client


ORG_NAME = os.getenv("github_conn__target_name", "")

shared_client = github_client("github_conn")



================================================
FILE: kittehub/devops/purrr/github_pr.py
================================================
"""Handler for GitHub "pull_request" events."""

import autokitteh
from autokitteh.slack import normalize_channel_name

import data_helper
import slack_channel
import slack_helper
import text_utils
import users


def on_github_pull_request(event) -> None:
    """Entry-point for AutoKitteh sessions triggered by GitHub "pull_request" events.

    Args:
        event: GitHub event data.
    """
    _parse_github_pr_event(event.data)


def _parse_github_pr_event(data) -> None:
    """Parse a GitHub "pull_request" event and dispatch the appropriate handler.

    About GitHub pull requests and these events:
    - https://docs.github.com/webhooks/webhook-events-and-payloads#pull_request
    - https://docs.github.com/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/about-pull-requests

    Args:
        data: GitHub event data.
    """
    match data.action:
        # A new pull request was created.
        case "opened":
            _on_pr_opened(data.action, data.pull_request, data.sender)
        # A pull request was closed.
        case "closed":
            _on_pr_closed(data.action, data.pull_request, data.sender)
        # A previously closed pull request was reopened.
        case "reopened":
            _on_pr_reopened(data.action, data.pull_request, data.sender)

        # A pull request was converted to a draft.
        case "converted_to_draft":
            _on_pr_converted_to_draft(data.action, data.pull_request, data.sender)
        # A draft pull request was marked as ready for review.
        case "ready_for_review":
            _on_pr_ready_for_review(data.action, data.pull_request, data.sender)

        # Review by a person or team was requested for a pull request.
        case "review_requested":
            _on_pr_review_requested(data)
        # A request for review by a person or team was removed from a pull request.
        case "review_request_removed":
            _on_pr_review_request_removed(data)

        # A pull request was assigned to a user.
        case "assigned":
            _on_pr_assigned(data)
        # A user was unassigned from a pull request.
        case "unassigned":
            _on_pr_unassigned(data)

        # The title or body of a pull request was edited,
        # or the base branch was changed.
        case "edited":
            _on_pr_edited(data.action, data.pull_request, data.changes, data.sender)
        # A pull request's head branch was updated.
        case "synchronize":
            _on_pr_synchronized(data.action, data.pull_request, data.sender)

        # TODO: locked, unlocked

        # Ignored actions:
        # - auto_merge_enabled, auto_merge_disabled
        # - enqueued, dequeued
        # - labeled, unlabeled
        # - milestoned, demilestoned


def _on_pr_opened(action: str, pr, sender) -> None:
    """A new pull request was created (or reopened, or marked as ready for review).

    See also the functions "_on_pr_reopened" and "_on_pr_ready_for_review".

    Args:
        action: GitHub PR event action.
        pr: GitHub PR data.
        sender: GitHub user who triggered the event.
    """
    # Ignore drafts until they're marked as ready for review.
    if pr.draft:
        return

    channel = slack_channel.initialize_for_github_pr(action, pr, sender)

    # Intercept relevant GitHub and Slack events.
    filter = f"event_type == 'pull_request' && data.number == {pr.number}"
    subs = [autokitteh.subscribe("github_conn", filter=filter)]

    filter = "(event_type == 'message' || event_type.startswith('member_'))"
    filter += f" && data.event.channel == {channel}"
    subs.append(autokitteh.subscribe("slack_conn", filter=filter))

    filter = f"event_type == 'reaction_added' && data.event.item.channel == {channel}"
    subs.append(autokitteh.subscribe("slack_conn", filter=filter))

    # Keep this AutoKitteh session running to handle them until the PR is closed.
    while True:
        data = autokitteh.next_event(subs)

        # GitHub PR event.
        if hasattr(data, "action"):
            print("Received GitHub PR event:", data.action)
            if data.action in ("closed", "converted_to_draft"):
                for sub in subs:
                    autokitteh.unsubscribe(sub)
                break

        # Slack event.
        else:
            print("Received Slack event:", data.event.type)


def _on_pr_closed(action: str, pr, sender) -> None:
    """A pull request (possibly a draft) was closed.

    If "merged" is false in the webhook payload, the pull request was
    closed with unmerged commits. If "merged" is true in the webhook
    payload, the pull request was merged.

    Args:
        action: GitHub PR event action.
        pr: GitHub PR data.
        sender: GitHub user who triggered the event.
    """
    # Ignore drafts - they don't have an active Slack channel anyway.
    if pr.draft:
        return

    slack_channel.archive(action, pr, sender)


def _on_pr_reopened(action: str, pr, sender) -> None:
    """A previously closed pull request (possibly a draft) was reopened.

    Slack bug alert from https://api.slack.com/methods/conversations.unarchive:
    bot tokens ("xoxb-...") cannot currently be used to unarchive conversations.
    For now, please use a user token ("xoxp-...") to unarchive the conversation
    rather than a bot token.

    Args:
        action: GitHub PR event action.
        pr: GitHub PR data.
        sender: GitHub user who triggered the event.
    """
    # Ignore drafts - they don't have an active Slack channel anyway.
    if pr.draft:
        return

    # Workaround for the Slack unarchive bug: treat this as a new PR.
    _on_pr_opened(action, pr, sender)


def _on_pr_converted_to_draft(action: str, pr, sender) -> None:
    """A pull request was converted to a draft.

    For more information, see "Changing the stage of a pull request":
    https://docs.github.com/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/changing-the-stage-of-a-pull-request

    Args:
        action: GitHub PR event action.
        pr: GitHub PR data.
        sender: GitHub user who triggered the event.
    """
    slack_channel.archive(action, pr, sender)


def _on_pr_ready_for_review(action: str, pr, sender) -> None:
    """A draft pull request was marked as ready for review.

    For more information, see "Changing the stage of a pull request":
    https://docs.github.com/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/changing-the-stage-of-a-pull-request

    Slack bug alert from https://api.slack.com/methods/conversations.unarchive:
    bot tokens ("xoxb-...") cannot currently be used to unarchive conversations.
    For now, please use a user token ("xoxp-...") to unarchive the conversation
    rather than a bot token.

    Args:
        action: GitHub PR event action.
        pr: GitHub PR data.
        sender: GitHub user who triggered the event.
    """
    # Workaround for the Slack unarchive bug: treat this as a new PR.
    _on_pr_opened(action, pr, sender)


def _on_pr_review_requested(data) -> None:
    """Review by a person or team was requested for a pull request.

    For more information, see "Requesting a pull request review":
    https://docs.github.com/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/requesting-a-pull-request-review

    Args:
        data: GitHub event data.
    """
    # Don't do anything if there isn't an active Slack channel anyway.
    channel = _lookup_channel(data.pull_request, data.action)
    if not channel:
        return

    if data.requested_reviewer:
        reviewer = data.requested_reviewer
        _on_pr_review_requested_person(reviewer, data.sender, channel, "reviewer")
    if data.requested_team:
        _on_pr_review_requested_team(data.requested_team, data.sender, channel)


def _on_pr_review_requested_person(reviewer, sender, channel: str, role: str) -> None:
    """Review by a person was requested for a pull request.

    Args:
        reviewer: GitHub user requested as a reviewer.
        sender: GitHub user who triggered the event.
        channel: PR's Slack channel ID.
        role: "reviewer" or "assignee".
    """
    slack_reviewer = users.format_github_user_for_slack(reviewer)
    self_added = reviewer.login == sender.login
    person = "themselves" if self_added else slack_reviewer
    article = "a" if role == "reviewer" else "an"  # "assignee"

    msg = f"{{}} added {person} as {article} {role}"
    slack_helper.mention_in_message(channel, sender, msg)

    if not slack_reviewer.startswith("<@"):
        return  # Not a real Slack user ID.

    # Remove the "<@" and ">" affixes from the Slack user mention to get the user ID.
    slack_reviewer = slack_reviewer[2:-1]

    if data_helper.slack_opted_out(slack_reviewer):
        return

    slack_channel.add_users(channel, [reviewer.login])

    if self_added:
        return

    # DM the reviewer a reference to the Slack channel.
    msg = f"{{}} added you as {article} {role} to a PR: <#{channel}>"
    slack_helper.mention_in_message(slack_reviewer, sender, msg)


def _on_pr_review_requested_team(team, sender, channel: str) -> None:
    """Review by a team was requested for a pull request.

    Args:
        team: GitHub team requested as a reviewer.
        sender: GitHub user who triggered the event.
        channel: PR's Slack channel ID.
    """
    msg = f"{{}} added the <{team.html_url}|{team.name}> team as a reviewer"
    slack_helper.mention_in_message(channel, sender, msg)


def _on_pr_review_request_removed(data) -> None:
    """A request for review by a person or team was removed from a pull request.

    Args:
        data: GitHub event data.
    """
    # Don't do anything if there isn't an active Slack channel anyway.
    channel = _lookup_channel(data.pull_request, data.action)
    if not channel:
        return

    if data.requested_reviewer:
        reviewer = data.requested_reviewer
        _on_pr_review_request_removed_person(reviewer, data.sender, channel, "reviewer")
    if data.requested_team:
        _on_pr_review_request_removed_team(data.requested_team, data.sender, channel)


def _on_pr_review_request_removed_person(
    reviewer, sender, channel: str, role: str
) -> None:
    """A request for review by a person was removed from a pull request.

    Args:
        reviewer: GitHub user requested as a reviewer.
        sender: GitHub user who triggered the event.
        channel: PR's Slack channel ID.
        role: "reviewer" or "assignee".
    """
    slack_reviewer = users.format_github_user_for_slack(reviewer)
    self_added = reviewer.login == sender.login
    person = "themselves" if self_added else slack_reviewer
    article = "a" if role == "reviewer" else "an"  # "assignee"

    msg = f"{{}} removed {person} as {article} {role}"
    slack_helper.mention_in_message(channel, sender, msg)

    if not slack_reviewer.startswith("<@"):
        return  # Not a real Slack user ID.

    # Remove the "<@" and ">" affixes from the Slack user mention to get the user ID.
    slack_reviewer = slack_reviewer[2:-1]

    if data_helper.slack_opted_out(slack_reviewer):
        return

    # TODO: Remove the reviewer from the Slack channel.

    # TODO: Remove the review request DM.


def _on_pr_review_request_removed_team(team, sender, channel: str) -> None:
    """A request for review by a team was removed from a pull request.

    Args:
        team: GitHub team that was requested as a reviewer.
        sender: GitHub user who triggered the event.
        channel: PR's Slack channel ID.
    """
    msg = f"removed the <{team.html_url}|{team.name}> team as a reviewer"
    slack_helper.mention_in_message(channel, sender, "{} " + msg)


def _on_pr_assigned(data) -> None:
    """A pull request was assigned to a user.

    Args:
        data: GitHub event data.
    """
    # Don't do anything if there isn't an active Slack channel anyway.
    channel = _lookup_channel(data.pull_request, data.action)
    if not channel:
        return

    _on_pr_review_requested_person(data.assignee, data.sender, channel, "assignee")


def _on_pr_unassigned(data) -> None:
    """A user was unassigned from a pull request.

    Args:
        data: GitHub event data.
    """
    # Don't do anything if there isn't an active Slack channel anyway.
    channel = _lookup_channel(data.pull_request, data.action)
    if not channel:
        return

    assignee, sender = data.assignee, data.sender
    _on_pr_review_request_removed_person(assignee, sender, channel, "assignee")


def _on_pr_edited(action: str, pr, changes, sender) -> None:
    """The title or body of a pull request was edited, or the base branch was changed.

    Args:
        action: GitHub PR event action.
        pr: GitHub PR data.
        changes: Changed title/body in the PR.
        sender: GitHub user who triggered the event.
    """
    # Don't do anything if there isn't an active Slack channel anyway.
    channel = _lookup_channel(pr, action)
    if not channel:
        return

    # PR base branch was changed.
    if "base" in changes:
        msg = "{} changed the base branch from "
        msg += "`{changes.base.ref}` to `{pr.base.ref}`"
        slack_helper.mention_in_message(channel, sender, msg)

    # PR description was changed.
    if "body" in changes:
        if pr.body:
            msg = "{} updated the PR description:\n\n"
            msg += text_utils.github_to_slack(pr.body, pr.html_url)
        else:
            msg = "{} deleted the PR description"

        slack_helper.mention_in_message(channel, sender, msg)

    # PR title was changed.
    if "title" in changes:
        msg = f"{{}} edited the PR title to: `{pr.title}`"
        slack_helper.mention_in_message(channel, sender, msg)

        name = f"{pr.number}_{normalize_channel_name(pr.title)}"
        slack_helper.rename_channel(channel, name)


def _on_pr_synchronized(action: str, pr, sender) -> None:
    """A pull request's head branch was updated.

    For example, the head branch was updated from the base
    branch or new commits were pushed to the head branch.

    Args:
        action: GitHub PR event action.
        pr: GitHub PR data.
        sender: GitHub user who triggered the event.
    """
    # Don't do anything if there isn't an active Slack channel anyway.
    channel = _lookup_channel(pr, action)
    if not channel:
        return

    msg = "{} updated the head branch (see the [PR commits]({pr.url}/commits))"
    slack_helper.mention_in_message(channel, sender, msg)


def _lookup_channel(pr, action: str) -> str | None:
    """Return the ID of a Slack channel that represents a GitHub PR.

    Return None the PR is inactive or the channel ID is not found.
    """
    if pr.draft or pr.state != "open":
        return None

    return slack_helper.lookup_channel(pr.html_url, action)



================================================
FILE: kittehub/devops/purrr/github_pr_test.py
================================================
"""Unit tests for the "github_pr" module."""

import collections

from autokitteh import github, slack
import pytest


@pytest.fixture(autouse=True)
def setup_mock_github_and_slack_clients(mocker):
    mocker.patch.object(github, "github_client", autospec=True)
    mocker.patch.object(slack, "slack_client", autospec=True)


@pytest.fixture
def mock_slack_user_id(mocker):
    import users

    return mocker.patch.object(users, "github_username_to_slack_user_id", autospec=True)


FakeGithubUser = collections.namedtuple("FakeGithubUser", ["login"])


class TestOnPRReviewRequestedPerson:
    """Unit tests for the "_on_pr_review_requested_person" function."""

    def test_reviewer(self, mock_slack_user_id):
        import github_pr
        import slack_helper

        mock_slack_user_id.side_effect = [
            "reviewer",  # _on_pr_review_requested_person: message to channel
            "sender",  # mention_in_reply: mention in message to channel
            "reviewer",  # add_users: invite reviewer to channel
            "sender",  # mention_in_reply: mention in DM to reviewer
        ]
        slack_helper.shared_client.chat_postMessage.reset_mock()

        github_pr._on_pr_review_requested_person(
            FakeGithubUser("reviewer"), FakeGithubUser("sender"), "C987", "reviewer"
        )

        slack_helper.shared_client.chat_postMessage.assert_any_call(
            channel="C987",
            text="<@sender> added <@reviewer> as a reviewer",
            thread_ts=None,
        )
        slack_helper.shared_client.chat_postMessage.assert_called_with(
            channel="reviewer",
            text="<@sender> added you as a reviewer to a PR: <#C987>",
            thread_ts=None,
        )

    def test_self_reviewer(self, mock_slack_user_id):
        import github_pr
        import slack_helper

        mock_slack_user_id.side_effect = ["U123", "U123", "U123"]
        slack_helper.shared_client.chat_postMessage.reset_mock()

        github_pr._on_pr_review_requested_person(
            FakeGithubUser("sender"), FakeGithubUser("sender"), "C987", "reviewer"
        )

        slack_helper.shared_client.chat_postMessage.assert_called_with(
            channel="C987",
            text="<@U123> added themselves as a reviewer",
            thread_ts=None,
        )

    def test_assignee(self, mock_slack_user_id):
        import github_pr
        import slack_helper

        mock_slack_user_id.side_effect = [
            "assignee",  # _on_pr_review_requested_person: message to channel
            "sender",  # mention_in_reply: mention in message to channel
            "assignee",  # add_users: invite reviewer to channel
            "sender",  # mention_in_reply: mention in DM to reviewer
        ]
        slack_helper.shared_client.chat_postMessage.reset_mock()

        github_pr._on_pr_review_requested_person(
            FakeGithubUser("assignee"), FakeGithubUser("sender"), "C987", "assignee"
        )

        slack_helper.shared_client.chat_postMessage.assert_any_call(
            channel="C987",
            text="<@sender> added <@assignee> as an assignee",
            thread_ts=None,
        )
        slack_helper.shared_client.chat_postMessage.assert_called_with(
            channel="assignee",
            text="<@sender> added you as an assignee to a PR: <#C987>",
            thread_ts=None,
        )

    def test_self_assignee(self, mock_slack_user_id):
        import github_pr
        import slack_helper

        mock_slack_user_id.side_effect = ["U123", "U123", "U123"]
        slack_helper.shared_client.chat_postMessage.reset_mock()

        github_pr._on_pr_review_requested_person(
            FakeGithubUser("sender"), FakeGithubUser("sender"), "C987", "assignee"
        )

        slack_helper.shared_client.chat_postMessage.assert_called_once_with(
            channel="C987",
            text="<@U123> added themselves as an assignee",
            thread_ts=None,
        )


class TestOnPRReviewRequestRemovedPerson:
    """Unit tests for the "_on_pr_review_request_removed_person" function."""

    def test_reviewer(self, mock_slack_user_id):
        import github_pr
        import slack_helper

        mock_slack_user_id.side_effect = [
            "reviewer",  # _on_pr_review_requested_person: message to channel
            "sender",  # mention_in_reply: mention in message to channel
        ]
        slack_helper.shared_client.chat_postMessage.reset_mock()

        github_pr._on_pr_review_request_removed_person(
            FakeGithubUser("reviewer"), FakeGithubUser("sender"), "C987", "reviewer"
        )

        slack_helper.shared_client.chat_postMessage.assert_any_call(
            channel="C987",
            text="<@sender> removed <@reviewer> as a reviewer",
            thread_ts=None,
        )

    def test_self_reviewer(self, mock_slack_user_id):
        import github_pr
        import slack_helper

        mock_slack_user_id.side_effect = ["U123", "U123"]
        slack_helper.shared_client.chat_postMessage.reset_mock()

        github_pr._on_pr_review_request_removed_person(
            FakeGithubUser("sender"), FakeGithubUser("sender"), "C987", "reviewer"
        )

        slack_helper.shared_client.chat_postMessage.assert_called_with(
            channel="C987",
            text="<@U123> removed themselves as a reviewer",
            thread_ts=None,
        )

    def test_assignee(self, mock_slack_user_id):
        import github_pr
        import slack_helper

        mock_slack_user_id.side_effect = [
            "assignee",  # _on_pr_review_requested_person: message to channel
            "sender",  # mention_in_reply: mention in message to channel
        ]
        slack_helper.shared_client.chat_postMessage.reset_mock()

        github_pr._on_pr_review_request_removed_person(
            FakeGithubUser("assignee"), FakeGithubUser("sender"), "C987", "assignee"
        )

        slack_helper.shared_client.chat_postMessage.assert_any_call(
            channel="C987",
            text="<@sender> removed <@assignee> as an assignee",
            thread_ts=None,
        )

    def test_self_assignee(self, mock_slack_user_id):
        import github_pr
        import slack_helper

        mock_slack_user_id.side_effect = ["U123", "U123"]
        slack_helper.shared_client.chat_postMessage.reset_mock()

        github_pr._on_pr_review_request_removed_person(
            FakeGithubUser("sender"), FakeGithubUser("sender"), "C987", "assignee"
        )

        slack_helper.shared_client.chat_postMessage.assert_called_once_with(
            channel="C987",
            text="<@U123> removed themselves as an assignee",
            thread_ts=None,
        )



================================================
FILE: kittehub/devops/purrr/markdown_test.py
================================================
"""Unit tests for the "markdown" module."""

import collections

from autokitteh import github, slack
import pytest


@pytest.fixture(autouse=True)
def setup_mock_github_and_slack_clients(mocker):
    mocker.patch.object(github, "github_client", autospec=True)
    mocker.patch.object(slack, "slack_client", autospec=True)


class TestGithubToSlack:
    """Unit tests for the "github_to_slack" function."""

    def test_trivial(self):
        import text_utils

        assert text_utils.github_to_slack("", "") == ""

    def test_basic_headers(self):
        import text_utils

        assert text_utils.github_to_slack("# H1", "") == "*H1*"
        assert text_utils.github_to_slack("## H2", "") == "*H2*"
        assert text_utils.github_to_slack("### H3", "") == "*H3*"

    def test_multiple_headers(self):
        import text_utils

        a = text_utils.github_to_slack("# Title 1\n\nFoo\n\n## Subtitle 2\nBar", "")
        assert a == "*Title 1*\n\nFoo\n\n*Subtitle 2*\nBar"

    def test_basic_text_style(self):
        import text_utils

        assert text_utils.github_to_slack("_italic_", "") == "_italic_"
        assert text_utils.github_to_slack("*italic*", "") == "_italic_"
        assert text_utils.github_to_slack("__bold__", "") == "*bold*"
        assert text_utils.github_to_slack("**bold**", "") == "*bold*"
        assert text_utils.github_to_slack("~~strikethrough~~", "") == "~strikethrough~"

    def test_advanced_text_style(self):
        import text_utils

        assert text_utils.github_to_slack("***both***", "") == "_*both*_"
        actual = text_utils.github_to_slack("**this _is_ nested**", "")
        assert actual == "*this _is_ nested*"
        actual = text_utils.github_to_slack("**this *is* nested**", "")
        assert actual == "*this _is_ nested*"
        actual = text_utils.github_to_slack("__this _is_ nested__", "")
        assert actual == "*this _is_ nested*"
        actual = text_utils.github_to_slack("_this **is** nested_", "")
        assert actual == "_this *is* nested_"
        # TODO:
        # actual = text_utils.github_to_slack("*this **is** nested*", "")
        # assert actual == "_this *is* nested_"

    def test_quote_blocks(self):
        import text_utils

        actual = text_utils.github_to_slack("111\n>222\n> 333\n444", "")
        assert actual == "111\n>222\n> 333\n444"

    def test_code_blocks(self):
        import text_utils

        assert text_utils.github_to_slack("`inline`", "") == "`inline`"
        actual = text_utils.github_to_slack("```\nmulti\nline\n```", "")
        assert actual == "```\nmulti\nline\n```"

    def test_links(self):
        import text_utils

        assert text_utils.github_to_slack("[text](url)", "") == "<url|text>"
        actual = text_utils.github_to_slack("!<url maybe with text>", "")
        assert actual == "Image: <url maybe with text>"

    def test_simple_lists(self):
        import text_utils

        expected = "  â€¢  111\n  â€¢  222\n  â€¢  333"
        assert text_utils.github_to_slack("- 111\n- 222\n- 333", "") == expected
        assert text_utils.github_to_slack("+ 111\n+ 222\n+ 333", "") == expected
        # TODO: assert ...github_to_slack("* 111\n* 222\n* 333", "") == expected

    def test_nested_lists(self):
        import text_utils

        exp = "  â€¢  111\n          â—¦   222\n          â—¦   333\n  â€¢  444"
        assert text_utils.github_to_slack("- 111\n  - 222\n  - 333\n- 444", "") == exp
        assert text_utils.github_to_slack("+ 111\n  + 222\n  + 333\n+ 444", "") == exp
        # TODO: assert ...github_to_slack("* 111\n  * 222\n  * 333\n* 444", "") == exp

    def test_user_mentions(self, mocker):
        import text_utils
        import users

        pr = "https://github.com/org/repo/pull/123"
        id = mocker.patch.object(
            users, "github_username_to_slack_user_id", autospec=True
        )
        id.side_effect = ["U123", None, None]

        # Slack user found.
        assert text_utils.github_to_slack("@user", pr) == "<@U123>"
        # Slack user not found.
        actual = text_utils.github_to_slack("@user", pr)
        assert actual == "<https://github.com/user|@user>"
        # Team not found.
        actual = text_utils.github_to_slack("@org/team", pr)
        assert actual == "<https://github.com/org/teams/team|@org/team>"

    def test_pr_references(self):
        import text_utils

        pr = "https://github.com/org/repo/pull/987"
        actual = text_utils.github_to_slack("#123", pr)
        assert actual == "<https://github.com/org/repo/pull/123|#123>"

    def test_html_comments(self):
        import text_utils

        actual = text_utils.github_to_slack("Blah\n<!-- hidden -->\nBlah blah", "")
        assert actual == "Blah\n\nBlah blah"


class TestSlackToGithub:
    """Unit tests for the "slack_to_github" function."""

    def test_trivial(self):
        import text_utils

        assert text_utils.slack_to_github("") == ""

    def test_text_style(self):
        import text_utils

        assert text_utils.slack_to_github("_italic_") == "_italic_"
        assert text_utils.slack_to_github("*bold*") == "**bold**"
        assert text_utils.slack_to_github("_*both*_") == "***both***"
        assert text_utils.slack_to_github("~strikethrough~") == "~~strikethrough~~"

        # Not needed, but good to have just in case someone
        # sends a non-Slack-markdown message programmatically:
        assert text_utils.slack_to_github("__italic__") == "_italic_"
        assert text_utils.slack_to_github("**bold**") == "**bold**"
        assert text_utils.slack_to_github("*_both_*") == "***both***"
        assert text_utils.slack_to_github("***both***") == "***both***"
        assert text_utils.slack_to_github("~~strikethrough~~") == "~~strikethrough~~"

    def test_quote_blocks(self):
        import text_utils

        actual = text_utils.slack_to_github("111\n&gt;222\n&gt; 333\n444")
        assert actual == "111\n>222\n> 333\n444"
        actual = text_utils.slack_to_github("111\n>222\n> 333\n444")
        assert actual == "111\n>222\n> 333\n444"

    def test_code_blocks(self):
        import text_utils

        assert text_utils.slack_to_github("`inline`") == "`inline`"
        assert text_utils.slack_to_github("```mult\nline```") == "```\nmult\nline\n```"

    def test_lists(self):
        import text_utils

        assert text_utils.slack_to_github("â€¢ X\nâ€¢ Y\nâ€¢ Z") == "- X\n- Y\n- Z"
        actual = text_utils.slack_to_github(
            "â€¢ X\n    â—¦ Y\n        â–ªï¸Ž Z\n            â€¢ A\n                â—¦ B"
        )
        assert actual == "- X\n  - Y\n    - Z\n      - A\n        - B"

    def test_links(self):
        import text_utils

        assert text_utils.slack_to_github("<url|text>") == "[text](url)"
        assert text_utils.slack_to_github("<url|>"), "[](url)"
        assert text_utils.slack_to_github("<url>"), "<url>"

    def test_channel(self, mocker):
        import text_utils

        channel = mocker.patch.object(text_utils, "_slack_channel_name", autospec=True)
        channel.return_value = "CHANNEL_NAME"
        team = mocker.patch.object(text_utils, "_slack_team_id", autospec=True)
        team.return_value = "TEAM_ID"

        expected = "[#CHANNEL_NAME](slack://channel?team=TEAM_ID&id=C123)"
        assert text_utils.slack_to_github("<#C123>") == expected
        assert text_utils.slack_to_github("<#C123|>") == expected

        actual = text_utils.slack_to_github("<#C123|custom-name>")
        assert actual == "[#custom-name](slack://channel?team=TEAM_ID&id=C123)"


FakeGithubUser = collections.namedtuple("FakeGithubUser", ["name", "login"])


class TestSlackToGithubUserMentions:
    """Unit tests for user mentions in the "slack_to_github" function."""

    @pytest.fixture
    def mock_github_user_id(self, mocker):
        import users

        return mocker.patch.object(users, "_email_to_github_user_id", autospec=True)

    @pytest.fixture
    def mock_github_users(self, mocker):
        import users

        return mocker.patch.object(users, "_github_users", autospec=True)

    @pytest.fixture
    def mock_slack_user_info(self, mocker):
        import users

        return mocker.patch.object(users, "_slack_user_info", autospec=True)

    def test_slack_user_info_error(self, mock_slack_user_info):
        import text_utils

        mock_slack_user_info.return_value = {}
        assert text_utils.slack_to_github("<@U123>") == "Someone"

    def test_email_and_name_not_found_in_slack_profile(self, mock_slack_user_info):
        import text_utils

        mock_slack_user_info.return_value = {"profile": {"foo": "bar"}}
        assert text_utils.slack_to_github("<@U123>") == "Someone"

    def test_named_and_unnamed_slack_apps(self, mock_slack_user_info):
        import text_utils

        mock_slack_user_info.side_effect = [
            {"is_bot": True, "profile": {"real_name": "Mr. Robot"}},
            {"is_bot": True},
        ]
        assert text_utils.slack_to_github("<@U123>") == "Mr. Robot"
        assert text_utils.slack_to_github("<@U123>") == "Some Slack app"

    def test_match_by_email(self, mock_github_user_id, mock_slack_user_info):
        import text_utils

        mock_github_user_id.return_value = "username"
        mock_slack_user_info.return_value = {"profile": {"email": "me@test.com"}}
        assert text_utils.slack_to_github("<@U123>") == "@username"

    def test_match_by_name(
        self, mock_github_user_id, mock_github_users, mock_slack_user_info
    ):
        import text_utils

        mock_github_user_id.return_value = ""
        mock_github_users.return_value = [FakeGithubUser("John Doe", "username")]
        mock_slack_user_info.return_value = {
            "profile": {"email": "me@test.com", "real_name": "John Doe"}
        }
        assert text_utils.slack_to_github("<@U123>") == "@username"

    def test_no_matches_by_name(
        self, mock_github_user_id, mock_github_users, mock_slack_user_info
    ):
        import text_utils

        mock_github_user_id.return_value = ""
        mock_github_users.return_value = []
        mock_slack_user_info.return_value = {
            "profile": {"email": "me@test.com", "real_name": "John Doe"}
        }
        assert text_utils.slack_to_github("<@U123>") == "John Doe"

    def test_too_many_matches_by_name(
        self, mock_github_user_id, mock_github_users, mock_slack_user_info
    ):
        import text_utils

        mock_github_user_id.return_value = ""
        mock_github_users.return_value = [
            FakeGithubUser("John Doe", "username1"),
            FakeGithubUser("john doe", "username2"),
            FakeGithubUser("JOHN DOE", "username3"),
        ]
        mock_slack_user_info.return_value = {
            "profile": {"email": "me@test.com", "real_name": "John Doe"}
        }
        assert text_utils.slack_to_github("<@U123>") == "John Doe"



================================================
FILE: kittehub/devops/purrr/slack_channel.py
================================================
"""Create and manage Slack channels."""

import json
import time

from autokitteh.slack import normalize_channel_name
from slack_sdk.errors import SlackApiError

import data_helper
import debug
import slack_helper
import text_utils
import users


# Character limit for topics and descriptions of Slack channels.
_MAX_METADATA_LENGTH = 250

# Wait for a few seconds to handle other asynchronous events
# (e.g. a PR closure comment) before archiving the channel.
_PR_CLOSE_DELAY = 5


slack = slack_helper.shared_client


def initialize_for_github_pr(action: str, pr, sender) -> str:
    """Initialize a Slack channel that represents a GitHub PR.

    Args:
        action: GitHub PR event action.
        pr: GitHub PR data.
        sender: GitHub user object of the PR sender.

    Returns:
        ID of the created Slack channel.
    """
    print(f"Creating Slack channel for {pr.html_url} (PR event action: {action})")
    print(json.dumps(pr, indent=4, sort_keys=True))

    name = f"{pr.number}_{normalize_channel_name(pr.title)}"
    channel_id = slack_helper.create_channel(name)
    if not channel_id:
        _report_creation_error(pr, sender.login)

    _set_topic(pr, channel_id)
    _set_description(pr, channel_id)
    _set_bookmarks(pr, channel_id)
    _post_messages(action, pr, sender, channel_id)

    # TODO: Map between the GitHub PR and the Slack channel ID, for 2-way event syncs.

    add_users(channel_id, users.github_pr_participants(pr))
    return channel_id


def _report_creation_error(pr, github_username) -> None:
    """Report to the PR sender that a Slack channel wasn't created for it, and abort."""
    error = "Failed to create Slack channel for " + pr.html_url
    debug.log(error)

    user_id = users.github_username_to_slack_user_id(github_username)
    if user_id and not data_helper.slack_opted_out(user_id):
        slack.chat_postMessage(channel=user_id, text=error)

    raise RuntimeError(error)


def _set_topic(pr, channel_id: str) -> None:
    """Set the topic of a Slack channel to a GitHub PR URL."""
    topic = pr.html_url
    if len(topic) > _MAX_METADATA_LENGTH:
        topic = topic[: _MAX_METADATA_LENGTH - 4] + " ..."
    try:
        slack.conversations_setTopic(channel=channel_id, topic=topic)
    except SlackApiError as e:
        error = f"Failed to set the topic of <#{channel_id}> to `{topic}`"
        debug.log(f"{error}: `{e.response['error']}`")


def _set_description(pr, channel_id: str) -> None:
    """Set the description of a Slack channel to a GitHub PR title."""
    title = f"`{pr.title}`"
    if len(title) > _MAX_METADATA_LENGTH:
        title = title[: _MAX_METADATA_LENGTH - 4] + "`..."
    try:
        slack.conversations_setPurpose(channel=channel_id, purpose=title)
    except SlackApiError as e:
        error = f"Failed to set the purpose of <#{channel_id}> to `{title}`"
        debug.log(f"{error}: `{e.response['error']}`")


def _set_bookmarks(pr, channel_id: str) -> None:
    """Set the bookmarks of a Slack channel to important GitHub PR links.

    Bookmark titles are also updated later based on relevant GitHub events.
    """
    pass  # TODO: Implement this function.


def _post_messages(action: str, pr, sender, channel_id: str) -> None:
    """Post initial messages to a Slack channel, describing a GitHub PR."""
    if action == "ready_for_review":
        action = "marked as ready for review"

    msg = f"{{}} {action} {pr.html_url}: `{pr.title}`"

    if pr.body:
        msg += "\n\n" + text_utils.github_to_slack(pr.body, pr.html_url)

    slack_helper.mention_in_message(channel_id, sender, msg)

    # TODO: Also post a message summarizing check states (updated
    # later based on "workflow_job" and "workflow_run" events).


def add_users(channel_id: str, github_users: list[str]) -> None:
    """Invite all the participants in a GitHub PR to a Slack channel."""
    slack_users = [users.github_username_to_slack_user_id(u) for u in github_users]
    slack_users = [user for user in slack_users if user]  # Ignore unrecognized users.

    # Also ignore users who opted out of Purrr. They will still be mentioned
    # in the channel, but as non-members they won't be notified about it.
    slack_users = [u for u in slack_users if not data_helper.slack_opted_out(u)]
    if not slack_users:
        return

    # Limit the number of users per https://api.slack.com/methods/conversations.invite
    if len(slack_users) > 1000:
        slack_users = slack_users[:1000]

    user_ids = ",".join(slack_users)
    try:
        slack.conversations_invite(channel=channel_id, users=user_ids, force=True)
    except SlackApiError as e:
        if e.response["error"] == "already_in_channel":
            return

        error = f"Failed to add {len(slack_users)} Slack user(s) to channel "
        error += f"<#{channel_id}>: `{e.response['error']}`"
        for err in e.response.get("errors", []):
            error += f"\n- <@{err.user}> - `{err.error}`"
        debug.log(error)


def archive(action: str, pr, sender) -> None:
    """Archive a Slack channel that represents a GitHub PR.

    This function is called when a PR is closed or converted to a draft.

    Args:
        action: GitHub PR event action.
        pr: GitHub PR data.
        sender: GitHub user who triggered the event.
    """
    channel_id = slack_helper.lookup_channel(pr.html_url, action)
    if not channel_id:
        # Unrecoverable error, but no need to report/debug it:
        # if we're not tracking it, there's nothing to fix.
        return

    # Wait for a few seconds to handle other asynchronous events
    # (e.g. a PR closure comment) before archiving the channel.
    time.sleep(_PR_CLOSE_DELAY)

    if action == "closed this PR":
        if pr.merged:
            action = "merged this PR"
    else:
        action = "converted this PR to a draft"

    slack_helper.mention_in_message(channel_id, sender, f"{{}} {action}")

    try:
        slack.conversations_archive(channel=channel_id)
    except SlackApiError as e:
        action = action.replace(" this PR", "")
        error = f"{pr.html_url} is `{action}`, but failed to archive <#{channel_id}>"
        debug.log(f"{error}: `{e.response['error']}`")



================================================
FILE: kittehub/devops/purrr/slack_cmd.py
================================================
"""Handler for Slack slash-command events."""

import collections

import data_helper
import slack_helper


slack = slack_helper.shared_client


def on_slack_slash_command(event):
    """Entry-point for AutoKitteh sessions triggered by Slack slash-command events.

    - /purrr help
    - /purrr opt-in
    - /purrr opt-out
    - /purrr list
    - /purrr status [PR]
    - /purrr approve [PR]

    About slash commands: https://api.slack.com/interactivity/slash-commands
    See also: https://api.slack.com/interactivity/handling#message_responses

    Args:
        event: Slack event data.
    """
    # Split the command into normalized arguments.
    data = event.data
    args = str(data.text).lower().split()

    # Route further processing to the appropriate command handler.
    if not args or "help" in args:
        _help(data, args)
        return

    if args[0] in _COMMANDS:
        _COMMANDS[args[0]].handler(data, args)
        return

    error = f"Error: unrecognized Purrr command: `{args[0]}`"
    slack.chat_postEphemeral(channel=data.channel_id, user=data.user_id, text=error)


def _error(data, cmd: str, msg: str):
    """Send a private error message to the user about their command."""
    error = f"Error in `{data.command} {cmd}`: {msg}"
    slack.chat_postEphemeral(channel=data.channel_id, user=data.user_id, text=error)


def _help(data, args: list[str]):
    """Send a private message to the user to list all the available Purrr commands."""
    if len(args) > 2:
        # TODO: Support per-command help too, in the future.
        _error(data, "help", "this command doesn't accept extra arguments")
        return

    # General help message: a list of all the available commands.
    text = _help_text(data)
    slack.chat_postEphemeral(channel=data.channel_id, user=data.user_id, text=text)


def _help_text(data) -> str:
    text = ":wave: *GitHub Pull Request Review Reminder (Purrr)* :wave:\n\n"
    text += "Available slash commands:"
    for cmd in _COMMANDS.values():
        text += f"\n  â€¢  `{data.command} {cmd.label}` - {cmd.description}"
    return text


def _opt_in(data, args: list[str]):
    """User opt-in command handler (this is the default user state)."""
    if len(args) > 1:
        _error(data, args[0], "this command doesn't accept extra arguments")
        return

    if not data_helper.slack_opted_out(data.user_id):
        msg = ":bell: You're already opted into Purrr"
        slack.chat_postEphemeral(channel=data.channel_id, user=data.user_id, text=msg)
        return

    data_helper.slack_opt_in(data.user_id)
    msg = ":bell: You are now opted into Purrr"
    slack.chat_postEphemeral(channel=data.channel_id, user=data.user_id, text=msg)


def _opt_out(data, args: list[str]):
    """User opt-out: don't use Purrr even in a Slack workspace that installed it."""
    if len(args) > 1:
        _error(data, args[0], "this command doesn't accept extra arguments")
        return

    opt_out_time = data_helper.slack_opted_out(data.user_id)
    if opt_out_time:
        msg = f":no_bell: You're already opted out of Purrr since: {opt_out_time}"
        slack.chat_postEphemeral(channel=data.channel_id, user=data.user_id, text=msg)
        return

    data_helper.slack_opt_out(data.user_id)
    msg = ":no_bell: You are now opted out of Purrr"
    slack.chat_postEphemeral(channel=data.channel_id, user=data.user_id, text=msg)


def _list(data, args: list[str]):
    """PR list command handler."""
    if len(args) > 1:
        _error(data, args[0], "this command doesn't accept extra arguments")
        return

    error = "Sorry, this command is not implemented yet"
    slack.chat_postEphemeral(channel=data.channel_id, user=data.user_id, text=error)


def _status(data, args: list[str]):
    """PR status command handler."""
    # TODO: If the Slack channel belongs to a PR, the arg is optional.
    if len(args) != 2:
        msg = "when called outside of a PR channel, this command requires exactly "
        msg += "1 argument - an ID of a GitHub PR (`<org>/<repo>/<number>`), "
        _error(data, args[0], msg + "or the PR's full URL")
        return

    error = "Sorry, this command is not implemented yet"
    slack.chat_postEphemeral(channel=data.channel_id, user=data.user_id, text=error)


def _approve(data, args: list[str]):
    """Approve command."""
    # TODO: If the Slack channel belongs to a PR, the arg is optional.
    if len(args) != 2:
        msg = "when called outside of a PR channel, this command requires exactly "
        msg += "1 argument - an ID of a GitHub PR (`<org>/<repo>/<number>`), "
        _error(data, args[0], msg + "or the PR's full URL")
        return

    error = "Sorry, this command is not implemented yet"
    slack.chat_postEphemeral(channel=data.channel_id, user=data.user_id, text=error)


_Command = collections.namedtuple("Command", ["label", "handler", "description"])

_COMMANDS = {
    "opt-in": _Command("opt-in", _opt_in, "Opt into receiving notifications"),
    "opt-out": _Command("opt-out", _opt_out, "Opt out of receiving notifications"),
    "list": _Command("list", _list, "List all PRs you should pay attention to"),
    "status": _Command("status [PR]", _status, "Check the status of a specific PR"),
    "approve": _Command("approve [PR]", _approve, "Approve a specific PR"),
}



================================================
FILE: kittehub/devops/purrr/slack_cmd_test.py
================================================
"""Unit tests for the "slack_cmd" module."""

from datetime import datetime, UTC

import autokitteh
from autokitteh import github, slack
import pytest


MIN_UTC = datetime.min.replace(tzinfo=UTC)


@pytest.fixture(autouse=True)
def setup_mock_github_and_slack_clients(mocker):
    mocker.patch.object(github, "github_client", autospec=True)
    mocker.patch.object(slack, "slack_client", autospec=True)


@pytest.fixture
def mock_data_helper(mocker):
    import slack_cmd

    return mocker.patch.object(slack_cmd, "data_helper", autospec=True)


fake_data = {
    "channel_id": "purr-debug",
    "user_id": "user",
    "command": "/purrr",
}


def test_help_text():
    import slack_cmd

    data = autokitteh.AttrDict(fake_data)
    text = slack_cmd._help_text(data)

    for cmd in slack_cmd._COMMANDS.values():
        assert cmd.label in text
        assert cmd.description in text


def test_on_slack_slash_command_without_text():
    import slack_cmd

    slack_cmd.slack.chat_postEphemeral.reset_mock()

    event = autokitteh.AttrDict({"data": fake_data | {"text": ""}})
    slack_cmd.on_slack_slash_command(event)

    slack_cmd.slack.chat_postEphemeral.assert_called_once_with(
        channel=event.data.channel_id,
        user=event.data.user_id,
        text=slack_cmd._help_text(event.data),
    )


def test_on_slack_slash_command_with_help():
    import slack_cmd

    slack_cmd.slack.chat_postEphemeral.reset_mock()

    event = autokitteh.AttrDict({"data": fake_data | {"text": "help"}})
    slack_cmd.on_slack_slash_command(event)

    slack_cmd.slack.chat_postEphemeral.assert_called_once_with(
        channel=event.data.channel_id,
        user=event.data.user_id,
        text=slack_cmd._help_text(event.data),
    )


def test_on_slack_slash_command_with_noop_opt_in(mock_data_helper):
    import slack_cmd

    mock_data_helper.slack_opted_out.return_value = ""
    slack_cmd.slack.chat_postEphemeral.reset_mock()

    event = autokitteh.AttrDict({"data": fake_data | {"text": "opt-in"}})
    slack_cmd.on_slack_slash_command(event)

    mock_data_helper.slack_opted_out.assert_called_once_with(event.data.user_id)
    mock_data_helper.slack_opt_in.assert_not_called()
    slack_cmd.slack.chat_postEphemeral.assert_called_once_with(
        channel=event.data.channel_id,
        user=event.data.user_id,
        text=":bell: You're already opted into Purrr",
    )


def test_on_slack_slash_command_with_actual_opt_in(mock_data_helper):
    import slack_cmd

    mock_data_helper.slack_opted_out.return_value = MIN_UTC
    slack_cmd.slack.chat_postEphemeral.reset_mock()

    event = autokitteh.AttrDict({"data": fake_data | {"text": "opt-in"}})
    slack_cmd.on_slack_slash_command(event)

    mock_data_helper.slack_opted_out.assert_called_once_with(event.data.user_id)
    mock_data_helper.slack_opt_in.assert_called_once_with(event.data.user_id)
    slack_cmd.slack.chat_postEphemeral.assert_called_once_with(
        channel=event.data.channel_id,
        user=event.data.user_id,
        text=":bell: You are now opted into Purrr",
    )


def test_on_slack_slash_command_with_noop_opt_out(mock_data_helper):
    import slack_cmd

    mock_data_helper.slack_opted_out.return_value = MIN_UTC
    slack_cmd.slack.chat_postEphemeral.reset_mock()

    event = autokitteh.AttrDict({"data": fake_data | {"text": "opt-out"}})
    slack_cmd.on_slack_slash_command(event)

    mock_data_helper.slack_opted_out.assert_called_once_with(event.data.user_id)
    mock_data_helper.slack_opt_out.assert_not_called()
    slack_cmd.slack.chat_postEphemeral.assert_called_once_with(
        channel=event.data.channel_id,
        user=event.data.user_id,
        text=":no_bell: You're already opted out of Purrr since: "
        "0001-01-01 00:00:00+00:00",
    )


def test_on_slack_slash_command_with_second_opt_out(mock_data_helper):
    import slack_cmd

    mock_data_helper.slack_opted_out.return_value = ""
    slack_cmd.slack.chat_postEphemeral.reset_mock()

    event = autokitteh.AttrDict({"data": fake_data | {"text": "opt-out"}})
    slack_cmd.on_slack_slash_command(event)

    mock_data_helper.slack_opted_out.assert_called_once_with(event.data.user_id)
    mock_data_helper.slack_opt_out.assert_called_once_with(event.data.user_id)
    slack_cmd.slack.chat_postEphemeral.assert_called_once_with(
        channel=event.data.channel_id,
        user=event.data.user_id,
        text=":no_bell: You are now opted out of Purrr",
    )



================================================
FILE: kittehub/devops/purrr/slack_helper.py
================================================
"""Thin layer of logic on top of the Slack API."""

import os

from autokitteh.slack import slack_client
from slack_sdk.errors import SlackApiError

import data_helper
import debug
import users


# PR channel names in Slack: "<prefix>_<number>_<title>".
_CHANNEL_PREFIX = os.getenv("SLACK_CHANNEL_PREFIX", "_pr")

# Visibility of PR channels in Slack: "public" (default) or "private".
_IS_PRIVATE = os.getenv("SLACK_CHANNEL_VISIBILITY", "")

shared_client = slack_client("slack_conn")


def create_channel(name: str) -> str:
    """Create a public or private Slack channel.

    If the name is already taken, add a numeric suffix to it.

    Args:
        name: Desired (and valid) name of the channel.

    Returns:
        Channel ID, or an empty string in case of an error.
    """
    is_private = _IS_PRIVATE.lower().strip() == "private"
    visibility = "private" if is_private else "public"
    suffix = 0

    while True:
        suffix += 1
        n = _CHANNEL_PREFIX + "_" + name if suffix == 1 else f"{name}_{suffix}"
        try:
            resp = shared_client.conversations_create(name=n, is_private=is_private)
            channel_id = resp["channel"]["id"]
            print(f"Created {visibility} Slack channel {n!r} ({channel_id})")
            return channel_id
        except SlackApiError as e:
            if e.response["error"] != "name_taken":
                error = f"Failed to create {visibility} Slack channel `{n}`"
                debug.log(f"{error}: `{e.response['error']}`")
                return ""


def rename_channel(channel_id: str, name: str) -> None:
    """Safely rename a Slack channel.

    If the name is already taken, add a numeric suffix to it.

    Args:
        channel_id: Slack channel ID.
        name: Desired (and valid) name of the channel.
    """
    suffix = 0
    while True:
        suffix += 1
        n = _CHANNEL_PREFIX + "_" + name if suffix == 1 else f"{name}_{suffix}"
        try:
            shared_client.conversations_rename(channel=channel_id, name=n)
            print(f"Renamed Slack channel to {n!r} ({channel_id})")
            return
        except SlackApiError as e:
            if e.response["error"] != "name_taken":
                error = f"Failed to rename Slack channel <#{channel_id}> to `{n}`"
                debug.log(f"{error}: `{e.response['error']}`")
                return


def impersonate_in_message(channel_id: str, github_user, msg: str) -> str:
    """Post a message to a Slack channel, on behalf of a GitHub user.

    Similar functions:
    - impersonate_in_reply
    - mention_in_message
    - mention_in_reply

    Args:
        channel_id: ID of the channel to send the message to.
        github_user: GitHub user object of the impersonated user.
        msg: Message to send.

    Returns:
        Message's thread timestamp, or "" in case of an error.
    """
    return impersonate_in_reply(channel_id, "", github_user, msg)


def impersonate_in_reply(
    channel_id: str, comment_url: str, github_user, msg: str
) -> str:
    """Post a reply to a Slack thread, on behalf of a GitHub user.

    Similar functions:
    - impersonate_in_message
    - mention_in_message
    - mention_in_reply

    Args:
        channel_id: ID of the channel to send the message to.
        comment_url: URL of the GitHub PR comment to reply to.
        github_user: GitHub user object of the impersonated user.
        msg: Message to send.

    Returns:
        Message's thread timestamp, or "" in case of an error.
    """
    # TODO: Is this check needed?
    # if not channel_id:
    #     return ""

    user = users.github_username_to_slack_user(github_user.login)
    if not user:
        return ""

    profile = user.get("profile", {})
    icon = profile.get("image_48")
    name = profile.get("real_name")
    ts = _lookup_message(comment_url)

    try:
        resp = shared_client.chat_postMessage(
            channel=channel_id, text=msg, thread_ts=ts, icon_url=icon, username=name
        )
        return resp["ts"]
    except SlackApiError as e:
        error = f"Failed to post {'reply' if ts else 'message'} "
        error += f"as <@{user['id']}> in <#{channel_id}>"
        debug.log(f"{error}: `{e.response['error']}`")
        return ""


def lookup_channel(pr_url: str, action: str) -> str | None:
    """Return the ID of a Slack channel that represents a GitHub PR.

    This function waits up to a few seconds for the PR's Slack message to exist,
    because GitHub events are asynchronous. For example: when a PR is re/opened,
    some "review_requested" events may arrive before the "opened" event.

    Args:
        pr_url: URL of the GitHub PR.
        action: GitHub PR event action.

    Returns:
        Channel ID, or None if not found.
    """
    channel_id = data_helper.lookup_github_link_details(pr_url)
    if not channel_id:
        debug.log(f"{pr_url} is `{action}`, but its Slack channel ID not found")
    return channel_id


def _lookup_message(comment_url: str) -> str | None:
    """Return the ID (timestamp) of a Slack message that represents a GitHub PR review.

    This function waits up to a few seconds for the PR review's Slack message
    to exist, because GitHub events are asynchronous. For example: when a PR
    review is submitted with file and line comments, some "child" comment
    events may arrive before the "parent" review event.

    Args:
        comment_url: URL of the GitHub PR comment to reply to.

    Returns:
        Message's thread timestamp, or None if not found.
    """
    thread_ts = data_helper.lookup_github_link_details(comment_url)
    if not thread_ts:
        debug.log(f"Slack message mapping for {comment_url} not found")
    return thread_ts


def mention_in_message(channel_id: str, github_user, msg: str) -> str:
    """Post a message to a Slack channel, mentioning a GitHub user.

    Similar functions:
    - impersonate_user_in_message
    - impersonate_user_in_reply
    - mention_user_in_reply

    Args:
        channel_id: ID of the channel to send the message to.
        github_user: GitHub user object of the mentioned user.
        msg: Message to send, containing a single "{}" placeholder.

    Returns:
        Message's thread timestamp, or "" in case of an error.
    """
    return mention_in_reply(channel_id, "", github_user, msg)


def mention_in_reply(channel_id: str, comment_url: str, github_user, msg: str) -> str:
    """Post a reply to a Slack thread, mentioning a GitHub user.

    Similar functions:
    - impersonate_user_in_message
    - impersonate_user_in_reply
    - mention_user_in_message

    Args:
        channel_id: ID of the channel to send the message to.
        comment_url: URL of the GitHub PR comment to reply to.
        github_user: GitHub user object of the mentioned user.
        msg: Message to send, containing a single "{}" placeholder.

    Returns:
        Message's thread timestamp, or "" in case of an error.
    """
    # TODO: Is this check needed?
    # if not channel_id:
    #     return ""

    m = msg.format(users.format_github_user_for_slack(github_user))
    ts = _lookup_message(comment_url)

    try:
        resp = shared_client.chat_postMessage(channel=channel_id, text=m, thread_ts=ts)
        return resp["ts"]
    except SlackApiError as e:
        error = f"Failed to post {'reply' if ts else 'message'} in <#{channel_id}>"
        debug.log(f"{error}: `{e.response['error']}`")
        return ""



================================================
FILE: kittehub/devops/purrr/text_utils.py
================================================
"""Markdown-related helper functions across GitHub and Slack."""

import collections
import re
from urllib.parse import urlparse

from slack_sdk.errors import SlackApiError

import debug
import slack_helper
import users


_GithubUser = collections.namedtuple("GithubUser", ["login", "html_url"])
_SlackChannel = collections.namedtuple("SlackChannel", ["name", "id"])
_SlackUser = collections.namedtuple("SlackUser", ["link", "id"])


slack = slack_helper.shared_client


def github_to_slack(text: str, pr_url: str) -> str:
    """Convert GitHub markdown text to Slack markdown text.

    References:
    - https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax
    - https://api.slack.com/reference/surfaces/formatting

    Args:
        text: Text body, possibly containing GitHub markdown.
        pr_url: URL of the PR we're working on, used to convert
            other PR references in the text ("#123") to links.

    Returns:
        Slack markdown text.
    """
    # Header lines --> bold lines.
    text = re.sub(r"^#+\s+(.+)", r"**\1**", text, flags=re.MULTILINE)

    # Bold and italic text together: "*** ... ***" --> "_* ... *_".
    text = re.sub(r"\*\*\*(.+?)\*\*\*", r"_**\1**_", text)

    # Italic text: "*" --> "_" ("_" -> "_" is a no-op).
    text = re.sub(r"(^|[^*])\*([^*]+?)\*", r"\1_\2_", text)

    # Bold text: "**" or "__" --> "*".
    text = re.sub(r"\*\*(.+?)\*\*", r"*\1*", text)
    text = re.sub(r"__(.+?)__", r"*\1*", text)

    # Strikethrough text: "~~" --> "~" ("~" -> "~" is a no-op).
    text = re.sub(r"~~(.+?)~~", r"~\1~", text)

    # Links: "[text](url)" --> "<url|text>".
    # Images: "![text](url)" --> "!<url|text>" --> "Image: <url|text>".
    text = re.sub(r"\[(.*?)\]\((.*?)\)", r"<\2|\1>", text)
    text = re.sub(r"!<(.*?)>", r"Image: <\1>", text)

    # Lists (up to 2 levels): "-" or "*" or "+" --> "â€¢" and "â—¦".
    for bullet in ("-", r"\+"):
        text = re.sub(rf"^{bullet}\s*", "  â€¢  ", text, flags=re.MULTILINE)
        text = re.sub(
            rf"^\s{{2,4}}{bullet}\s*", r"          â—¦   ", text, flags=re.MULTILINE
        )

    # Mentions: "@user" --> "<@U123>" or "<https://github.com/user|@user>",
    # "@org/team" --> "<https://github.com/org/teams/team|@org/team>".
    for github_user in re.findall(r"@[\w/-]+", text):
        parsed = urlparse(pr_url)
        url_suffix = github_user[1:]
        if "/" in url_suffix:
            url_suffix = url_suffix.replace("/", "/teams/")
        profile_link = f"{parsed.scheme}://{parsed.netloc}/{url_suffix}"
        user_obj = _GithubUser(login=github_user[1:], html_url=profile_link)
        slack_user = users.format_github_user_for_slack(user_obj)
        text = text.replace(github_user, slack_user)

    # PR references: "#123" --> "<PR URL|#123>" (works for issues too).
    url_base = re.sub(r"/pull/\d+$", "/pull", pr_url)
    text = re.sub(r"#(\d+)", rf"<{url_base}/\1|#\1>", text)

    # Hide HTML comments.
    text = re.sub(r"<!--.+?-->", "", text, flags=re.DOTALL)

    return text


def slack_to_github(text: str) -> str:
    """Convert Slack markdown text to GitHub markdown text.

    References:
    - https://api.slack.com/reference/surfaces/formatting
    - https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax

    Args:
        text: Text body, possibly containing Slack markdown.

    Returns:
        GitHub markdown text.
    """
    # Bold and italic text together: "_*" or "*_" --> "***".
    text = re.sub(r"_\*(.+?)\*_", r"***\1***", text)
    text = re.sub(r"\*_(.+?)_\*", r"***\1***", text)

    # Bold text: "*" --> "**" (italic text is a no-op: "_" --> "_").
    text = re.sub(r"(^|[^*])\*([^*]+?)\*", r"\1**\2**", text)

    # Italic text: "__" --> "_".
    text = re.sub(r"__(.+?)__", r"_\1_", text)

    # Strikethrough text: "~" --> "~~" ("~~" -> "~~" is a no-op).
    text = re.sub(r"(^|[^~])~([^~]+?)~", r"\1~~\2~~", text)

    # Block quotes: "&gt; aaa" --> "> aaa".
    text = re.sub(r"^&gt;(.*)", r">\1", text, flags=re.MULTILINE)

    # Multiline code blocks: ```aaa\nbbb``` --> ```\naaa\nbbb\n```.
    text = re.sub(r"```(.+?)```", r"```\n\1\n```", text, flags=re.DOTALL)

    # Lists (up to 5 levels): "â€¢", "â—¦", and "â–ªï¸Ž" --> "-".
    text = re.sub(r"^â€¢", "-", text, flags=re.MULTILINE)
    text = re.sub(r"^    â—¦", "  -", text, flags=re.MULTILINE)
    text = re.sub(r"^        â–ªï¸Ž", "    -", text, flags=re.MULTILINE)
    text = re.sub(r"^            â€¢", "      -", text, flags=re.MULTILINE)
    text = re.sub(r"^                â—¦", "        -", text, flags=re.MULTILINE)

    # Links: "<url|text>" or "<@...>" or "<#...>" --> "[text](url)".
    text = re.sub(r"<(.*?)\|(.*?)>", r"[\2](\1)", text)
    text = re.sub(r"<([@#][A-Z0-9]+)>", r"[](\1)", text)

    # Channel references: "<#...>" or "<#...|name>" --> "[name](#...)" -->
    # "[#name](slack://channel?team={TEAM_ID}&id={CHANNEL_ID})"
    # (see https://api.slack.com/reference/deep-linking).
    for channel in re.findall(r"\[(.*?)\]\(#([A-Z0-9]+)\)", text):
        channel = _SlackChannel(*channel)
        old = f"[{channel.name}](#{channel.id})"
        if not channel.name:
            channel = _SlackChannel(_slack_channel_name(channel.id), channel.id)
        team_id = _slack_team_id()
        new = f"[#{channel.name}](slack://channel?team={team_id}&id={channel.id})"
        text = text.replace(old, new)

    # User mentions: "<@...>" --> "[](@...)" --> "@github-user" or "Full Name".
    for slack_user in re.findall(r"(\[.*?\]\(@([A-Z0-9]+)\))", text):
        slack_user = _SlackUser(*slack_user)
        github_user = users.format_slack_user_for_github(slack_user.id)
        text = text.replace(slack_user.link, github_user)

    return text


def _slack_channel_name(id: str) -> str:
    """Return the name of a Slack channel based on its ID."""
    try:
        resp = slack.conversations_info(channel=id)
        return resp.get("channel", {}).get("name", "")
    except SlackApiError as e:
        error = f"Failed to get Slack channel info for <#{id}>"
        debug.log(f"{error}: `{e.response['error']}`")
        return ""


def _slack_team_id() -> str:
    """Return the Slack app's team ID."""
    try:
        return slack.auth_test().get("team_id", "")
    except SlackApiError as e:
        debug.log(f"Slack auth test failed: `{e.response['error']}`")
        return ""



================================================
FILE: kittehub/devops/purrr/users.py
================================================
"""User-related helper functions across GitHub and Slack."""

from autokitteh.slack import slack_client
from github import GithubException
from github import NamedUser
from slack_sdk.errors import SlackApiError

import data_helper
import debug
import github_helper


gh = github_helper.shared_client
slack = slack_client("slack_conn")


def _email_to_github_user_id(email: str) -> str:
    """Convert an email address to a GitHub user ID, or "" if not found."""
    users = gh.search_users(email + " in:email")
    if users.totalCount == 1:
        return users[0].login
    else:
        error = f"GitHub user search results: {users.totalCount} users"
        debug.log(f"{error} with the email address `{email}`")
        return ""


def _email_to_slack_user_id(email: str) -> str:
    """Convert an email address to a Slack user ID, or "" if not found."""
    try:
        resp = slack.users_lookupByEmail(email=email)
        return resp.get("user", {}).get("id", "")
    except SlackApiError as e:
        error = f"Failed to look-up Slack user by email {email}"
        debug.log(f"{error}: `{e.response['error']}`")
        return ""


def format_github_user_for_slack(github_user) -> str:
    """Convert a GitHub user or team to a linkified reference in Slack.

    Args:
        github_user: GitHub user object.

    Returns:
        Slack user reference, or GitHub profile link.
        Used for mentioning users in Slack messages.
    """
    slack_user_id = github_username_to_slack_user_id(github_user.login)
    if slack_user_id:
        # Mention the user by their Slack ID, if possible.
        return f"<@{slack_user_id}>"
    else:
        # Otherwise, fall-back to their GitHub profile link.
        return f"<{github_user.html_url}|@{github_user.login}>"


def format_slack_user_for_github(slack_user_id: str) -> str:
    """Convert a Slack user ID to a GitHub user reference/name.

    This function also caches both successful and failed results for
    a day, to reduce the amount of API calls, especially to Slack.

    Args:
        slack_user_id: Slack user ID.

    Returns:
        GitHub user reference, or the Slack user's full name, or "Someone".
        Used for mentioning users in GitHub reviews and comments.
    """
    if not slack_user_id:
        debug.log("Required input not found: Slack user ID")
        return "Someone"

    # Optimization: if we already have it cached, no need to look it up.
    github_ref = data_helper.cached_github_reference(slack_user_id)
    if github_ref:
        return github_ref

    user = _slack_user_info(slack_user_id)
    if not user:
        # This is never OK, don't cache it in order to keep retrying.
        return "Someone"

    profile = user.get("profile", {})

    # Special case: Slack apps/bots can't have GitHub identities.
    if user.get("is_bot"):
        bot_name = profile.get("real_name", "Some Slack app")
        data_helper.cache_github_reference(slack_user_id, bot_name)
        return bot_name

    # Try to match by the email address first.
    email = profile.get("email", "")
    if not email:
        debug.log(f"Email address not set for Slack user <@{slack_user_id}>")
    else:
        github_id = _email_to_github_user_id(email)
        if github_id:
            github_ref = "@" + github_id
            data_helper.cache_github_reference(slack_user_id, github_ref)
            return github_ref

    # Otherwise, try to match by the user's full name.
    slack_name = profile.get("real_name", "").lower()
    if not slack_name:
        debug.log(f"Slack user <@{slack_user_id}>: `real_name` not found in profile")
        return "Someone"

    users = []
    for user in _github_users():
        if user.name and user.name.lower() == slack_name:
            users.append(user)

    if len(users) == 1:
        github_ref = "@" + users[0].login
        data_helper.cache_github_reference(slack_user_id, github_ref)
        return github_ref

    # Optimization: cache unsuccessful results too (i.e. external collaborators).
    error = f"Slack user <@{slack_user_id}>: found {len(users)}"
    debug.log(f"{error} GitHub org members with the same full name")
    data_helper.cache_github_reference(slack_user_id, profile["real_name"])

    # If all else fails, return the Slack user's full name.
    return profile["real_name"]


def _github_users() -> list[NamedUser.NamedUser]:
    """Return a list of all GitHub users in the organization."""
    try:
        return list(gh.get_organization(github_helper.ORG_NAME).get_members())
    except GithubException as e:
        error = "Failed to list GitHub members in the organization"
        debug.log(f"{error} `{github_helper.ORG_NAME}`:\n```{e}```")
        return []


def github_pr_participants(pr) -> list[str]:
    """Return all the participants in the given GitHub PR.

    Args:
        pr: GitHub PR data.

    Returns:
        List of usernames (author/reviewers/assignees),
        guaranteed to be sorted and without repetitions.
    """
    usernames = []

    # Author.
    if pr.user.type == "User":
        usernames.append(pr.user.login)

    # Specific reviewers (not teams) + assignees.
    for user in pr.requested_reviewers + pr.assignees:
        if user.type == "User" and user.login not in usernames:
            usernames.append(user.login)

    return sorted(usernames)


def github_username_to_slack_user(github_username: str) -> dict:
    """Convert a GitHub username to Slack user data (empty in case of errors)."""
    slack_user_id = github_username_to_slack_user_id(github_username)
    return _slack_user_info(slack_user_id) if slack_user_id else {}


def github_username_to_slack_user_id(github_username: str) -> str:
    """Convert a GitHub username to a Slack user ID, or "" if not found.

    This function tries to match the email address first, and then
    falls back to matching the user's full name (case-insensitive).

    This function also caches both successful and failed results for
    a day, to reduce the amount of API calls, especially to Slack.
    """
    # Don't even check GitHub teams, only individual users.
    if "/" in github_username:
        return ""

    # Optimization: if we already have it cached, no need to look it up.
    slack_user_id = data_helper.cached_slack_user_id(github_username)
    if slack_user_id in ("bot", "not found"):
        return ""
    elif slack_user_id:
        return slack_user_id

    user = gh.get_user(github_username)
    gh_user_link = f"<{user.html_url}|{github_username}>"

    # Special case: GitHub bots can't have Slack identities.
    if user.type == "Bot":
        data_helper.cache_slack_user_id(github_username, "bot")
        return ""

    # Try to match by the email address first.
    if not user.email:
        debug.log(f"GitHub user {gh_user_link}: email address not found")
    else:
        slack_user_id = _email_to_slack_user_id(user.email)
        if slack_user_id:
            data_helper.cache_slack_user_id(github_username, slack_user_id)
            return slack_user_id

    # Otherwise, try to match by the user's full name.
    github_name = (user.name or "").lower()
    if not github_name:
        debug.log(f"GitHub user {gh_user_link}: full name not found")
        return ""

    for user in _slack_users():
        profile = user.get("profile", {})
        real_name = profile.get("real_name", "").lower()
        normalized_name = profile.get("real_name_normalized", "").lower()
        if github_name in (real_name, normalized_name):
            slack_user_id = user.get("id", "")
            data_helper.cache_slack_user_id(github_username, slack_user_id)
            return slack_user_id

    # Optimization: cache unsuccessful results too (i.e. external users).
    debug.log(f"GitHub user {gh_user_link}: email & name not found in Slack")
    data_helper.cache_slack_user_id(github_username, "not found")
    return ""


def _slack_user_info(slack_user_id: str) -> dict:
    """Return all the details of a Slack user based on their ID."""
    try:
        resp = slack.users_info(user=slack_user_id)
        return resp.get("user", {})
    except SlackApiError as e:
        error = f"Failed to get Slack user info for <@{slack_user_id}>"
        debug.log(f"{error}: `{e.response['error']}`")
        return {}


def _slack_users() -> list[dict]:
    """Return a list of all Slack users in the workspace."""
    users = []
    next_cursor = None
    while next_cursor != "":
        try:
            resp = slack.users_list(cursor=next_cursor, limit=100)
            users += resp.get("members", [])
            next_cursor = resp.get("response_metadata", {}).get("next_cursor", "")
        except SlackApiError as e:
            debug.log(f"Failed to list Slack users: `{e.response['error']}`")
            next_cursor = ""

    return users



================================================
FILE: kittehub/devops/reviewkitteh/README.md
================================================
title: ReviewKitteh
description: Monitor a GitHub PR in Slack until it's closed
integrations: ["github", "sheets", "slack"]
categories: ["DevOps"]



================================================
FILE: kittehub/devops/reviewkitteh/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup of
# an AutoKitteh project that integrates GitHub, Google Sheets, and Slack.

version: v1

project:
  name: reviewkitteh

  vars:
    - name: SLACK_CHANNEL_ID
      value:
    - name: GOOGLE_SHEET_ID
      value:
    - name: ORG_DOMAIN
      value:

  connections:
    - name: github_conn
      integration: github
    - name: googlesheets_conn
      integration: googlesheets
    - name: slack_conn
      integration: slack

  triggers:
    - name: github_pull_request
      connection: github_conn
      event_type: pull_request
      filter: data.action == "opened" || data.action == "reopened"
      call: program.py:on_github_pull_request



================================================
FILE: kittehub/devops/reviewkitteh/program.py
================================================
"""Listen for GitHub pull requests and meow at random people.

This program listens for GitHub pull request events and posts a message
to a Slack channel when a pull request is opened or reopened. It then polls
the pull request until it is closed or merged, updating the message with the
current state of the pull request. Every 15 seconds, it also reads a random
name from a Google Sheet and pages that person in the Slack channel.
"""

from datetime import datetime, UTC
import os
import random
import time

from autokitteh.github import github_client
from autokitteh.google import google_sheets_client
from autokitteh.slack import slack_client


CHANNEL_ID = os.getenv("SLACK_CHANNEL_ID", "")
SHEET_ID = os.getenv("GOOGLE_SHEET_ID", "")
ORG_DOMAIN = os.getenv("ORG_DOMAIN", "")

github = github_client("github_conn")
googlesheets = google_sheets_client("googlesheets_conn").spreadsheets().values()
slack = slack_client("slack_conn")


def on_github_pull_request(event):
    """Workflow's entry-point."""
    pr = event.data.pull_request
    msg = f"{pr.html_url} [{pr.state}]"
    ts = slack.chat_postMessage(channel=CHANNEL_ID, text=msg)["ts"]

    i = 0

    while pr.state not in ("closed", "merged"):
        _log(f"Polling #{i}")
        time.sleep(5)

        repo = github.get_repo(event.data.repository.full_name)
        pr = repo.get_pull(pr.number)
        msg = f"{pr.html_url} meow [{pr.state}]"
        slack.chat_update(channel=CHANNEL_ID, ts=ts, text=msg)

        i += 1

        if i % 3 == 0:
            # Spreadsheet contains a list of usernames.
            result = googlesheets.get(spreadsheetId=SHEET_ID, range="A1:A5").execute()
            rows = result.get("values", [])
            the_chosen_one = random.choice(rows)[0]
            _log(f"Meowing at {the_chosen_one}")

            user_email = f"{the_chosen_one}@{ORG_DOMAIN}"
            user = slack.users_lookupByEmail(email=user_email)["user"]
            msg = f"Paging <@{user['id']}>"
            slack.chat_postMessage(channel=CHANNEL_ID, text=msg, thread_ts=ts)


def _log(msg):
    print(f"[{datetime.now(UTC)}] {msg}")



================================================
FILE: kittehub/devops/sftp/README.md
================================================
title: SFTP demo
description: Trigger a file transfer from SFTP to HTTP on webhook call
integrations: ["http"]
categories: ["DevOps"]



================================================
FILE: kittehub/devops/sftp/autokitteh.yaml
================================================
# This is a YAML file that describes the minimal setup of an AutoKitteh SFTP project.

version: v1

project:
  name: SFTP_demo

  triggers:
    - name: webhook
      type: webhook
      event_type: get
      call: program.py:on_webhook_call

  vars:
    - name: HTTP_TARGET
      value: ""



================================================
FILE: kittehub/devops/sftp/program.py
================================================
"""Download a file via SFTP, remove spaces and upload it."""

from io import BytesIO
import os

import autokitteh
import paramiko
import requests


SFTP_CONFIG = {
    "host": "test.rebex.net",
    "port": 22,
    "username": "demo",
    "password": "password",
    "remote_path": "/readme.txt",
}


HTTP_TARGET = os.getenv("HTTP_TARGET")


def download_sftp_file(host, port, username, password, remote_path):
    transport = paramiko.Transport((host, port))
    transport.connect(username=username, password=password)
    sftp = paramiko.SFTPClient.from_transport(transport)

    file_io = BytesIO()
    sftp.getfo(remote_path, file_io)
    file_io.seek(0)

    sftp.close()
    transport.close()
    return file_io


def remove_spaces(file_io):
    content = file_io.read().decode("utf-8").replace(" ", "")
    return BytesIO(content.encode("utf-8"))


def send_file_http(file_io, filename, url):
    file_io.seek(0)
    files = {"file": (filename, file_io)}
    response = requests.post(url, files=files, timeout=10)
    return response.status_code, response.text


# Use a single activity to avoid Temporal's data serialization between steps.
# - big files boundary.
# - Keeps a stream (not serializable) in-process.
@autokitteh.activity
def on_webhook_call(_):
    """Download a file via SFTP, remove spaces and upload it."""
    print("Downloading from SFTP...")
    file_io = download_sftp_file(**SFTP_CONFIG)

    processed = remove_spaces(file_io)

    print(f"Sending to {HTTP_TARGET}...")
    status, msg = send_file_http(processed, "readme.txt", HTTP_TARGET)
    print(f"Upload status: {status}, Message: {msg}")



================================================
FILE: kittehub/devops/sftp/requirements.txt
================================================
paramiko


================================================
FILE: kittehub/discord_to_spreadsheet/README.md
================================================



================================================
FILE: kittehub/discord_to_spreadsheet/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup
# of an AutoKitteh project that logs messages from Discord to a
# Google Sheets document.

version: v1

project:
  name: discord_to_spreadsheet

  vars:
    - name: RANGE_NAME
      value: Sheet1!A1
    - name: SPREADSHEET_ID
      value:

  connections:
    - name: discord_conn
      integration: discord
    - name: googlesheets_conn
      integration: googlesheets

  triggers:
    - name: on_discord_message
      connection: discord_conn
      event_type: message_create
      call: program.py:on_discord_message



================================================
FILE: kittehub/discord_to_spreadsheet/program.py
================================================
"""Log Discord message events and the author's username into a Google Sheet."""

import os

from autokitteh.google import google_sheets_client


SPREADSHEET_ID = os.getenv("SPREADSHEET_ID")
RANGE_NAME = os.getenv("RANGE_NAME")

sheet = google_sheets_client("googlesheets_conn").spreadsheets().values()


def on_discord_message(event):
    values = [[event.data["author"]["username"], event.data["content"]]]
    sheet.append(
        spreadsheetId=SPREADSHEET_ID,
        range=RANGE_NAME,
        valueInputOption="USER_ENTERED",
        body={"values": values},
    ).execute()



================================================
FILE: kittehub/github_copilot_seats/README.md
================================================
title: Cancel GitHub Copilot access for inactive users
description: If Copilot was not used in a preceding period by users, unsubscribe and notify them in Slack. Users can ask for their subscription to be reinstated.
integrations: ["githubcopilot", "slack"]
categories: ["DevOps"]



================================================
FILE: kittehub/github_copilot_seats/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup
# of an AutoKitteh project that manages GitHub Copilot subscriptions.

version: v1

project:
  name: github_copilot_seats

  vars:
    - name: IDLE_HOURS_THRESHOLD
      value: 72
    # Optional: manage GitHub Copilot subscriptions only for these users, separated by commas.
    - name: MANAGED_LOGINS
      value:
    # Optional: Slack channel name or ID, for debugging.
    - name: SLACK_LOG_CHANNEL
      value:

  connections:
    - name: github_conn
      integration: github
    - name: slack_conn
      integration: slack

  triggers:
    - name: check_daily
      schedule: "@daily"
      call: triggers.py:on_schedule
    - name: check_now
      connection: slack_conn
      event_type: slash_command
      call: triggers.py:on_slack_slash_command



================================================
FILE: kittehub/github_copilot_seats/message.json
================================================
{
	"blocks": [
		{
			"type": "header",
			"text": {
				"type": "plain_text",
				"text": "You have been removed from the Copilot program due to inactivity",
				"emoji": true
			}
		},
		{
			"type": "section",
			"text": {
				"type": "mrkdwn",
				"text": "Please select an option:"
			}
		},
		{
			"type": "actions",
			"elements": [
				{
					"type": "button",
					"text": {
						"type": "plain_text",
						"text": ":repeat: Reinstate",
						"emoji": true
					},
					"value": "reinstate",
					"action_id": "reinstate-action"
				},
				{
					"type": "button",
					"text": {
						"type": "plain_text",
						"text": ":relieved: OK",
						"emoji": true
					},
					"value": "ok",
					"action_id": "ok-action"
				}
			]
		}
	]
}



================================================
FILE: kittehub/github_copilot_seats/seats.py
================================================
"""Manage GitHub Copilot seat assignments within an organization.

It identifies inactive users and prunes their seats,
but allow the users to get them back via Slack.
"""

from datetime import datetime, timedelta, UTC
import json
import os
from pathlib import Path

import autokitteh
from autokitteh.github import github_client
from autokitteh.slack import slack_client

from users import github_username_to_slack_user_id


GITHUB_ORG_NAME = os.getenv("github_conn__target_name", "")
IDLE_HOURS_THRESHOLD = int(os.getenv("IDLE_HOURS_THRESHOLD", "72"))
MANAGED_LOGINS = os.getenv("MANAGED_LOGINS")

github = github_client("github_conn")
org = github.get_organization(GITHUB_ORG_NAME)
copilot = org.get_copilot()

slack = slack_client("slack_conn")


def find_idle_seats(*, prune: bool = False) -> list[dict[str, str]]:
    """Identifies idle GitHub Copilot users based on their last activity time.

    If `prune` is set to `True`, it also cancels their seat assignments and
    interacts with the users asynchronously to confirm this action.
    """
    idle_seats = []
    for seat in copilot.get_seats():
        # If the project is limited to specific org users, ignore the rest.
        managed_logins = MANAGED_LOGINS.split(",") if MANAGED_LOGINS else []
        if managed_logins and seat.assignee.login not in managed_logins:
            print(f"Skipping unmanaged user: {seat.assignee.login}")
            continue

        # Was the assigned seat being used recently?
        now = datetime.now(UTC)
        delta = now - seat.last_activity_at
        is_active = delta < timedelta(hours=IDLE_HOURS_THRESHOLD)

        comparison = "<" if is_active else ">="
        status = f"{seat.assignee.login}: {now} - {seat.last_activity_at} = "
        status += f"{delta} {comparison} {IDLE_HOURS_THRESHOLD} hours"
        print(status)

        if is_active:
            continue

        # Convert the non-serializable "CopilotSeat" object into a simple dictionary.
        simple_seat = {
            "assignee_login": seat.assignee.login,
            "last_activity_at": seat.last_activity_at.isoformat(),
        }
        idle_seats.append(simple_seat)

        # Interact with the user asynchronously in a child workflow.
        if prune:
            autokitteh.start(loc="seats.py:prune_idle_seat", data=simple_seat)

    return idle_seats


def prune_idle_seat(seat: dict[str, str]) -> None:
    """Interacts via Slack with a GitHub user assigned to an idle Copilot seat.

    Note:
        This function is designed to run as a child workflow, by calling:
        autokitteh.start(loc="seats.py:prune_idle_seat", data={...})

    Args:
        seat: Username and last activity timestamp of the GitHub user to which
            the Copilot seat is assigned.
    """
    github_login = seat.data["assignee_login"]
    report(github_login, "removing seat")
    copilot.remove_seats([github_login])

    slack_id = github_username_to_slack_user_id(github_login)
    if not slack_id:
        print(f"No Slack user found for GitHub user {github_login}")
        return

    report(github_login, "notifying user")

    # Load a blocks-based interactive message template
    # from a JSON file and post it to the user's Slack.
    blocks = json.loads(Path("message.json").read_text())["blocks"]
    slack.chat_postMessage(channel=slack_id, blocks=blocks)

    # Subscribe to Slack interaction events, waiting for the user's response.
    filter = f"event_type == 'interaction' && data.user.id == '{slack_id}'"
    subscription = autokitteh.subscribe("slack_conn", filter)

    # Retrieve the value from the user's response in the Slack event.
    value = autokitteh.next_event(subscription)["actions"][0]["value"]

    # The user's response either confirms the action or reinstates the seat.
    match value:
        case "ok":
            report(github_login, "ok")
            msg = "Okey dokey!"
        case "reinstate":
            report(github_login, "reinstate")
            copilot.add_seats([github_login])
            msg = "You have been reinstated to the Copilot program."
        case _:
            report(github_login, f"weird response: {value}")
            msg = f"Response: `{value}` not recognized."

    slack.chat_postMessage(channel=slack_id, text=msg)


def report(github_login: str, msg: str) -> None:
    channel = os.getenv("SLACK_LOG_CHANNEL")
    if channel:
        slack.chat_postMessage(channel=channel, text=f"{github_login}: {msg}")



================================================
FILE: kittehub/github_copilot_seats/triggers.py
================================================
"""Manage scheduled tasks and Slack commands for idle seat management."""

from autokitteh.slack import slack_client

import seats


def on_schedule() -> None:
    for seat in seats.find_idle_seats(prune=True):
        print(seat)


def on_slack_slash_command(event) -> None:
    find_seats = True
    match event.data.text.lower():
        case "prune-idle-copilot-seats":
            prune = True
        case "find-idle-copilot-seats":
            prune = False
        case _:
            find_seats = False

    if find_seats:
        idle_seats = seats.find_idle_seats(prune=prune)
        action = "Pruned" if prune else "Found"
        msg = f"{action} {len(idle_seats)} idle seats for these users: "
        msg += ", ".join(_get_logins(idle_seats))
    else:
        msg = "Error: unrecognized command"

    slack_client("slack_conn").chat_postEphemeral(
        channel=event.data.channel_id, user=event.data.user_id, text=msg
    )


def _get_logins(idle_seats: list[dict[str, str]]) -> list[str]:
    return [seat["assignee_login"] for seat in idle_seats]



================================================
FILE: kittehub/github_copilot_seats/users.py
================================================
"""User-related helper functions across GitHub and Slack.

Based on: https://github.com/autokitteh/kittehub/blob/main/purrr/users.py
"""

from autokitteh.github import github_client
from autokitteh.slack import slack_client
from slack_sdk.errors import SlackApiError


github = github_client("github_conn")
slack = slack_client("slack_conn")


def github_username_to_slack_user_id(github_username: str) -> str:
    """Convert a GitHub username to a Slack user ID, or "" if not found.

    This function tries to match the email address first, and then
    falls back to matching the user's full name (case-insensitive).
    """
    user = github.get_user(github_username)

    # Special case: GitHub bots can't have Slack identities.
    if user.type == "Bot":
        return ""

    # Try to match by the email address first.
    if user.email:
        slack_user_id = _email_to_slack_user_id(user.email)
        if slack_user_id:
            return slack_user_id

    # Otherwise, try to match by the user's full name.
    github_name = (user.name or "").lower()
    if not github_name:
        return ""

    for user in _slack_users():
        profile = user.get("profile", {})
        real_name = profile.get("real_name", "").lower()
        normalized_name = profile.get("real_name_normalized", "").lower()
        if github_name in (real_name, normalized_name):
            return user.get("id", "")

    return ""


def _email_to_slack_user_id(email: str) -> str:
    """Convert an email address to a Slack user ID, or "" if not found."""
    try:
        resp = slack.users_lookupByEmail(email=email)
        return resp.get("user", {}).get("id", "")
    except SlackApiError:
        return ""


def _slack_users() -> list[dict]:
    """Return a list of all Slack users in the workspace."""
    users = []
    next_cursor = None
    while next_cursor != "":
        try:
            resp = slack.users_list(cursor=next_cursor, limit=100)
            users += resp.get("members", [])
            next_cursor = resp.get("response_metadata", {}).get("next_cursor", "")
        except SlackApiError:
            next_cursor = ""

    return users



================================================
FILE: kittehub/github_marketplace_to_slack/README.md
================================================
title: GitHub Marketplace to Slack
description: Forward GitHub Marketplace notifications to Slack
integrations: ["github", "http", "slack"]
categories: ["CRM"]



================================================
FILE: kittehub/github_marketplace_to_slack/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup
# of an AutoKitteh project that forwards GitHub Marketplace webhook
# notifications to a Slack channel.

version: v1

project:
  name: github_marketplace_to_slack

  vars:
    - name: GITHUB_WEBHOOK_SECRET
      secret: true
      value:
    - name: SLACK_CHANNEL_NAME_OR_ID
      value: github-marketplace

  connections:
    - name: slack_conn
      integration: slack

  triggers:
    - name: webhook_notification
      type: webhook
      event_type: post
      call: program.py:on_webhook_notification



================================================
FILE: kittehub/github_marketplace_to_slack/program.py
================================================
"""Forward GitHub Marketplace webhook notifications to a Slack channel.

GitHub API documentation:
- https://docs.github.com/en/apps/github-marketplace/listing-an-app-on-github-marketplace/configuring-a-webhook-to-notify-you-of-plan-changes
- https://docs.github.com/en/webhooks/webhook-events-and-payloads#marketplace_purchase
- https://docs.github.com/en/webhooks/webhook-events-and-payloads#ping
"""

import hashlib
import hmac
import json
import os

import autokitteh
from autokitteh.slack import slack_client


def on_webhook_notification(event):
    """Handle GitHub Marketplace webhook notifications.

    Args:
        event: Incoming HTTP request data.
    """
    headers = event.data.headers

    secret = os.getenv("GITHUB_WEBHOOK_SECRET", "")
    signature = headers.get("X-Hub-Signature-256", "")
    _verify_signature(event.data.body.bytes, secret, signature)

    # https://docs.github.com/en/webhooks/webhook-events-and-payloads#delivery-headers
    msg = f"*GitHub Marketplace event:* `{headers.get('X-Github-Event', '???')}`\n"
    msg += f"(Resource ID `{headers.get('X-Github-Hook-Installation-Target-Id')}`, "
    msg += f"webhook ID `{headers.get('X-Github-Hook-Id')}`, "
    msg += f"event ID `{headers.get('X-Github-Delivery')}`)\n"

    # https://docs.github.com/en/webhooks/webhook-events-and-payloads#marketplace_purchase
    # https://docs.github.com/en/webhooks/webhook-events-and-payloads#ping
    msg += f"```{json.dumps(event.data.body.json, indent=4)}```"

    channel = os.getenv("SLACK_CHANNEL_NAME_OR_ID", "")
    slack_client("slack_conn").chat_postMessage(channel=channel, text=msg)


@autokitteh.activity
def _verify_signature(payload: bytes, secret: str, signature: str):
    """Verify that the payload was sent from GitHub by validating its SHA-256 signature.

    Based on:
    https://docs.github.com/en/webhooks/using-webhooks/validating-webhook-deliveries

    Args:
        payload: Original request body to verify.
        secret: GitHub Marketplace webhook secret of the GitHub app.
        signature: HTTP header received from GitHub ("X-Hub-Signature-256").

    Raises:
        RuntimeError: If the signature is missing or doesn't match the expected value.
    """
    if not signature:
        raise RuntimeError("'X-Hub-Signature-256' HTTP header is missing!")

    hash = hmac.new(secret.encode("utf-8"), msg=payload, digestmod=hashlib.sha256)
    expected = "sha256=" + hash.hexdigest()
    if not hmac.compare_digest(expected, signature):
        raise RuntimeError("Request signatures didn't match!")



================================================
FILE: kittehub/google_cal_to_asana/README.md
================================================
title: Google Calendar To Asana
description: Creates Asana tasks based on Google Calendar events
integrations: ["calendar", "asana"]
categories: ["Productivity"]



================================================
FILE: kittehub/google_cal_to_asana/autokitteh.yaml
================================================
# This YAML file defines a declarative manifest for an AutoKitteh project that
# creates Asana tasks from Google Calendar events.

version: v1

project:
  name: google_cal_to_asana

  vars:
    - name: ASANA_PROJECT_GID
      value:

  connections:
    - name: asana_conn
      integration: asana
    - name: google_conn
      integration: googlecalendar

  triggers:
    - name: gcal_event_created
      connection: google_conn
      event_type: event_created
      call: program.py:on_calendar_event_created



================================================
FILE: kittehub/google_cal_to_asana/program.py
================================================
"""Create a new Asana task when a new event is created in Google Calendar."""

import os

import asana
from asana.rest import ApiException
from autokitteh.asana import asana_client


ASANA_PROJECT_GID = os.getenv("ASANA_PROJECT_GID")

api_client = asana_client("asana_conn")
tasks_api_instance = asana.TasksApi(api_client)


def on_calendar_event_created(event):
    """This is the workflow entry point."""
    # Extract relevant information from the Google Calendar event.
    task_name = event.data.get("summary", "New Task")
    due_date = event.data.get("start", {}).get("date_time")
    description = event.data.get("description", "")

    create_asana_task(task_name, due_date, description)


def create_asana_task(task_name, due_date, description):
    """Create a new task in Asana.

    See:
        https://github.com/Asana/python-asana/blob/v5.0.10/docs/TasksApi.md#create_task
    """
    body = {
        "data": {
            "name": task_name,
            "projects": [ASANA_PROJECT_GID],  # More than one project can be added.
            "due_on": due_date,
            "notes": description,
        }
    }

    opts = {"opt_fields": "name,assignee.name,due_on,created_at,projects.name,notes"}

    try:
        task = tasks_api_instance.create_task(body, opts)
        print(task)
    except ApiException as e:
        print(f"Exception when calling TasksApi->create_task: {e}")



================================================
FILE: kittehub/google_forms_to_jira/README.md
================================================
title: Create Jira ticket from Google form
description: Create and update Jira tickets automatically from Google Forms responses
integrations: ["forms", "jira"]
categories: ["DevOps"]



================================================
FILE: kittehub/google_forms_to_jira/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup of an
# AutoKitteh project that creates Jira issues based on Google Forms responses.

version: v1

project:
  name: google_forms_to_jira
  vars:
    - name: JIRA_PROJECT_KEY
      value:

  connections:
    - name: forms_conn
      integration: googleforms
    - name: jira_conn
      integration: jira

  triggers:
    - name: google_forms_response
      connection: forms_conn
      event_type: responses
      call: program.py:on_form_response



================================================
FILE: kittehub/google_forms_to_jira/program.py
================================================
"""Create Jira issues based on Google Forms responses.

Atlassian Jira API documentation:
- https://docs.autokitteh.com/integrations/atlassian/jira/python

Google Forms API documentation:
- https://docs.autokitteh.com/integrations/google/forms/events
"""

import os

from autokitteh import google
from autokitteh.atlassian import jira_client


JIRA_PROJECT_KEY = os.getenv("JIRA_PROJECT_KEY")

jira = jira_client("jira_conn")


def on_form_response(event):
    print("Form response submitted:", event.data)
    response_id = event.data.response.response_id

    forms = google.google_forms_client("forms_conn").forms()
    questions = forms.get(formId=event.data.form_id).execute().get("items", [])

    answers = _summarize_form_response(event.data.response.answers, questions)

    # Check if a Jira issue already exists for this response (i.e. response edited).
    query = f"project = {JIRA_PROJECT_KEY} AND description ~ {response_id}"
    issues = jira.jql(query + " ORDER BY created DESC")
    if issues.get("total", 0) == 0:
        _create_jira_issue(answers, response_id)
    else:
        _update_jira_issue(issues["issues"][0], answers, response_id)


def _summarize_form_response(answers, questions):
    """Extract answers from response, and match with form questions."""
    summary = []
    for i, question in enumerate(questions, start=1):
        question_id = question["questionItem"]["question"]["questionId"]
        title = question.get("title", "Untitled question")

        if question_id not in answers:
            summary.append(f"{i}. {title}:\nNot answered")
        else:
            answer = answers[question_id]["text_answers"]["answers"][0]["value"]
            summary.append(f"{i}. {title}:\n{answer}")

    return summary


def _create_jira_issue(answers, response_id):
    fields = {
        "project": {"key": JIRA_PROJECT_KEY},
        "issuetype": {"name": "Task"},
        "summary": "Response to Google Form",
        "description": "\n\n".join(answers) + f"\n\n(Response ID: {response_id})",
    }
    issue = jira.create_issue(fields=fields)
    print("Created Jira issue:", issue["key"])


def _update_jira_issue(issue, answers, response_id):
    description = "\n\n".join(answers) + f"\n\n(Response ID: {response_id})"
    jira.update_issue_field(issue["key"], fields={"description": description})
    print("Updated Jira issue:", issue["key"])



================================================
FILE: kittehub/hackernews/README.md
================================================
title: Hacker News alerts in Slack
description: Track Hacker News articles by topic and send updates to Slack
integrations: ["slack"]
categories: ["Productivity"]



================================================
FILE: kittehub/hackernews/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup of
# an AutoKitteh project that monitors Hacker News for a specific topic.

version: v1

project:
  name: hackernews_alert

  vars:
    - name: POLLING_INTERVAL_SECS
      value: 120

  connections:
    - name: slack_connection
      integration: slack

  triggers:
    - name: slack_slash_command
      connection: slack_connection
      event_type: app_mention
      call: program.py:on_slack_command



================================================
FILE: kittehub/hackernews/program.py
================================================
"""Monitor Hacker News for new articles on a specific topic, post updates to Slack."""

import os
import time
import urllib.parse

from autokitteh.slack import slack_client
import requests


API_URL = "http://hn.algolia.com/api/v1/search_by_date?tags=story&page=0&query="
POLLING_INTERVAL_SECS = int(os.getenv("POLLING_INTERVAL_SECS", "120"))

slack = slack_client("slack_connection")


def on_slack_command(event):
    """Workflow's entry-point.

    Extracts a topic from a Slack command, monitors for new articles,
    and posts updates to the same Slack channel.
    """
    topic = event.data.text.split(" ", 1)[-1].strip()
    slack.chat_postMessage(
        channel=event.data.channel,
        text=f"Waiting for new articles on the topic: `{topic}`.",
    )
    current_articles = set()
    fetch_articles(topic, current_articles)

    # NOTE: For low-traffic topics, it might take a while for new articles to
    # be published, so users may experience delays in receiving notifications.
    while True:
        all_articles = set(current_articles)
        fetch_articles(topic, all_articles)
        new_articles = all_articles - current_articles

        for article in new_articles:
            _, title, url = article
            slack_message = f"Title: {title}, URL: {url if url else 'No URL'}"
            slack.chat_postMessage(channel=event.data.channel, text=slack_message)
        current_articles.update(new_articles)

        time.sleep(POLLING_INTERVAL_SECS)


def fetch_articles(topic, all_articles):
    encoded_query = urllib.parse.quote(topic)
    full_url = f"{API_URL}{encoded_query}"
    hits = requests.get(full_url, timeout=10).json().get("hits", [])

    # Extract some of the article fields from the API response.
    for article in hits:
        object_id = article["objectID"]
        title = article["title"]
        url = article.get("url")
        all_articles.add((object_id, title, url))



================================================
FILE: kittehub/invoice_processing/README.md
================================================
title: Invoice processing system
description: Process emails for invoices, extract data, and generate reports
integrations: ["gmail", "chatgpt"]
categories: ["AI", "Productivity"]



================================================
FILE: kittehub/invoice_processing/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup
# of an AutoKitteh project that processes emails to detect invoices
# and generate structured reports.

version: v1

project:
  name: invoice_project

  vars:
    - name: POLLING_INTERVAL_MINUTES
      value: 30
    - name: START_DATE
      value:

  connections:
    - name: gmail_conn
      integration: gmail
    - name: openai_conn
      integration: chatgpt

  triggers:
    - name: process_invoices
      type: webhook
      call: program.py:main
    - name: send_mail
      type: webhook



================================================
FILE: kittehub/invoice_processing/openAI_handling.py
================================================
"""Functions to create AI files, create threads, and send requests to the OpenAI API."""

import base64
import binascii
import io
import time

import autokitteh
from autokitteh.openai import openai_client
import requests


chatgpt = openai_client("openai_conn")


def create_ai_file(attachment, vector_store_id):
    """Create an AI file from an attachment for OpenAI processing."""
    try:
        if attachment["data"].startswith("data:"):
            # Extract base64 data after the comma.
            _, data = attachment["data"].split(",", 1)
            file_data = base64.b64decode(data)
        else:
            # Handle regular base64 data.
            file_data = base64.b64decode(attachment["data"])

        file_stream = io.BytesIO(file_data)
        file_stream.name = attachment["filename"]

        file_stream.seek(0)

        # Create file for assistant.
        message_file = chatgpt.files.create(file=file_stream, purpose="assistants")
        file_stream.close()
        return message_file

    except ValueError as e:
        print(f"Error creating AI file: {str(e)}")
        return None


def create_thread(content, attachments, assistant, response_schema):
    """Create an OpenAI thread, run the assistant, and get the response."""
    try:
        # Create thread with user message.
        thread = chatgpt.beta.threads.create(
            messages=[
                {
                    "role": "user",
                    "content": content,
                    "attachments": attachments,
                }
            ]
        )

        # Run the assistant on the thread.
        run = chatgpt.beta.threads.runs.create(
            thread_id=thread.id,
            assistant_id=assistant.id,
            response_format=response_schema,
        )

        # Poll for completion.
        while True:
            run_status = chatgpt.beta.threads.runs.retrieve(
                thread_id=thread.id, run_id=run.id
            )
            if run_status.status == "completed":
                break
            elif run_status.status in ["failed", "cancelled", "expired"]:
                print(f"Run failed - {run_status.status}")
                return None

            time.sleep(5)  # Reduced polling interval.

        # Get the assistant's response.
        ai_messages = chatgpt.beta.threads.messages.list(thread_id=thread.id)

        assistant_message = next(
            (msg for msg in ai_messages.data if msg.role == "assistant"), None
        )

        if assistant_message and assistant_message.content:
            return assistant_message.content[0].text.value

    except requests.exceptions.RequestException as e:
        print(f"Network error: {str(e)}")

    return None


@autokitteh.activity
def send_ai_request(
    message_body, message_attachments, message_images, ai_request, response_schema
):
    """Send a request to the OpenAI API with message content and attachments"""
    # Early return if no content to analyze.
    if not message_body and not message_attachments and not message_images:
        print("No content to analyze")
        return False

    # Create a temporary file from the message body.
    temp_file_path = f"message_{int(time.time())}.txt"
    temp_file = {
        "filename": temp_file_path,
        "data": base64.b64encode(message_body.encode("utf-8")).decode("utf-8"),
    }

    # Create assistant with explicit model version.
    assistant = chatgpt.beta.assistants.create(
        name="Document Analyzer",
        instructions=ai_request,
        model="gpt-4o",  # Use latest model.
        tools=[{"type": "file_search"}],
    )

    # Create vector store for file search.
    vector_store = chatgpt.vector_stores.create(name="Invoice Analysis")

    # Process all files (message body and attachments).
    messages = []

    temp_ai_file = create_ai_file(temp_file, vector_store.id)
    if temp_ai_file:
        messages.append(temp_ai_file)

    for attachment in message_attachments:
        ai_file = create_ai_file(attachment, vector_store.id)
        if ai_file:
            messages.append(ai_file)

    attachments = [
        {"file_id": file.id, "tools": [{"type": "file_search"}]} for file in messages
    ]

    # Prepare content array with instructions.
    content = [{"type": "text", "text": ai_request}]

    # Handle image processing if present.
    if message_images and len(message_images) > 0:
        try:
            image_data = message_images[0]["data"]
            if image_data.startswith("data:"):
                _, base64_data = image_data.split(",", 1)
                image_bytes = base64.b64decode(base64_data)

                image_stream = io.BytesIO(image_bytes)
                image_stream.name = "image.png"

                file = chatgpt.files.create(file=image_stream, purpose="vision")

                content.append(
                    {"type": "image_file", "image_file": {"file_id": file.id}}
                )
                print(f"Image added with file ID: {file.id}")
        except binascii.Error as e:
            print(f"Base64 decoding error: {str(e)}")
        except OSError as e:
            print(f"IO error processing image: {str(e)}")

    # Create thread and get response.
    result = create_thread(content, attachments, assistant, response_schema)
    return result



================================================
FILE: kittehub/invoice_processing/process_gmails.py
================================================
"""Processes Gmail messages to identify and extract invoice details."""

import base64
import json
import time
import traceback

from autokitteh.google import gmail_client

import openAI_handling
import scan_gmails
import schemas


gmail = gmail_client("gmail_conn").users()


def is_message_invoice(message_body, message_attachments, message_images):
    """Determine if a message contains an invoice."""
    print("Checking if message is an invoice...")

    # Use specific instructions that clearly request a simple True/False response.
    instructions = """
    You are a helper that determines if attached files are an invoice or receipt.
    IMPORTANT: Analyze all files and respond with ONLY 'True' or 'False'.
    - If ANY file is an invoice or receipt, respond with 'True'
    - Otherwise, respond with 'False'
    Do not include any explanations, just True or False.
    """

    # Get the raw text response from AI.
    is_invoice_response = openAI_handling.send_ai_request(
        message_body,
        message_attachments,
        message_images,
        instructions,
        schemas.AI_BOOLEAN_SCHEMA,
    )

    # Handle response as text.
    if not is_invoice_response:
        print("No response received from AI")
        return False

    # Parse text response - accept variations of true/yes.
    cleaned_response = is_invoice_response.strip().lower()

    # Check for positive responses.
    true_indicators = ["true", "yes", "1", "correct", "invoice", "receipt"]

    # Return True if any indicator is found in the response.
    for indicator in true_indicators:
        if indicator in cleaned_response:
            print(f"Found '{indicator}' in response - considering this an invoice")
            return True

    return False


def try_parse_json(response):
    """Attempt to parse JSON response with required invoice fields."""
    try:
        parsed_json = json.loads(response)
    except json.JSONDecodeError:
        parsed_json = {}

    required_keys = ["companyName", "date", "amount", "invoiceId"]
    if not all(key in parsed_json for key in required_keys):
        parsed_json = {}

    return parsed_json


def parse_invoice_to_json(message_body, message_attachments, message_images):
    """Extract invoice details into structured JSON."""
    max_retries = 3

    instructions = """
    Please extract information from the uploaded invoice files (PDF or images).
    For each invoice, extract:
    1. Company name (who issued the invoice)
    2. Invoice date
    3. Total amount (with currency)
    4. Invoice ID or number
    Return ONLY a JSON object with these fields:
    {
      "companyName": "Example Corp",
      "date": "2023-01-15",
      "amount": "$123.45",
      "invoiceId": "INV-12345"
    }
    """

    for attempt in range(max_retries):
        json_invoice = openAI_handling.send_ai_request(
            message_body,
            message_attachments,
            message_images,
            instructions,
            schemas.AI_INVOICE_JSON_SCHEMA,
        )

        if json_invoice:
            parsed_json = try_parse_json(json_invoice)
            if parsed_json:
                return parsed_json

        if attempt < max_retries - 1:
            print(f"Retrying invoice parsing... ({attempt + 1}/{max_retries})")
            time.sleep(2)  # Brief pause before retry.

    return None


def handle_scan(ts):
    """Scan emails since timestamp ts and process for invoices."""
    invoices = []

    try:
        messages = scan_gmails.scan_gmail_messages(ts)

        for idx, msg in enumerate(messages):
            print(f"Processing message {idx + 1}/{len(messages)}")

            # Rate limiting.
            time.sleep(5)

            # Check if message is an invoice.
            is_email_invoice = is_message_invoice(
                msg["body"], msg["attachments"], msg["images"]
            )

            if is_email_invoice:
                # Parse invoice details.
                message_json_parsed = parse_invoice_to_json(
                    msg["body"], msg["attachments"], msg["images"]
                )

                if message_json_parsed:
                    invoices.append(message_json_parsed)
            else:
                print(f"Message {msg['id']} is not an invoice")

    except json.JSONDecodeError as e:
        print(f"Error in handle_scan: {e}")
        traceback.print_exc()

    return invoices


def send_invoices(invoices):
    """Send an email report with processed invoices."""
    try:
        profile = gmail.getProfile(userId="me").execute()

        if not invoices:
            mail_body = "No invoices found for this period."
        else:
            mail_body = json.dumps(invoices, indent=4)

        msg = f"""From: {profile["emailAddress"]}
To: {profile["emailAddress"]}
Subject: Invoice Processing Report

{mail_body}"""

        # Format message for Gmail API
        msg = msg.replace("\n", "\r\n")
        msg = base64.urlsafe_b64encode(msg.encode()).decode()

        gmail.messages().send(userId="me", body={"raw": msg}).execute()
        print("Invoice report sent successfully!")

    except json.JSONDecodeError as e:
        print(f"Unexpected error sending invoice report: {str(e)}")



================================================
FILE: kittehub/invoice_processing/program.py
================================================
"""Invoice processing system module."""

from datetime import datetime, UTC
import os
import time

import autokitteh

import process_gmails


def main(event):
    """Main entry point for the invoice processing system"""
    invoices = []

    polling_interval = int(os.getenv("POLLING_INTERVAL_MINUTES", "60")) * 60

    start_date = os.getenv("START_DATE")
    if start_date is None:
        start_date = datetime.now(UTC).replace(day=1)
        start_date = start_date.strftime("%Y-%m-%d")

    last_check_time = int(time.mktime(time.strptime(start_date, "%Y-%m-%d")))

    # Subscribe to send_mail events.
    send_mail_webhook = autokitteh.subscribe("send_mail", "true")

    # Initial scan.
    new_invoices = process_gmails.handle_scan(last_check_time)
    invoices.extend(new_invoices)
    last_check_time = int(time.time())

    while True:
        # Wait for send_mail event or timeout.
        send_mail_req = autokitteh.next_event(
            send_mail_webhook, timeout=polling_interval
        )

        if send_mail_req:
            # Send invoice report on demand.
            print("Received send_mail event - sending invoice report")
            process_gmails.send_invoices(invoices)
        else:
            # Check for new invoices.
            new_invoices = process_gmails.handle_scan(last_check_time)

            if new_invoices:
                print(f"Found {len(new_invoices)} new invoices")
                invoices.extend(new_invoices)
            else:
                print("No new invoices found")

            last_check_time = int(time.time())



================================================
FILE: kittehub/invoice_processing/scan_gmails.py
================================================
"""Scan Gmail messages and extract content.

Including subject, body, PDF attachments, and image attachments.
"""

import base64
from datetime import datetime, UTC

from autokitteh.google import gmail_client


IMAGE_MIME_TYPES = [
    "image/bmp",  # Not sure if works, need to check.
    "image/gif",  # Not sure if works, need to check.
    "image/jpeg",  # Not sure if works, need to check.
    "image/png",
    "image/tiff",  # Not sure if works, need to check.
    "image/webp",  # Not sure if works, need to check.
]

TEXT_MIME_TYPES = [
    "text/html",
    "text/plain",
]

gmail = gmail_client("gmail_conn").users()


def is_image(part):
    recognized_type = part.get("mimeType") in IMAGE_MIME_TYPES
    return recognized_type and "attachmentId" not in part.get("body", {})


def is_pdf(part):
    recognized_type = part.get("mimeType") == "application/pdf"
    return recognized_type and "attachmentId" in part.get("body", {})


def is_text(part):
    recognized_type = part.get("mimeType") in TEXT_MIME_TYPES
    return recognized_type and "data" in part.get("body", {})


def get_mail_content(message):
    subject = get_subject(message)
    body = get_body(message)
    pdf_files = get_pdf_attachments(message)
    images = get_image_attachments(message)
    return subject, body, pdf_files, images


def get_subject(message):
    """Extract subject from message headers."""
    headers = message.get("payload", {}).get("headers", [])
    return next(
        (header["value"] for header in headers if header["name"].lower() == "subject"),
        "No Subject",
    )


def get_body(message):
    payload = message.get("payload", {})

    for part in payload.get("parts", []):
        if part["mimeType"] == "multipart/alternative":
            for sub_part in part.get("parts", []):
                if is_text(sub_part):
                    return process_body_part(sub_part)
        elif is_text(part):
            return process_body_part(part)

    return "No body content"


def process_body_part(part):
    data = part["body"]["data"]
    return base64.urlsafe_b64decode(data).decode("utf-8")


def get_pdf_attachments(message):
    """Extract PDF attachments from message."""
    pdf_files = []

    payload = message.get("payload", {})
    for part in [part for part in payload.get("parts", []) if is_pdf(part)]:
        client = gmail.messages().attachments()
        attachment = client.get(
            userId="me", messageId=message["id"], id=part["body"]["attachmentId"]
        ).execute()

        if "data" not in attachment:
            continue

        pdf_files.append(
            {
                "filename": part.get("filename", "unnamed.pdf"),
                "data": base64url_to_base64(attachment),
            }
        )

    return pdf_files


def base64url_to_base64(attachment):
    data = base64.urlsafe_b64decode(attachment["data"])
    return base64.b64encode(data).decode("utf-8")


def get_image_attachments(message):
    """Extract images from message, including from nested multipart messages."""
    image_files = []
    payload = message.get("payload", {})

    def process_part(part):
        if part.get("mimeType") == "multipart/alternative":
            for sub_part in part.get("parts", []):
                process_part(sub_part)

        elif is_image(part):
            try:
                client = gmail.messages().attachments()
                attachment = client.get(
                    userId="me",
                    messageId=message["id"],
                    id=part["body"]["attachmentId"],
                ).execute()

                if attachment.get("data"):
                    mime_type = part.get("mimeType", "image/png")
                    encoded_data = base64url_to_base64(attachment)

                    # Create proper image URL format.
                    data_url = f"data:{mime_type};base64,{encoded_data}"

                    image_files.append({"data": data_url})

            except (KeyError, TypeError) as e:
                print(f"Error processing image attachment: {str(e)}")
                return  # Use return instead of continue.

    # Process all parts.
    if "parts" in payload:
        for part in payload["parts"]:
            process_part(part)
    elif is_image(payload):
        process_part(payload)

    return image_files


def scan_gmail_messages(ts):
    """Scans Gmail for messages based on a timestamp (ts)."""
    date_from = datetime.fromtimestamp(ts, tz=UTC).strftime("%Y/%m/%d")
    messages = gmail.messages().list(userId="me", q=f"after:{date_from}").execute()
    emails = []

    for msg in messages.get("messages", []):
        message = gmail.messages().get(userId="me", id=msg["id"]).execute()
        subject, body, pdf_files, images = get_mail_content(message)

        attachments = []
        for pdf in pdf_files:
            attachment = {"filename": pdf["filename"], "data": pdf["data"]}
            attachments.append(attachment)

        mail_data = {
            "id": message["id"],
            "subject": subject,
            "body": body,
            "images": images or [],
            "attachments": attachments,
        }
        emails.append(mail_data)

    return emails



================================================
FILE: kittehub/invoice_processing/schemas.py
================================================
"""This module contains JSON schemas for invoice parsing and detection."""

# Schema for invoice parsing.
AI_INVOICE_JSON_SCHEMA = {
    "type": "json_schema",
    "json_schema": {
        "strict": True,
        "name": "parsed_invoice",
        "schema": {
            "type": "object",
            "properties": {
                "companyName": {"type": "string", "nullable": True},
                "date": {"type": "string", "nullable": True},
                "amount": {"type": "string", "nullable": True},
                "invoiceId": {"type": "string", "nullable": True},
            },
            "required": ["companyName", "date", "amount", "invoiceId"],
            "additionalProperties": False,
        },
    },
}

# Schema for invoice detection (boolean response).
AI_BOOLEAN_SCHEMA = {"type": "text"}



================================================
FILE: kittehub/jenkins_release/README.md
================================================
title: GitHub and Jenkins workflow
description: This ensures that when a commit is pushed to main, a specific Jenkins build is completed.
integrations: ["github"]
categories: ["DevOps"]



================================================
FILE: kittehub/jenkins_release/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup of
# an AutoKitteh project that monitors comments on GitHub issues.

version: v1

project:
  name: jenkins_release

  vars:
    - name: JENKINS_URL
      value:
    - name: JENKINS_USER
      value:
    - name: JENKINS_PASSWORD
      secret: true
      value:
    - name: JOB_NAME
      value:

  connections:
    - name: github_conn
      integration: github

  triggers:
    - name: on_github_push
      event_type: push
      connection: github_conn
      call: program.py:on_github_push



================================================
FILE: kittehub/jenkins_release/program.py
================================================
"""Trigger and track Jenkins builds based on GitHub push events."""

from os import getenv

from jenkins import Jenkins
from jenkins import JenkinsException
from tenacity import retry
from tenacity import retry_if_exception
from tenacity import retry_if_result
from tenacity import wait_fixed


JOB_NAME = getenv("JOB_NAME")

jenkins = Jenkins(
    getenv("JENKINS_URL"),
    username=getenv("JENKINS_USER"),
    password=getenv("JENKINS_PASSWORD"),
)


def on_github_push(event):
    if not event.data.get("ref") == "refs/heads/main":
        print("not main")
        return

    _must_build(JOB_NAME, event.data.get("after"))


# Retry until build is successful.
@retry(
    retry=(
        retry_if_result(lambda r: r != "SUCCESS") | retry_if_exception(JenkinsException)
    )
)
def _must_build(job_name, sha):
    build_number = jenkins.get_job_info(job_name)["nextBuildNumber"]

    build_id = jenkins.build_job(job_name, {"sha": sha})

    print(f"job {job_name}(sha={sha}) started: build id {build_id}, #{build_number}")

    return _track(job_name, build_number)


# Retry until there is a result.
@retry(
    wait=wait_fixed(3),
    retry=(retry_if_result(lambda r: not r) | retry_if_exception(JenkinsException)),
)
def _track(job_name, build_number):
    bi = jenkins.get_build_info(job_name, build_number)
    if bi.get("building"):
        print(f"build {build_number} is building")
        return ""

    result = bi.get("result")

    print(f"build {build_number} finished with result {result}")

    return result



================================================
FILE: kittehub/jira_google_calendar/assignee_from_schedule/README.md
================================================
title: Jira assignee from Google Calendar
description: Set assignee in Jira ticket to the person currently on-call
integrations: ["jira", "calendar"]
categories: ["DevOps"]



================================================
FILE: kittehub/jira_google_calendar/assignee_from_schedule/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup of
# an AutoKitteh project that sets the assignee of new Atlassian Jira
# issues based on an on-call rotation in a shared Google Calendar.

version: v1

project:
  name: jira_assignee_from_google_calendar_schedule

  vars:
    - name: SHARED_CALENDAR_ID
      value: primary

  connections:
    - name: google_calendar_connection
      integration: googlecalendar
    - name: jira_connection
      integration: jira

  triggers:
    - name: jira_issue_created
      connection: jira_connection
      event_type: issue_created
      filter: data.issue.fields.project.key == "JIRA_PROJECT_KEY"
      call: program.py:on_jira_issue_created



================================================
FILE: kittehub/jira_google_calendar/assignee_from_schedule/program.py
================================================
"""This program assigns Atlassian Jira issues based on a shared Google Calendar.

The shared Google Calendar defines a 27/4 on-call rotation.
How to create it: https://support.google.com/calendar/answer/37095

This program assumes that the calendar entries have these fields:
- Summary: the on-call person's human-readable name
- Description: their Atlassian account ID
"""

from datetime import datetime, timedelta, UTC
import os

import autokitteh
from autokitteh.atlassian import jira_client
from autokitteh.google import google_calendar_client


def on_jira_issue_created(event):
    """Workflow's entry-point."""
    name, account_id = _get_current_oncall()
    update = {"assignee": {"accountId": account_id}}

    jira = jira_client("jira_connection")
    jira.update_issue_field(event.data.issue.key, update, notify_users=True)

    print(f"Assigned {event.data.issue.key} to {name}")


@autokitteh.activity
def _get_current_oncall():
    """Return the name and Atlassian account ID of the current on-call."""
    gcal = google_calendar_client("google_calendar_connection").events()
    now = datetime.now(UTC)
    in_a_minute = now + timedelta(minutes=1)

    result = gcal.list(
        calendarId=os.getenv("SHARED_CALENDAR_ID"),
        timeMin=now.isoformat(),  # Request all currently-effective events.
        timeMax=in_a_minute.isoformat(),
        orderBy="updated",  # Use the most-recently updated one.
    ).execute()["items"][-1]

    # Google Calendar may add whitespaces - strip them.
    return result["summary"].strip(), result["description"].strip()



================================================
FILE: kittehub/jira_google_calendar/deadline_to_event/README.md
================================================
title: Create calendar due date event for Jira ticket
description: When a new Jira issue is created, the workflow automatically generates a Google Calendar event with a deadline
integrations: ["calendar", "jira"]
categories: ["DevOps"]



================================================
FILE: kittehub/jira_google_calendar/deadline_to_event/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup
# of an AutoKitteh project that creates events in Google Calendar
# when Atlassian Jira issues are created in a specific project.

version: v1

project:
  name: jira_deadline_to_google_calendar_event

  connections:
    - name: jira_connection
      integration: jira
    - name: google_calendar_connection
      integration: googlecalendar

  triggers:
    - name: jira_issue_created
      connection: jira_connection
      event_type: issue_created
      filter: data.issue.fields.project.key == "JIRA_PROJECT_KEY"
      call: program.py:on_jira_issue_created



================================================
FILE: kittehub/jira_google_calendar/deadline_to_event/program.py
================================================
"""This program receives Jira events and creates Google Calendar events.

Scenario:
    Initiating a procedure that requires collaboration and coordination,
    e.g. scheduling a consult with another team, or planning a joint review.

Workflow:
    The user creates a new Jira ticket for the discussion. AutoKitteh
    automatically generates a Google Calendar event with a deadline for
    the completion, to ensure that the review happens as planned.
"""

import autokitteh
from autokitteh import atlassian
from autokitteh.google import google_calendar_client


def on_jira_issue_created(event):
    """Workflow's entry-point."""
    _create_calendar_event(event.data.issue.fields, event.data.issue.key)


@autokitteh.activity
def _create_calendar_event(issue, key):
    url = atlassian.get_base_url("jira_connection")
    link = f"Link to Jira issue: {url}/browse/{key}\n\n"

    event = {
        "summary": issue.summary,
        "description": link + issue.description,
        "start": {"date": issue.duedate},
        "end": {"date": issue.duedate},
        "reminders": {"useDefault": True},
        "attendees": [
            {"email": "auto@example.com"},
            {"email": "kitteh@example.com"},
        ],
    }

    gcal = google_calendar_client("google_calendar_connection").events()
    event = gcal.insert(calendarId="primary", body=event).execute()

    print("Google Cloud event created: " + event.get("htmlLink"))



================================================
FILE: kittehub/quickstart/README.md
================================================
title: Quickstart
description: Sample for quickstart
integrations: ["http"]
categories: ["Samples"]



================================================
FILE: kittehub/quickstart/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes
# the minimal setup of an AutoKitteh project.

version: v1

project:
  name: quickstart

  triggers:
    - name: quickstart_webhook
      type: webhook
      event_type: get
      call: program.py:quickstart



================================================
FILE: kittehub/quickstart/program.py
================================================
"""Handler for manual runs with a simple loop."""

import time


SLEEP_SECONDS = 1
ITERATIONS = 5


def quickstart(_):
    for i in range(ITERATIONS):
        print(f"Loop iteration: {i + 1} of {ITERATIONS}")
        time.sleep(SLEEP_SECONDS)



================================================
FILE: kittehub/reliability/aws_health_monitor/README.md
================================================
title: AWS Health monitor
description: Announce AWS Health events in Slack channels, based on resource ownership data in a Google Sheet
integrations: ["aws", "slack", "sheets"]
categories: ["Reliability"]



================================================
FILE: kittehub/reliability/aws_health_monitor/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup
# of an AutoKitteh project that announces AWS Health events in Slack
# channels, based on resource ownership data in a Google Sheet.

version: v1

project:
  name: aws_health_monitor

  vars:
    - name: GOOGLE_SHEET_URL
      value: https://docs.google.com/spreadsheets/d/1PalmLwSZOPW9k668_jU-wFI5xCj88a4mDfNUtJAupMQ/
    - name: TRIGGER_INTERVAL
      value: 1m

  connections:
    - name: aws_conn
      integration: aws
    - name: sheets_conn
      integration: googlesheets
    - name: slack_conn
      integration: slack

  triggers:
    - name: every_minute
      schedule: "@every 1m"
      call: program.py:on_schedule



================================================
FILE: kittehub/reliability/aws_health_monitor/program.py
================================================
"""Announce AWS Health events in Slack, based on resource ownership in a Google Sheet.

API documentation:
- https://docs.aws.amazon.com/health/
- https://aws.amazon.com/blogs/mt/tag/aws-health-api/

See the configuration and deployment instructions in the README.md file.
"""

from datetime import datetime, timedelta, UTC
import json
import os

import autokitteh
from autokitteh.aws import boto3_client
from autokitteh.google import google_id, google_sheets_client
from autokitteh.slack import slack_client
from hubspot.crm.contacts.exceptions import ApiException


OWNERSHIP_DATA = os.getenv("GOOGLE_SHEET_URL", "")

slack = slack_client("slack_conn")


def on_schedule(_):
    """Workflow's entry-point, triggered at the beginning of every minute."""
    slack_channels = _read_google_sheet()
    events = _aws_health_events()

    if not events:
        print("No AWS Health events found.")
        return

    events_by_arn = {event["arn"]: event for event in events}
    for entity in _affected_aws_entities(events):
        project = entity.get("tags", {}).get("project")
        if not project:
            print(f"Error: AWS entity without project tag: {entity}")
            continue

        channel = slack_channels.get(project)
        affecting_events = [events_by_arn[arn] for arn in entity["eventArns"]]
        _post_slack_message(project, channel, entity, affecting_events)


@autokitteh.activity
def _read_google_sheet() -> dict[str, str]:
    """Read mapping of project tags to Slack channels from Google Sheet."""
    sheets = google_sheets_client("google_sheets_conn").spreadsheets().values()
    rows = sheets.get(spreadsheetId=google_id(OWNERSHIP_DATA), range="A:B").execute()
    return {row[0].strip(): row[1].strip() for row in rows.get("values", [])}


@autokitteh.activity
def _aws_health_events() -> list[dict]:
    """List all recent AWS Health events.

    This function currently fetches events for a single AWS account:
    https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/health/client/describe_events.html

    With a bit more code, you can also fetch events for multiple ones:
    https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/health/client/describe_events_for_organization.html
    """
    # Remove the unit suffix ("m") and parse as an integer.
    interval = int((os.getenv("TRIGGER_INTERVAL", "1m"))[:-1])
    try:
        end_time = datetime.now(UTC).replace(second=0, microsecond=0)
        start_time = end_time - timedelta(minutes=interval)
        filter = {"lastUpdatedTimes": [{"from": start_time, "to": end_time}]}

        aws = boto3_client("aws_conn", "health")
        resp = aws.describe_events(filter=filter)
        events = resp.get("events", [])

        next_token = resp.get("nextToken")
        while next_token:
            resp = aws.describe_events(filter=filter, nextToken=next_token)
            events += resp.get("events", [])
            next_token = resp.get("nextToken")

        return events

    except ApiException as e:
        print(f"Boto3 error: {e}")
        return []


@autokitteh.activity
def _affected_aws_entities(events: list[dict]) -> list[dict]:
    """List all AWS entities affected by the given AWS Health events.

    API reference:
    https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/health/client/describe_affected_entities.html
    """
    try:
        aws = boto3_client("aws_conn", "health")
        arns = [event["arn"] for event in events]

        filter = {"eventArns": arns}
        # Possible alternative: describe_affected_entities_for_organization.
        resp = aws.describe_affected_entities(filter=filter)
        entities = resp.get("entities", [])

        next_token = resp.get("nextToken")
        while next_token:
            resp = aws.describe_affected_entities(filter=filter, nextToken=next_token)
            entities += resp.get("entities", [])
            next_token = resp.get("nextToken")

        return entities
    except ApiException as e:
        print(f"Boto3 error: {e}")
        return []


def _post_slack_message(
    channel: str, project: str, entity: dict, affecting_events: list[dict]
):
    if not channel:
        print(f"Error: project tag {project!r} not found in {OWNERSHIP_DATA}")

    text = f"This AWS resource:\n```\n{json.dumps(entity, indent=4)}\n```"
    text += "\nis affected by these AWS Health events:"
    for i, event in enumerate(affecting_events, 1):
        text += f"\n{i}.\n```\n{json.dumps(event, indent=4)}\n```"

    print(f"Posting in Slack channel: {channel}")
    slack.chat_postMessage(channel=channel, text=text)



================================================
FILE: kittehub/reliability/incidenter/README.md
================================================
title: Incident management automation
description: Connect separate systems to have seamless incident management
integrations: ["slack", "zoom", "height"]
categories: ["Reliability"]



================================================
FILE: kittehub/reliability/incidenter/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup
# of an AutoKitteh project that automates incident management.

version: v1

project:
  name: incidenter

  vars:
    - name: SLACK_CHANNEL_PREFIX
      value: test_incident_
    - name: HEIGHT_LIST_ID
      value:

  connections:
    - name: height_conn
      integration: height
    - name: slack_conn
      integration: slack
    - name: zoom_conn
      integration: zoom

  triggers:
    - name: slack_app_mention
      event_type: app_mention
      connection: slack
      call: program.py:on_slack_app_mention



================================================
FILE: kittehub/reliability/incidenter/height.py
================================================
"""Create Height tasks and add messages to them."""

import os
from urllib.parse import urljoin

from autokitteh.height import height_client


_ROOT_URL = "https://api.height.app/"

_HEIGHT_LIST_ID = os.getenv("HEIGHT_LIST_ID")

if not _HEIGHT_LIST_ID:
    raise ValueError("HEIGHT_LIST_ID project variable must be set")

height = height_client("height_conn")


def _post(path: str, data: dict) -> dict:
    resp = height.post(urljoin(_ROOT_URL, path), json=data)
    resp.raise_for_status()
    return resp.json()


def create_task(name: str, desc: str, status: str) -> dict:
    return _post(
        "tasks",
        {
            "type": "task",
            "name": name,
            "description": desc,
            "status": status,
            "listIds": [_HEIGHT_LIST_ID],
        },
    )


def add_task_message(task_id: str, msg: str) -> dict:
    return _post(
        "activities",
        {
            "type": "comment",
            "taskId": task_id,
            "message": msg,
        },
    )



================================================
FILE: kittehub/reliability/incidenter/program.py
================================================
"""Tracks Slack-reported incidents, integrating with Height and Zoom."""

import os
import re

from autokitteh import next_event, subscribe
from autokitteh.slack import normalize_channel_name
from autokitteh.slack import slack_client

import height
import zoom


_CHANNEL_PREFIX = os.getenv("SLACK_CHANNEL_PREFIX", "")

slack_client = slack_client("slack_conn")


def on_slack_app_mention(event):
    # Another option is to put this straight in the trigger definition as "filter".
    m = re.compile(r"^<.+?>\s*incident\s*(.*)").match(event.data.text)
    if not m:
        print("irrelevant")
        return

    incident = _start(event.data.user, event.data.channel, event.data.ts, m.group(1))

    _track(incident)


def _start(
    slack_user: str, trigger_channel_id: str, trigger_ts: str, title: str
) -> dict:
    task = height.create_task(title, "New incident created from slack", "inProgress")

    zoom_url = zoom.create_meeting(f"Incident: {title}")

    name = f"{_CHANNEL_PREFIX}{task['index']}_{normalize_channel_name(title)}"
    resp = slack_client.conversations_create(name=name, is_private=False)
    channel = resp.get("channel")

    slack_client.conversations_setTopic(
        channel=channel["id"],
        topic=f"âš  Incident: {title}",
    )

    slack_client.conversations_setPurpose(
        channel=channel["id"],
        purpose=f"Task: {task['url']} | Zoom: {zoom_url}",
    )

    slack_client.conversations_invite(
        channel=channel["id"],
        users=slack_user,
    )

    slack_client.chat_postMessage(
        channel=trigger_channel_id,
        thread_ts=trigger_ts,
        text=f"""âš âš âš  Started incident: {title}
Task created: {task["url"]}
Channel created: <#{channel["id"]}>
Zoom: {zoom_url}
""",
    )

    return {
        "title": title,
        "slack_user": slack_user,
        "trigger": {
            "channel_id": trigger_channel_id,
            "ts": trigger_ts,
        },
        "zoom_url": zoom_url,
        "channel": channel,
        "task": task,
    }


def _track(incident: dict):
    s = subscribe("slack", f"data.channel == '{incident['channel']['id']}'")

    while True:
        evt = next_event(s)
        text, user = evt.text.strip(), evt["user"]

        if not text.startswith("!"):
            continue

        parts = text[1:].strip().split(" ", 1)
        cmd = parts[0]
        rest = parts[1] if len(parts) > 1 else ""

        match cmd:
            case "abandon":
                slack_client.chat_postMessage(
                    channel=evt["channel"],
                    ts=evt["ts"],
                    text="abandoned.",
                )
                return
            case "resolve":
                _resolve(incident, user, rest)
                return
            case "note":
                _note(incident, user, rest)

                slack_client.reactions_add(
                    channel=evt["channel"],
                    timestamp=evt["ts"],
                    name="memo",
                )
            case _:
                slack_client.chat_postMessage(
                    channel=evt["channel"],
                    ts=evt["ts"],
                    text="unknown incident command.",
                )


def _resolve(incident: dict, slack_user: str, msg: str):
    text = "ðŸŽ‰ Incident resolved!"

    if msg:
        text += f"\nwith note from <@{slack_user}>: {msg}"

    slack_client.chat_postMessage(
        channel=incident["channel"]["id"],
        text=text,
    )

    slack_client.chat_postMessage(
        channel=incident["trigger"]["channel_id"],
        thread_ts=incident["trigger"]["ts"],
        text=text,
    )

    _note(incident, slack_user, msg)

    slack_client.reactions_add(
        channel=incident["trigger"]["channel_id"],
        timestamp=incident["trigger"]["ts"],
        name="white_check_mark",
    )


def _note(incident: dict, slack_user: str, msg: str):
    resp = slack_client.users_info(user=slack_user)

    height.add_task_message(
        incident["task"]["id"],
        f'{resp["user"]["name"]} via slack: "{msg}"',
    )



================================================
FILE: kittehub/reliability/incidenter/zoom.py
================================================
"""Create Zoom meetings."""

from autokitteh.zoom import zoom_client


zoom = zoom_client("zoom_conn")


def create_meeting(topic):
    resp = zoom.post(
        "https://api.zoom.us/v2/users/me/meetings",
        json={"topic": topic},
    )
    resp.raise_for_status()
    return resp.json().get("join_url")



================================================
FILE: kittehub/reliability/missing_jira_events_monitor/README.md
================================================
title: Missing Jira events monitor
description: Send Slack alerts when AutoKitteh doesn't receive certain Jira events in time
integrations: ["jira", "slack"]
categories: ["Reliability"]



================================================
FILE: kittehub/reliability/missing_jira_events_monitor/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup
# of an AutoKitteh project that sends Slack alerts when AutoKitteh
# doesn't receive certain Jira events in time.

version: v1

project:
  name: missing_jira_events_monitor

  vars:
    # This should be identical to the connection
    # name of the monitored service below!
    - name: CONN_NAME
      value: monitored_service_conn
    # Must be identical/equivalent to the "event_type"
    # and/or "filter" fields of the trigger below!
    - name: EVENT_FILTER
      value:
    - name: EVENT_DESCRIPTION
      value:
    - name: TIMEOUT_HOURS
      value: 24
    - name: PING_HOURS
      value: 1
    - name: SLACK_CHANNEL_NAME_OR_ID
      value: autokitteh-alerts

  connections:
    - name: monitored_service_conn
      integration: jira
    - name: slack_conn
      integration: slack

  triggers:
    - name: monitor_trigger
      connection: monitored_service_conn
      # Set this CEL expression to match the events you want to monitor.
      # Also set the "EVENT_FILTER" project variable above accordingly!
      filter: event_type == "TODO" && data.TODO["TODO"] == "TODO"
      call: program.py:on_monitor_trigger



================================================
FILE: kittehub/reliability/missing_jira_events_monitor/program.py
================================================
"""Send Slack alerts when AutoKitteh doesn't receive certain Jira events in time.

See the configuration and deployment instructions in the README.md file.
"""

from datetime import datetime, timedelta, UTC
import os

import autokitteh
from autokitteh.slack import slack_client


CONN_NAME = os.getenv("CONN_NAME", "")
EVENT_FILTER = os.getenv("EVENT_FILTER", "")
EVENT_DESCRIPTION = os.getenv("EVENT_DESCRIPTION", "")

TIMEOUT_HOURS = int(os.getenv("TIMEOUT_HOURS", "24"))
PING_HOURS = int(os.getenv("PING_HOURS", "1"))

SLACK_CHANNEL = os.getenv("SLACK_CHANNEL_NAME_OR_ID", "")


def on_monitor_trigger(_):
    """Handle an incoming event from a monitored service."""
    start_time = datetime.now(UTC)
    slack = slack_client(CONN_NAME)

    # Wait for the next conformant event from the monitored service.
    sub = autokitteh.subscribe(CONN_NAME, filter=EVENT_FILTER)
    data = autokitteh.next_event(sub, timeout=timedelta(hours=TIMEOUT_HOURS))
    incident_detected = data is None

    # The monitored service hasn't sent us a conformant event for TIMEOUT_HOURS.
    # Send a Slack alert once every PING_HOURS, until the incident is resolved.
    while data is None:
        description = EVENT_DESCRIPTION or f"`{EVENT_FILTER}` in `{CONN_NAME}`"
        msg = f"Events not received since {start_time} (UTC): {description}"
        slack.chat_postMessage(channel=SLACK_CHANNEL, text=msg)

        data = autokitteh.next_event(sub, timeout=timedelta(hours=PING_HOURS))

    # All clear, the monitored service is sending us events still/again.
    # Note that another "on_monitor_trigger" workflow is starting to run now,
    # in a separate AutoKitteh session, waiting for the next event/incident.
    autokitteh.unsubscribe(sub)
    if incident_detected:
        msg = f":relieved: Event received again now: {description}"
        slack.chat_postMessage(channel=SLACK_CHANNEL, text=msg)



================================================
FILE: kittehub/reliability/session_errors_monitor/README.md
================================================
title: AutoKitteh session errors monitor
description: Send Slack alerts when AutoKitteh sessions end due to errors
integrations: ["autokitteh", "slack"]
categories: ["Reliability"]



================================================
FILE: kittehub/reliability/session_errors_monitor/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup of an
# AutoKitteh project that sends Slack alerts when sessions end due to errors.

version: v1

project:
  name: session_errors_monitor

  vars:
    - name: AUTOKITTEH_API_BASE_URL
      value: https://api.autokitteh.cloud
    - name: AUTOKITTEH_UI_BASE_URL
      value: https://app.autokitteh.cloud
    - name: AUTOKITTEH_AUTH_TOKEN
      secret: true
      value:
    - name: SLACK_CHANNEL_NAME_OR_ID
      value: autokitteh-alerts
    - name: TRIGGER_INTERVAL
      value: 1m

  connections:
    - name: slack_conn
      integration: slack

  triggers:
    - name: monitor_schedule
      schedule: "@every 1m"
      call: program.py:on_monitor_schedule



================================================
FILE: kittehub/reliability/session_errors_monitor/program.py
================================================
"""Send Slack alerts when AutoKitteh sessions end due to errors.

See the configuration and deployment instructions in the README.md file.
"""

from datetime import datetime, timedelta, UTC
import json
import os
from urllib.parse import urljoin

from autokitteh.slack import slack_client
import requests
from requests import exceptions


API_BASE_URL = os.getenv("AUTOKITTEH_API_BASE_URL", "")
UI_BASE_URL = os.getenv("AUTOKITTEH_UI_BASE_URL", "")
JWT = os.getenv("AUTOKITTEH_AUTH_TOKEN", "")
SLACK_CHANNEL = os.getenv("SLACK_CHANNEL_NAME_OR_ID", "")

slack = slack_client("slack_conn")


def on_monitor_schedule(_):
    """Triggered at the beginning of every minute, so it covers the previous one."""
    end_time = datetime.now(UTC).replace(second=0, microsecond=0)
    # Remove the unit suffix ("m") and parse as an integer.
    interval = int((os.getenv("TRIGGER_INTERVAL", "1m"))[:-1])
    start_time = end_time - timedelta(minutes=interval)

    count = 0
    for session in reversed(_list_sessions_with_errors()):
        session_updated = datetime.fromisoformat(session["updatedAt"])
        if start_time <= session_updated < end_time:
            count += 1
            _log_error(session)

    print(f"Found {count} sessions with new errors")


def _list_sessions_with_errors():
    url = urljoin(API_BASE_URL, "autokitteh.sessions.v1.SessionsService/List")
    headers = {"Content-Type": "application/json"}
    if JWT:  # Servers in dev mode don't require auth.
        headers["Authorization"] = "Bearer " + JWT

    resp = requests.post(url, headers=headers, json={"stateType": 3}, timeout=10)
    print(f"API call's Round Trip Time: {resp.elapsed}")
    resp.raise_for_status()

    try:
        return resp.json().get("sessions", [])
    except exceptions.JSONDecodeError:
        print(f"Response headers: {resp.headers}")
        print(f"Response text: {resp.text}")
        raise


def _log_error(session):
    data = json.dumps(session, indent=4)
    print(data)

    pid, did = session["projectId"], session["deploymentId"]
    path = f"/projects/{pid}/deployments/{did}/sessions/{session['sessionId']}"
    msg = f"Error in AutoKitteh session: {urljoin(UI_BASE_URL, path)}\n```{data}```"
    slack.chat_postMessage(channel=SLACK_CHANNEL, text=msg)



================================================
FILE: kittehub/room_reservation/README.md
================================================
title: Ad-hoc room reservation via Slack
description: Ad-hoc room reservation via Slack slash commands
integrations: ["slack", "calendar"]
categories: ["Productivity"]



================================================
FILE: kittehub/room_reservation/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup
# of an AutoKitteh project that manages via Slack ad-hoc room
# reservations in Google Calendar.

version: v1

project:
  name: room_reservation

  vars:
    - name: GOOGLE_SHEET_ID
      value:

  connections:
    - name: calendar_conn
      integration: googlecalendar
    - name: sheets_conn
      integration: googlesheets
    - name: slack_conn
      integration: slack

  triggers:
    - name: slack_slash_command_available_rooms
      connection: slack_conn
      event_type: slash_command
      filter: data.text == "availablerooms"
      call: available_rooms.py:on_slack_slash_command
    - name: slack_slash_command_room_status
      connection: slack_conn
      event_type: slash_command
      filter: data.text.startsWith("roomstatus ")
      call: room_status.py:on_slack_slash_command
    - name: slack_slash_command_reserve_room
      connection: slack_conn
      event_type: slash_command
      filter: data.text.startsWith("reserveroom ")
      call: reserve_room.py:on_slack_slash_command



================================================
FILE: kittehub/room_reservation/available_rooms.py
================================================
"""List all the available rooms for the next half hour."""

from datetime import datetime, timedelta, UTC

from autokitteh.google import google_calendar_client
from autokitteh.slack import slack_client
from googleapiclient.errors import HttpError

import util


def on_slack_slash_command(event):
    """Entry point for the "/<app-name> availablerooms" Slack slash command."""
    slack = slack_client("slack_conn")
    channel_id = event.data.user_id  # event.data.channel_id

    now = datetime.now(UTC)
    in_30_minutes = now + timedelta(minutes=30)
    gcal = google_calendar_client("calendar_conn").events()

    # Iterate over the list of rooms, notify the user about
    # each room which is available in the next half hour.
    available = False
    for room in sorted(util.get_room_list()):
        print(f"Checking upcoming events in: {room}")
        try:
            events = gcal.list(
                calendarId=room,
                timeMin=now.isoformat(),
                timeMax=in_30_minutes.isoformat(),
                singleEvents=True,
                orderBy="startTime",
            ).execute()

            events = events.get("items", [])
            # Ignore non-blocking events where the room is marked as "free".
            events = [e for e in events if e.get("transparency", "") != "transparent"]

            if not events:
                msg = f"The room `{room}` is available for the next half hour"
                slack.chat_postMessage(channel=channel_id, text=msg)
                available = True

        except HttpError as e:
            err = f"Error for the room `{room}`: '{e.reason}'"
            slack.chat_postMessage(channel=channel_id, text=err)
            print(f"Error when listing events for room `{room}`: {e}")

    if not available:
        msg = "No available rooms found for the next half hour"
        slack.chat_postMessage(channel=channel_id, text=msg)



================================================
FILE: kittehub/room_reservation/reserve_room.py
================================================
"""Reserve a specific room for the next half hour."""

from datetime import datetime, timedelta, UTC

import autokitteh
from autokitteh.google import google_calendar_client
from autokitteh.slack import slack_client
from googleapiclient.errors import HttpError

import util


def on_slack_slash_command(event):
    """Entry point for the "reserveroom <room> <title>" Slack slash command."""
    data = event.data

    slack = slack_client("slack_conn")
    channel_id = data.user_id  # DM the user who sent the command.

    cmd_text = data.text.split(maxsplit=2)

    if len(cmd_text) < 3:
        err = f"Error: use this format: `{data.command} reserveroom <room> <title>`"
        slack.chat_postMessage(channel=channel_id, text=err)
        return
    _, room, title = cmd_text

    room = util.get_email_from_slack_command(room)

    if room not in util.get_room_list():
        err = f"Error: `{room}` not found in the list of rooms"
        slack.chat_postMessage(channel=channel_id, text=err)
        return

    user = slack.users_profile_get(user=data.user_id).get("profile", {})

    now = datetime.now(UTC)
    in_5_minutes = now + timedelta(minutes=5)
    in_30_minutes = now + timedelta(minutes=30)

    event = {
        "summary": title,
        "description": f"Reserved via Slack by {user['real_name']}",
        "start": {"dateTime": in_5_minutes.isoformat()},
        "end": {"dateTime": in_30_minutes.isoformat()},
        "reminders": {"useDefault": False},
        "attendees": [
            {"email": user["email"]},
        ],
    }

    result = _create_calendar_event(room, event)
    slack.chat_postMessage(channel=channel_id, text=result)


# It's better to mark this as a single activity, to minimize the creation of
# multiple overly-granular activities during this Google Calendar API call.
@autokitteh.activity
def _create_calendar_event(room, event):
    try:
        gcal = google_calendar_client("calendar_conn").events()
        gcal.insert(calendarId=room, body=event).execute()
        return f"Scheduled a meeting now in the room `{room}`"
    except HttpError as e:
        return f"Error: failed to schedule a meeting ('{e.reason}')"



================================================
FILE: kittehub/room_reservation/room_status.py
================================================
"""Check the status of a specific room for the next hour."""

from datetime import datetime, timedelta, UTC

import autokitteh
from autokitteh.google import google_calendar_client
from autokitteh.slack import slack_client
from googleapiclient.errors import HttpError

import util


def on_slack_slash_command(event):
    """Entry point for the "/<app-name> roomstatus <room>" Slack slash command."""
    slack = slack_client("slack_conn")
    channel_id = event.data.user_id  # event.data.channel_id

    # Extract the email address from the Slack command text, which is formatted like:
    # "<@USER_ID> <mailto:test@example.com|test@example.com>".
    room = util.get_email_from_slack_command(event.data.text)

    if room not in util.get_room_list():
        err = f"Error: `{room}` not found in the list of rooms"
        slack.chat_postMessage(channel=channel_id, text=err)

    gcal = google_calendar_client("calendar_conn").events()
    now = datetime.now(UTC)
    in_1_hour = now + timedelta(hours=1)

    msg = f"Events in the room `{room}`:"
    try:
        events = gcal.list(
            calendarId=room,
            timeMin=now.isoformat(),
            timeMax=in_1_hour.isoformat(),
            singleEvents=True,
            orderBy="startTime",
        ).execute()

        events = events.get("items", [])
        # Ignore non-blocking events where the room is marked as "free".
        events = [e for e in events if e.get("transparency", "") != "transparent"]

        if not events:
            msg += " none found for the next half hour"

        for event in events:
            event = autokitteh.AttrDict(event)
            start = event.start.get("dateTime") or event.start.get("date")
            msg += f"\n{start} - {event.summary}"

    except HttpError as e:
        msg += f" error '{e.reason}'"
        print(f"Error when listing events for room `{room}`: {e}")

    slack.chat_postMessage(channel=channel_id, text=msg)



================================================
FILE: kittehub/room_reservation/util.py
================================================
"""Utility functions for the room reservation app."""

import os

from autokitteh.google import google_sheets_client


def get_room_list():
    sheet = google_sheets_client("sheets_conn").spreadsheets().values()
    rows = sheet.get(spreadsheetId=os.getenv("GOOGLE_SHEET_ID"), range="A:A").execute()
    return [cell[0] for cell in rows.get("values", []) if cell]


def get_email_from_slack_command(text):
    """Extract the email address from the Slack command text, which is formatted like:

    "<@USER_ID> <mailto:test@example.com|test@example.com>".
    """
    return text.split("|")[-1].strip(">")



================================================
FILE: kittehub/samples/asana/README.md
================================================
title: Asana sample
description: Simple usage of the Asana API
integrations: ["asana"]
categories: ["Samples"]



================================================
FILE: kittehub/samples/asana/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup
# of an AutoKitteh project that demonstrates integration with Asana.

version: v1

project:
  name: asana_sample

  vars:
    - name: WORKSPACE_GID
      value:

  connections:
    - name: asana_conn
      integration: asana

  triggers:
    - name: create_task_webhook
      type: webhook
      event_type: get
      call: program.py:create_task
    - name: update_task_webhook
      type: webhook
      event_type: post
      call: program.py:update_task



================================================
FILE: kittehub/samples/asana/program.py
================================================
"""Demonstrates AutoKittehâ€™s Asana integration for managing tasks via the Asana API."""

import os

import asana
from autokitteh.asana import asana_client


api_client = asana_client("asana_conn")
client = asana.TasksApi(api_client)

WORKSPACE_GID = os.getenv("WORKSPACE_GID", "")


def create_task(event):
    task_name = event.data.url.query.get("name") or "autokitteh task"
    body = {
        "data": {
            "workspace": WORKSPACE_GID,
            "name": task_name,
            "assignee": "me",
        }
    }

    task = client.create_task(body, {})
    print(f"Task '{task['name']}' has been successfully created!")


def update_task(event):
    """Updates an Asana task's name and due date."""
    form = event.data.body.form
    task_gid = form.get("task_gid")
    new_due_date = form.get("new_due_date", "2025-01-20")
    new_name_suffix = form.get("name_suffix", " - Updated by AutoKitteh")

    task = client.get_task(task_gid, {"opt_fields": "name,assignee,due_on,tags"})
    print(f"Current Task: {task}")

    body = {
        "data": {
            "name": task["name"] + new_name_suffix,
            "due_on": new_due_date,
        }
    }

    updated_task = client.update_task(body, task_gid, {})

    print(f"Task '{updated_task['name']}' has been successfully updated!")



================================================
FILE: kittehub/samples/atlassian/README.md
================================================



================================================
FILE: kittehub/samples/atlassian/jira/README.md
================================================
title: Jira sample
description: Samples using Jira APIs
integrations: ["jira"]
categories: ["Samples"]



================================================
FILE: kittehub/samples/atlassian/jira/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup
# of an AutoKitteh project that demonstrates 2-way integration with
# Atlassian Jira (https://www.atlassian.com/software/jira).

version: v1

project:
  name: jira_sample

  connections:
    - name: jira_conn
      integration: jira

  triggers:
    - name: jira_comment_created
      connection: jira_conn
      event_type: comment_created
      call: program.py:on_jira_comment_created
    - name: jira_issue_created
      connection: jira_conn
      event_type: issue_created
      call: program.py:on_jira_issue_created



================================================
FILE: kittehub/samples/atlassian/jira/program.py
================================================
"""This program demonstrates AutoKitteh's 2-way Atlassian Jira integration.

Atlassian Jira API documentation:
- https://docs.autokitteh.com/integrations/atlassian/jira/python
- https://docs.autokitteh.com/integrations/atlassian/jira/events
"""

from autokitteh.atlassian import jira_client


def on_jira_issue_created(event):
    issue_key = event.data.issue.key
    user_name = event.data.user.displayName

    jira = jira_client("jira_conn")
    jira.issue_add_comment(issue_key, "This issue was created by " + user_name)


def on_jira_comment_created(event):
    issue_key = event.data.issue.key
    comment = event.data.comment

    jira = jira_client("jira_conn")
    suffix = "\n\nThis comment was added by " + comment.author.displayName
    jira.issue_edit_comment(issue_key, comment.id, comment.body + suffix)



================================================
FILE: kittehub/samples/auth0/README.md
================================================
title: Auth0 sample
description: Simple usage of the Auth0 API
integrations: ["auth0"]
categories: ["Samples"]



================================================
FILE: kittehub/samples/auth0/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup
# of an AutoKitteh project that demonstrates integration with Auth0.

version: v1

project:
  name: auth0_sample

  vars:
    - name: ROLE_ID
      value:
    - name: TIME_INTERVAL
      value: 7d

  connections:
    - name: auth_conn
      integration: auth0

  triggers:
    - name: weekly
      schedule: 0 0 * * 1
      call: program.py:weekly_user_growth
    - name: assign_role_webhook
      type: webhook
      event_type: post
      call: program.py:assign_role



================================================
FILE: kittehub/samples/auth0/program.py
================================================
"""Demonstrates AutoKittehâ€™s Auth0 integration for managing tasks via the Auth0 API."""

from datetime import datetime, timedelta, UTC
import os

from autokitteh.auth0 import auth0_client


ROLE_ID = os.getenv("ROLE_ID", "")

auth0 = auth0_client("auth_conn")


def assign_role(event):
    """Entry-point function for a webhook-based workflow assigning a role to a user."""
    user = event.data.body.form.get("user_id", "")
    auth0.roles.add_users(ROLE_ID, [user])
    print(f"Assigned role {ROLE_ID!r} to user {user!r}")


def weekly_user_growth(_):
    """Fetch and display the number of users created in the past week."""
    # Remove the unit suffix ("d") and parse as an integer.
    interval_days = int((os.getenv("TIME_INTERVAL", "7d"))[:-1])
    end_time = datetime.now(UTC).replace(second=0, microsecond=0)
    start_time = end_time - timedelta(minutes=interval_days)

    start_time_iso = start_time.isoformat()
    end_time_iso = end_time.isoformat()

    query = f"created_at:[{start_time_iso} TO {end_time_iso}]"

    response = auth0.users.list(q=query, search_engine="v3")
    new_users = response.get("users", [])

    print(f"New users in the past week: {len(new_users)}")
    for user in new_users:
        print(f"- {user['email']} (created at: {user['created_at']})")



================================================
FILE: kittehub/samples/discord/README.md
================================================



================================================
FILE: kittehub/samples/discord/discord_client/README.md
================================================



================================================
FILE: kittehub/samples/discord/discord_client/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup
# of an AutoKitteh project that demonstrates 2-way integration with
# Discord (https://discord.com/).

version: v1

project:
  name: discord_client_sample

  vars:
    - name: CHANNEL_ID
      value:

  connections:
    - name: discord_conn
      integration: discord
  triggers:
    - name: start_event_loop
      type: webhook
      event_type: get
      call: program.py:start_event_loop



================================================
FILE: kittehub/samples/discord/discord_client/program.py
================================================
"""Discprd bot that performs basic operations."""

import os

import autokitteh
import autokitteh.discord as ak_discord
import discord


intents = discord.Intents.default()
intents.message_content = True

client = ak_discord.discord_client("discord_conn", intents)


@autokitteh.activity
def start_event_loop(event):
    """Starts the bot and connects it to the Discord gateway."""
    client.run(ak_discord.bot_token("discord_conn"))


@client.event
async def on_ready():
    """Asynchronous function triggered when the bot successfully connects to Discord."""
    print(f"We have logged in as {client.user}")
    channel_id = int(os.getenv("CHANNEL_ID"))
    channel = client.get_channel(channel_id)

    if channel is None:
        print(f"Channel with ID {channel_id} not found")
        print("Available channels:")
        for guild in client.guilds:
            for channel in guild.channels:
                print(f"{channel.name} (ID: {channel.id})")
        return

    try:
        await channel.send("Meow!")
    except discord.Forbidden:
        print("The bot does not have permission to send messages in this channel.")
    except discord.HTTPException as e:
        print(f"Failed to send message: {e}")
    finally:
        # Closing the client to prevent duplicate messages
        # or unexpected behavior in future workflows.
        await client.close()



================================================
FILE: kittehub/samples/discord/events/README.md
================================================



================================================
FILE: kittehub/samples/discord/events/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup
# of an AutoKitteh project that demonstrates 2-way integration with
# Discord (https://discord.com/).

version: v1

project:
  name: discord_events_sample

  connections:
    - name: discord_conn
      integration: discord

  triggers:
    - name: discord_message_create
      connection: discord_conn
      event_type: message_create
      call: program.py:on_discord_message_create
    - name: discord_message_update
      connection: discord_conn
      event_type: message_update
      call: program.py:on_discord_message_update
    - name: discord_message_delete
      connection: discord_conn
      event_type: message_delete
      call: program.py:on_discord_message_delete



================================================
FILE: kittehub/samples/discord/events/program.py
================================================
"""Handle message-related events in Discord.

Also log the corresponding information using the `autokitteh.discord` client.
"""


def on_discord_message_create(event):
    print(f"User {event.data['author']['username']} sent: {event.data['content']}")


def on_discord_message_update(event):
    print(f"Message updated to: {event.data['content']}")


def on_discord_message_delete(event):
    print(f"Message with ID {event.data['id']} was deleted")



================================================
FILE: kittehub/samples/github/README.md
================================================



================================================
FILE: kittehub/samples/google/README.md
================================================



================================================
FILE: kittehub/samples/google/calendar/README.md
================================================
title: Google Calendar sample
description: Samples using Google Calendar APIs
integrations: ["calendar"]
categories: ["Samples"]



================================================
FILE: kittehub/samples/google/calendar/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup
# of an AutoKitteh project that demonstrates 2-way integration with
# Google Calendar (https://workspace.google.com/products/calendar/).

version: v1

project:
  name: google_calendar_sample

  connections:
    - name: calendar_conn
      integration: googlecalendar

  triggers:
    - name: list_events
      type: webhook
      event_type: get
      call: program.py:list_events
    - name: google_calendar_event_created
      connection: calendar_conn
      event_type: event_created
      call: program.py:on_calendar_event_created
    - name: google_calendar_event_updated
      connection: calendar_conn
      event_type: event_updated
      call: program.py:on_calendar_event_updated
    - name: google_calendar_event_deleted
      connection: calendar_conn
      event_type: event_deleted
      call: program.py:on_calendar_event_deleted



================================================
FILE: kittehub/samples/google/calendar/program.py
================================================
"""This program demonstrates AutoKitteh's 2-way Google Calendar integration.

API documentation:
- https://docs.autokitteh.com/integrations/google/calendar/python
- https://docs.autokitteh.com/integrations/google/calendar/events
"""

from datetime import datetime, UTC

from autokitteh.google import google_calendar_client
from googleapiclient.errors import HttpError


def list_events(event):
    """Get the next 10 events from the primary calendar.

    This is the same as Google's quickstart code sample, but simpler:
    https://github.com/googleworkspace/python-samples/tree/main/calendar
    """
    gcal = google_calendar_client("calendar_conn").events()
    print("Getting the next 10 events")

    try:
        result = gcal.list(
            calendarId="primary",
            timeMin=datetime.now(UTC).isoformat(),
            maxResults=10,
            singleEvents=True,
            orderBy="startTime",
        ).execute()
    except HttpError as e:
        print(f"An error occurred: {e.reason}")
        return

    events = result.get("items")
    if not events:
        print("No upcoming events found")
        return

    for e in events:
        start = e["start"].get("dateTime") or e["start"].get("date")
        start = datetime.fromisoformat(start)
        print(f"{start} - {e['summary']}")


def on_calendar_event_created(event):
    print("Event created:", event.data)


def on_calendar_event_updated(event):
    print("Event updated:", event.data)


def on_calendar_event_deleted(event):
    print("Event deleted:", event.data)



================================================
FILE: kittehub/samples/google/drive/README.md
================================================
title: Google Drive sample
description: Samples using Google Drive APIs
integrations: ["drive"]
categories: ["Samples"]



================================================
FILE: kittehub/samples/google/drive/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup
# of an AutoKitteh project that demonstrates 2-way integration with
# Google Drive (https://workspace.google.com/products/drive/).

version: v1

project:
  name: google_drive_sample

  connections:
    - name: google_drive_conn
      integration: googledrive

  vars:
    - name: USER_EMAIL
      value:

  triggers:
    - name: create_new_document
      type: webhook
      call: program.py:create_new_document
    - name: on_file_change
      connection: google_drive_conn
      event_type: file_change
      call: program.py:on_file_change
    - name: on_file_remove
      connection: google_drive_conn
      event_type: file_remove
      call: program.py:on_file_remove



================================================
FILE: kittehub/samples/google/drive/program.py
================================================
"""Autokitteh's Google Drive integration to monitor changes to files."""

import os

from autokitteh.google import google_drive_client


USER_EMAIL = os.getenv("USER_EMAIL", "")


def on_file_change(event):
    print(f"File with ID {event.data.file_id} has changed!")


def on_file_remove(event):
    print(f"File with ID {event.data.file_id} has been removed!")


def create_new_document(_):
    """Creates a new Google Document and optionally shares it with a specified user.

    If the Google Drive permission scope is limited to https://www.googleapis.com/auth/drive.file,
    the app must create a new file to enable change monitoring. Note that creating a
    file is not the only way to grant permissions; there are other options detailed
    here: https://developers.google.com/drive/api/guides/manage-sharing. For example,
    when using a service account, you can share a specific file with the service
    account's email address.
    """
    client = google_drive_client("google_drive_conn")

    file_metadata = {
        "name": "New Document",
        "mimeType": "application/vnd.google-apps.document",
    }

    file = client.files().create(body=file_metadata).execute()

    # When using a service account, granting access to a specific user
    # can simplify file interactions. This step is optional.
    if USER_EMAIL:
        client.permissions().create(
            fileId=file.get("id"),
            body={"type": "user", "role": "writer", "emailAddress": USER_EMAIL},
        ).execute()

    print(f"Created file with ID: {file.get('id')}")



================================================
FILE: kittehub/samples/google/forms/README.md
================================================
title: Google Forms sample
description: Samples using Google Forms APIs
integrations: ["forms"]
categories: ["Samples"]



================================================
FILE: kittehub/samples/google/forms/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup
# of an AutoKitteh project that demonstrates 2-way integration with
# Google Forms (https://www.google.com/forms/about/).

version: v1

project:
  name: google_forms_sample
  connections:
    - name: forms_conn
      integration: googleforms

  triggers:
    - name: add_question
      type: webhook
      event_type: get
      call: program.py:add_question
    - name: google_forms_schema_change
      connection: forms_conn
      event_type: schema
      call: program.py:on_form_change
    - name: google_forms_response
      connection: forms_conn
      event_type: responses
      call: program.py:on_form_response



================================================
FILE: kittehub/samples/google/forms/new_question.json
================================================
{
    "requests": [
        {
            "createItem": {
                "item": {
                    "title": "In what year did the United States land a mission on the moon?",
                    "questionItem": {
                        "question": {
                            "required": true,
                            "choiceQuestion": {
                                "type": "RADIO",
                                "options": [
                                    {"value": "1965"},
                                    {"value": "1967"},
                                    {"value": "1969"},
                                    {"value": "1971"}
                                ],
                                "shuffle": true
                            }
                        }
                    }
                },
                "location": {"index": 0}
            }
        }
    ]
}



================================================
FILE: kittehub/samples/google/forms/program.py
================================================
"""This program demonstrates AutoKitteh's 2-way Google Forms integration.

API documentation:
- https://docs.autokitteh.com/integrations/google/forms/python
- https://docs.autokitteh.com/integrations/google/forms/events
"""

import json
import os
from pathlib import Path

from autokitteh.google import google_forms_client


def add_question(event):
    """Add a new question to the form that our connection watches.

    This is the same as Google's quickstart code sample, but simpler:
    https://github.com/googleworkspace/python-samples/tree/main/forms
    """
    # Get the form that our connection watches.
    forms = google_forms_client("forms_conn").forms()
    form_id = os.environ.get("forms_conn__FormID")
    form = forms.get(formId=form_id).execute()
    new_index = len(form["items"])

    # Add a new question to the form.
    body = Path("new_question.json").read_text().replace("0", str(new_index))
    result = forms.batchUpdate(formId=form_id, body=json.loads(body)).execute()
    print(result)


def on_form_change(event):
    title = event.data.form.info.title
    form_id = event.data.form_id
    revision = event.data.form.revision_id
    items = len(event.data.form.get("items", []))
    print(f"Form change: {title} ({form_id}), revision {revision}, {items} items")


def on_form_response(event):
    print("New form response submitted:", event.data)



================================================
FILE: kittehub/samples/google/gemini/README.md
================================================
title: Gemini sample
description: Simple usage of the Gemini API
integrations: ["googlegemini"]
categories: ["AI", "Samples"]



================================================
FILE: kittehub/samples/google/gemini/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup
# of an AutoKitteh project that demonstrates integration with Gemini.

version: v1

project:
  name: gemini_sample

  connections:
    - name: gemini_conn
      integration: googlegemini

  triggers:
    - name: trivial_interaction
      type: webhook
      event_type: get
      call: program.py:trivial_interaction
    - name: interactive_chat
      type: webhook
      event_type: get
      call: program.py:interactive_chat



================================================
FILE: kittehub/samples/google/gemini/program.py
================================================
"""Demonstration of AutoKitteh's Gemini integration.

Two entry-point functions are implemented that send requests to the
Gemini API and print the responses in the AutoKitteh session log.
"""

from autokitteh.google import gemini_client


MODEL = "gemini-1.5-flash"

gemini = gemini_client("gemini_conn", model_name=MODEL)


def trivial_interaction(_):
    prompt = "say meow in different languages"
    response = gemini.generate_content(prompt)
    print(response.text)


def interactive_chat(_):
    chat = gemini.start_chat(
        history=[
            {"role": "user", "parts": "Hello"},
            {
                "role": "model",
                "parts": "Great to meet you. What would you like to know?",
            },
        ]
    )
    response = chat.send_message("I have 2 cats in my house.")
    print(response.text)
    response = chat.send_message("How many paws are in my house?")
    print(response.text)



================================================
FILE: kittehub/samples/google/gmail/README.md
================================================
title: Gmail sample
description: Samples using Gmail APIs
integrations: ["gmail"]
categories: ["Samples"]



================================================
FILE: kittehub/samples/google/gmail/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup
# of an AutoKitteh project that demonstrates 2-way integration with
# Gmail (https://www.google.com/gmail/about/).

version: v1

project:
  name: gmail_sample

  connections:
    - name: gmail_conn
      integration: gmail

  triggers:
    - name: on_http_get
      type: webhook
      event_type: get
      call: program.py:on_http_get
    - name: gmail_mailbox_change
      connection: gmail_conn
      event_type: mailbox_change
      call: program.py:on_gmail_mailbox_change



================================================
FILE: kittehub/samples/google/gmail/program.py
================================================
"""This program demonstrates AutoKitteh's 2-way Gmail integration.

API documentation:
- https://docs.autokitteh.com/integrations/google/gmail/python
- https://docs.autokitteh.com/integrations/google/gmail/events
"""

import base64
import json

import autokitteh
from autokitteh.google import gmail_client
from googleapiclient.errors import HttpError


gmail = gmail_client("gmail_conn").users()


def on_http_get(event):
    """Handle Gmail interaction via HTTP trigger using query params.

    Example URL: "http://localhost:9980/webhooks/<webhook_slug>?cmd=list_drafts"

    Commands:
    - cmd=get_profile
    - cmd=list_drafts&query=optional_query
    - cmd=get_draft&draft_id=<draft_ID>
    - cmd=list_messages&query=optional_query
    - cmd=get_message&message_id=<message_ID>
    - cmd=send_message&text=<message_text>

    Args:
        event: HTTP request event data (contains query parameters).
    """
    params = event.data.url.query
    cmd = params.get("cmd")

    match cmd:
        case "get_profile":
            _get_profile()
        case "list_drafts":
            _drafts_list(params.get("query", ""))
        case "get_draft":
            _drafts_get(params.get("draft_id"))
        case "list_messages":
            _messages_list(params.get("query", ""))
        case "get_message":
            _messages_get(params.get("message_id"))
        case "send_message":
            _messages_send(params.get("text"))
        case _:
            return "Unknown command"


def _get_profile():
    """https://developers.google.com/resources/api-libraries/documentation/gmail/v1/python/latest/gmail_v1.users.html#getProfile"""
    resp = gmail.getProfile(userId="me").execute()
    print(resp["emailAddress"])
    print("Total no. of messages:", resp["messagesTotal"])
    print("Total no. of threads:", resp["threadsTotal"])
    print("Current History record ID:", resp["historyId"])


def _drafts_get(id):
    """https://developers.google.com/resources/api-libraries/documentation/gmail/v1/python/latest/gmail_v1.users.drafts.html#get

    Args:
        id: Required ID of the draft to retrieve.
    """
    try:
        resp = gmail.drafts().get(userId="me", id=id).execute()
    except HttpError as e:
        print(f"Error: `{e.reason}`")
        return

    print(f"```\n{json.dumps(resp, indent=4)}\n```")


def _drafts_list(query):
    """https://developers.google.com/resources/api-libraries/documentation/gmail/v1/python/latest/gmail_v1.users.drafts.html#list

    Args:
        query: Optional query, e.g. "is:unread".
    """
    try:
        resp = gmail.drafts().list(userId="me", q=query, maxResults=10).execute()
    except HttpError as e:
        print(f"Error: `{e.reason}`")
        return

    print(f"Result size estimate: `{resp['resultSizeEstimate']}`")

    for i, d in enumerate(resp.get("drafts", []), start=1):
        print(f"{i}\n```\n{json.dumps(d, indent=4)}\n```")

    next_page_token = resp.get("nextPageToken")
    if next_page_token:
        print(f"Next page token: `{next_page_token}`")


def _messages_get(id):
    """https://developers.google.com/resources/api-libraries/documentation/gmail/v1/python/latest/gmail_v1.users.messages.html#get

    Args:
        id: Required ID of the message to retrieve.
    """
    try:
        resp = gmail.messages().get(userId="me", id=id).execute()
    except HttpError as e:
        print(f"Error: `{e.reason}`")
        return

    print(f"```\n{json.dumps(resp, indent=4)}\n```")


def _messages_list(query):
    """https://developers.google.com/resources/api-libraries/documentation/gmail/v1/python/latest/gmail_v1.users.messages.html#list

    See also:
    https://developers.google.com/resources/api-libraries/documentation/gmail/v1/python/latest/gmail_v1.users.messages.html#list_next

    Args:
        query: Optional query, e.g. "is:unread".
    """
    try:
        resp = gmail.messages().list(userId="me", q=query, maxResults=10).execute()
    except HttpError as e:
        print(f"Error: `{e.reason}`")
        return

    print(f"Result size estimate: `{resp['resultSizeEstimate']}`")

    for i, m in enumerate(resp.get("messages", []), start=1):
        print(f"{i}\n```\n{json.dumps(m, indent=4)}\n```")

    next_page_token = resp.get("nextPageToken")
    if next_page_token:
        print(f"Next page token: `{next_page_token}`")


def _messages_send(text):
    """https://developers.google.com/resources/api-libraries/documentation/gmail/v1/python/latest/gmail_v1.users.messages.html#send

    See also: https://developers.google.com/gmail/api/guides/sending

    This is the same as Google's send-message snippet, but simpler:
    https://github.com/googleworkspace/python-samples/blob/main/gmail/snippet/send%20mail/send_message.py

    Args:
        text: Short message to send to yourself.
    """
    profile = gmail.getProfile(userId="me").execute()

    # Raw text compliant with https://datatracker.ietf.org/doc/html/rfc5322.
    msg = f"""From: {profile["emailAddress"]}
    To: {profile["emailAddress"]}
    Subject: Test from AutoKitteh

    {text}"""

    msg = msg.replace("\n", "\r\n").replace("    ", "")
    msg = base64.urlsafe_b64encode(msg.encode()).decode()
    try:
        gmail.messages().send(userId="me", body={"raw": msg}).execute()
    except HttpError as e:
        print(f"Error: `{e.reason}`")
        return

    print("Message sent successfully!")


def on_gmail_mailbox_change(event):
    """Gmail Mailbox Change Event Handler.

    This function acts as a custom event handler for Gmail mailbox changes
    (triggered via Pub/Sub webhook events). Due to limitations
    in Gmail's native history ID event handling, this
    function detects and handles incoming emails events.
    """
    try:
        history_id = event.data.get("history_id")
        if not history_id:
            return

        current_history_id = int(history_id)
        last_processed_id = int(
            autokitteh.get_value("last_processed_id") or (current_history_id - 100)
        )

        history = (
            gmail.history()
            .list(userId="me", startHistoryId=str(last_processed_id))
            .execute()
        )

        if "history" in history:
            for history_record in history["history"]:
                record_id = int(history_record["id"])

                # Skip already processed records.
                if record_id <= last_processed_id:
                    continue

                if "messagesAdded" in history_record:
                    for message_entry in history_record["messagesAdded"]:
                        message_id = message_entry["message"]["id"]
                        message = (
                            gmail.messages()
                            .get(
                                userId="me",
                                id=message_id,
                                format="metadata",
                                metadataHeaders=["From", "To", "Subject"],
                            )
                            .execute()
                        )

                        # Only process INBOX messages (incoming).
                        labels = message.get("labelIds", [])
                        if "INBOX" in labels and "SENT" not in labels:
                            on_new_message(message)

        # Only update if we processed something new.
        if current_history_id > last_processed_id:
            autokitteh.set_value("last_processed_id", str(current_history_id))

    except HttpError as e:
        print(f"Error: {e.reason}")


def on_new_message(message):
    headers = {
        h["name"]: h["value"] for h in message.get("payload", {}).get("headers", [])
    }
    print("New Mail Received:")
    print(f"From: {headers.get('From')}")
    print(f"To: {headers.get('To')}")
    print(f"Subject: {headers.get('Subject')}")



================================================
FILE: kittehub/samples/google/sheets/README.md
================================================
title: Google Sheets sample
description: Samples using Google Sheets APIs
integrations: ["sheets"]
categories: ["Samples"]



================================================
FILE: kittehub/samples/google/sheets/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup
# of an AutoKitteh project that demonstrates 2-way integration with
# Google Sheets (https://workspace.google.com/products/sheets/).

version: v1

project:
  name: google_sheets_sample

  connections:
    - name: sheets_conn
      integration: googlesheets

  triggers:
    - name: http_get
      type: webhook
      event_type: get
      call: program.py:on_http_get



================================================
FILE: kittehub/samples/google/sheets/program.py
================================================
"""This program demonstrates AutoKitteh's 2-way Google Sheets integration.

API documentation:
https://docs.autokitteh.com/integrations/google/sheets/python
"""

import autokitteh
from autokitteh.google import google_sheets_client


sheet = google_sheets_client("sheets_conn").spreadsheets().values()


def on_http_get(event):
    """Entry point for the workflow.

    This function expects the URL parameter 'id' to be a valid Google Sheets ID
    (see https://developers.google.com/sheets/api/guides/concepts).

    Example URL: "http://localhost:9980/webhooks/<webhook-slug>?id=<Google-Sheets-ID>"

    Args:
        event: HTTP event data, including URL query parameters.
    """
    sheet_id = event.data.url.query.get("id")
    if not sheet_id:
        print("Error: Missing required 'id' URL parameter for Google Sheets.")
        return

    _write_values(sheet_id)
    _read_values(sheet_id)
    _read_formula(sheet_id)


@autokitteh.activity
def _write_values(id):
    """Write multiple cell values, with different data types."""
    resp = sheet.update(
        spreadsheetId=id,
        # Explanation of the A1 notation for cell ranges:
        # https://developers.google.com/sheets/api/guides/concepts#expandable-1
        range="Sheet1!A1:B7",
        # Value input options:
        # https://developers.google.com/sheets/api/reference/rest/v4/ValueInputOption
        valueInputOption="USER_ENTERED",
        body={
            "values": [
                ["String", "Hello, world!"],
                ["Number", -123.45],
                ["Also number", "-123.45"],
                ["Percent", "10.12%"],
                ["Boolean", True],
                ["Date", "2022-12-31"],
                ["Formula", "=B2*B3"],
            ]
        },
    ).execute()

    print(f"Updated range: {resp['updatedRange']!r}")
    print(f"Rows: {resp['updatedRows']}")
    print(f"Columns: {resp['updatedColumns']}")
    print(f"Cells: {resp['updatedCells']}")


@autokitteh.activity
def _read_values(id):
    """Read multiple cell values from a Google Sheet, and send them to Slack.

    Value render options:
    https://developers.google.com/sheets/api/reference/rest/v4/ValueRenderOption
    """
    # Default value render option: "FORMATTED_VALUE".
    resp = sheet.get(spreadsheetId=id, range="A1:B6").execute()
    col_a, formatted_col_b = list(zip(*resp.get("values", []), strict=True))

    ufv = "UNFORMATTED_VALUE"
    resp = sheet.get(spreadsheetId=id, range="A1:B6", valueRenderOption=ufv).execute()
    unform_col_b = [v for _, v in resp.get("values", [])]

    for i, row in enumerate(zip(col_a, formatted_col_b, unform_col_b, strict=True)):
        data_type, formatted, unformatted = row
        text = f"Row {i + 1}: {data_type} = formatted "
        text += f"`{formatted!r}`, unformatted `{unformatted!r}`"
        print(text)


@autokitteh.activity
def _read_formula(id):
    """Read a single cell value with a formula, and its evaluated result.

    Value render options:
    https://developers.google.com/sheets/api/reference/rest/v4/ValueRenderOption
    """
    f = "FORMULA"
    resp = sheet.get(spreadsheetId=id, range="B7", valueRenderOption=f).execute()
    value = resp.get("values", [["Not found"]])[0][0]
    print(f"Formula: `{value!r}`")

    # Default value render option: "FORMATTED_VALUE".
    resp = sheet.get(spreadsheetId=id, range="B7").execute()
    value = resp.get("values", [["Not found"]])[0][0]
    print(f"Formula: `{value!r}`")

    ufv = "UNFORMATTED_VALUE"
    resp = sheet.get(spreadsheetId=id, range="B7", valueRenderOption=ufv).execute()
    value = resp.get("values", [["Not found"]])[0][0]
    print(f"Formula: `{value!r}`")



================================================
FILE: kittehub/samples/http/README.md
================================================
title: HTTP sample
description: Samples using HTTP requests and webhooks
integrations: ["http"]
categories: ["Samples"]



================================================
FILE: kittehub/samples/http/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup
# of an AutoKitteh project that demonstrates 2-way usage of HTTP.

version: v1

project:
  name: http_sample
  vars:
    - name: HTTPBIN_BASE_URL
      value: https://httpbin.org/

  triggers:
    - name: receive_http_get_or_head
      type: webhook
      filter: data.method in ["GET", "HEAD"]
      call: webhooks.py:on_http_get_or_head

    - name: receive_http_post_form
      type: webhook
      event_type: post
      filter: data.headers["Content-Type"] == "application/x-www-form-urlencoded"
      call: webhooks.py:on_http_post_form
    - name: receive_http_post_json
      type: webhook
      event_type: post
      filter: data.headers["Content-Type"].startsWith("application/json")
      call: webhooks.py:on_http_post_json

    - name: send_requests
      type: webhook
      call: webhooks.py:send_requests



================================================
FILE: kittehub/samples/http/basic_auth.py
================================================
"""This module demonstrates the "requests" library with basic authentication."""

import base64
from urllib.parse import urljoin

import requests


def send_requests(base_url):
    """Send HTTP requests with basic authentication (username + password).

    See: https://datatracker.ietf.org/doc/html/rfc7617
    """
    print("\n>>> Sending HTTP requests with basic authentication")

    expected_creds = ("user", "pass")
    url = urljoin(base_url, f"basic-auth/{expected_creds[0]}/{expected_creds[1]}")

    print("\n--- Use the expected credentials (authentication success)")
    resp = requests.get(url, auth=expected_creds, timeout=10)
    _print_response_details(resp)

    print("\n--- Use unexpected credentials (authentication failure)")
    # Also, set them directly in the HTTP request headers, instead of
    # using the "auth" parameter, just for the sake of demonstration.
    unexpected_creds = "someone_else:wrong_password"
    headers = {
        "Authorization": "Basic " + base64.b64encode(unexpected_creds.encode()).decode()
    }
    resp = requests.get(url, headers=headers, timeout=10)
    _print_response_details(resp)


def _print_response_details(resp):
    print("Response URL:", resp.url)
    print("Response status code:", resp.status_code)
    print("Response text:", resp.text)
    print("Response headers:")
    for key in sorted(resp.headers):
        print(f"  {key} = {resp.headers[key]}")



================================================
FILE: kittehub/samples/http/bearer_token.py
================================================
"""This module demonstrates the "requests" library with an OAuth bearer token."""

from urllib.parse import urljoin

import requests


def send_requests(base_url):
    """Send HTTP requests with an OAuth bearer token.

    See: https://datatracker.ietf.org/doc/html/rfc6750
    """
    print("\n>>> Sending HTTP requests with an OAuth bearer token")

    url = urljoin(base_url, "bearer")
    token = "my_bearer_token"  # noqa: S105
    headers = {"Authorization": "Bearer " + token}
    resp = requests.get(url, headers=headers, timeout=10)
    _print_response_details(resp)


def _print_response_details(resp):
    print("Response URL:", resp.url)
    print("Response status code:", resp.status_code)
    print("Response text:", resp.text)
    print("Response headers:")
    for key in sorted(resp.headers):
        print(f"  {key} = {resp.headers[key]}")



================================================
FILE: kittehub/samples/http/no_auth.py
================================================
"""This module demonstrates the "requests" library without authentication."""

from urllib.parse import urljoin

import requests


def send_requests(base_url):
    print(">>> Sending requests without authentication")

    _get_echo_params(base_url)
    _get_html(base_url)
    _get_json(base_url)
    _get_error(base_url)

    url = urljoin(base_url, "post")
    _post_echo_form(url)
    _post_echo_json(url)


def _get_echo_params(base_url):
    """https://httpbin.org/#/HTTP_Methods/get_get"""
    url = urljoin(base_url, "get")
    print(f"\n--- GET {url}")
    resp = requests.get(url, params={"key1": "value1", "key2": "value2"}, timeout=10)
    # Expected: "Content-Type" header is "application/json".
    _print_response_status_and_headers(resp)

    # httpbin echoes back query params (as "args"), headers, and other things
    # in the response's JSON body. In this specific case, the "headers",
    # "args", "url" keys should be present in the response body.

    # Expected JSON: {"args": {"key1": "value1", ... }, ...}
    print(f"Response body (JSON):\n{resp.json()}")
    # Expected text: same as JSON, but formatted as multiline text.
    print(f"Response body (text):\n{resp.text}")


def _get_html(base_url):
    """https://httpbin.org/#/Response_formats/get_html"""
    url = urljoin(base_url, "html")
    print(f"\n--- GET {url}")
    resp = requests.get(url, timeout=10)
    _print_response_status_and_headers(resp)

    # Expected text: "\u003c!DOCTYPE html\u003e\\n..."
    print(f"Response body (text):\n{resp.text}")
    # Don't call resp.json(), since HTML is not valid JSON.


def _get_json(base_url):
    """https://httpbin.org/#/Response_formats/get_json"""
    url = urljoin(base_url, "json")
    print(f"\n--- GET {url}")
    resp = requests.get(url, timeout=10)
    _print_response_status_and_headers(resp)

    # Expected text: same as JSON, but formatted as multiline byte text.
    print(f"response body (bytes):\n{resp.content}")
    # Expected JSON: {"slideshow": {"author": "Yours Truly", ... }}
    print(f"response body (json):\n{resp.json()}")
    # Expected value inside JSON: "Yours Truly".
    slideshow_author = resp.json().get("slideshow", {}).get("author")
    print("response_json['slideshow']['author']:", slideshow_author)


def _get_error(base_url):
    url = urljoin(base_url, "status/404")
    print(f"\n--- GET {url}")
    resp = requests.get(url, timeout=10)
    _print_response_status_and_headers(resp)  # Expected status code: 404.


def _post_echo_form(url):
    """https://httpbin.org/#/HTTP_Methods/post_post"""
    print(f"\n--- POST {url} (form)")
    resp = requests.post(url, data={"foo": "bar"}, timeout=10)
    # Expected: "Content-Type" header is "application/json".
    _print_response_status_and_headers(resp)

    # The form we submitted will be echoed back by httpbin under the "form" key.

    # Expected JSON: {..., "form": {"foo": "bar"}, ...}
    print(f"Response body (JSON):\n{resp.json()}")
    # Expected text: same as JSON, but formatted as multiline text.
    print(f"Response body (text):\n{resp.text}")


def _post_echo_json(url):
    """https://httpbin.org/#/HTTP_Methods/post_post"""
    print(f"\n--- POST {url} (JSON)")

    # Option 1: use the "json" param, without specifying content type.
    resp = requests.post(url, json={"foo": "bar"}, timeout=10)

    # Option 2: use the "data" param, and specify its content type.
    # headers={"Content-Type": "application/json", ...}
    # resp = requests.post(url, data={"foo": "bar"}, headers=headers)

    _print_response_status_and_headers(resp)

    # The JSON we sent will be echoed back by httpbin under the "data" key
    # (as a string), and the "json" key.

    # Expected JSON: {..., "data": "{...}", "json": {"foo": "bar"}, ...}
    print(f"Response body (JSON):\n{resp.json()}")
    # Expected text: same as JSON, but formatted as text.
    print(f"Response body (text):\n{resp.text}")


def _print_response_status_and_headers(resp):
    print("Response status code:", resp.status_code)
    print("Response headers:")
    for key in sorted(resp.headers):
        print(f"  {key} = {resp.headers[key]}")



================================================
FILE: kittehub/samples/http/webhooks.py
================================================
"""This module demonstrates the usage of AutoKitteh webhooks."""

import os

import basic_auth
import bearer_token
import no_auth


BASE_URL = os.getenv("HTTPBIN_BASE_URL")  # Set in "autokitteh.yaml".


def on_http_get_or_head(event):
    """Handle incoming HTTP GET and HEAD requests.

    - https://www.rfc-editor.org/rfc/rfc9110#name-get
    - https://www.rfc-editor.org/rfc/rfc9110#name-head

    Args:
        event: Incoming HTTP request details.
    """
    _print_request_details(event.data)

    print("Query parameters:")
    if not event.data.url.query:
        print("  none")
    for key in sorted(event.data.url.query):
        print(f"  {key} = {event.data.url.query[key]}")


def on_http_post_form(event):
    """Handle URL-encoded form submissions in HTTP POST requests.

    - https://www.rfc-editor.org/rfc/rfc9110#name-post
    - https://html.spec.whatwg.org/multipage/forms.html

    Args:
        event: Incoming HTTP request details.
    """
    _print_request_details(event.data)
    print(f"Body: {event.data.body.bytes}")

    print("Form parameters:")
    if not event.data.body.form:
        print("  none")
    for key in sorted(event.data.body.form):
        print(f"  {key} = {event.data.body.form[key]}")


def on_http_post_json(event):
    """Handle incoming HTTP POST requests with a JSON body.

    https://www.rfc-editor.org/rfc/rfc9110#name-post

    Args:
        event: Incoming HTTP request details.
    """
    _print_request_details(event.data)
    print(f"Body: {event.data.body.bytes}")
    print(f"JSON: {event.data.body.json}")


def _print_request_details(data):
    print(f"Triggered by an HTTP {data.method} request")
    print("Full URL:", data.raw_url)
    print("URL path:", data.url.path)

    print("Headers:")
    for key in sorted(data.headers):
        print(f"  {key} = {data.headers[key]}")


def send_requests(event):
    """Send various HTTP requests with various authentication schemes."""
    no_auth.send_requests(BASE_URL)
    basic_auth.send_requests(BASE_URL)
    bearer_token.send_requests(BASE_URL)



================================================
FILE: kittehub/samples/hubspot/README.md
================================================
title: HubSpot sample
description: Simple usage of the HubSpot API
integrations: ["hubspot"]
categories: ["CRM", "Samples"]



================================================
FILE: kittehub/samples/hubspot/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup of
# an AutoKitteh project that demonstrates integration with HubSpot.

version: v1

project:
  name: hubspot

  connections:
    - name: hubspot_conn
      integration: hubspot

  triggers:
    - name: create_contact_webhook
      type: webhook
      event_type: post
      call: program.py:create_contact
    - name: list_deals_webhook
      type: webhook
      event_type: get
      call: program.py:list_deals



================================================
FILE: kittehub/samples/hubspot/program.py
================================================
"""Demonstration of AutoKitteh's HubSpot integration.

This script showcases two basic operations with the HubSpot API:
creating a new contact and listing all deals.
"""

from autokitteh.hubspot import hubspot_client
from hubspot.crm import contacts


hubspot = hubspot_client("hubspot_conn")


def create_contact(event):
    contact_properties = {
        "email": event.data.body.form.get("email", "meow@autokitteh.com"),
        "firstname": event.data.body.form.get("firstname", "Kitty"),
        "lastname": event.data.body.form.get("lastname", "Meowington"),
    }
    contact_input = contacts.SimplePublicObjectInputForCreate(
        properties=contact_properties
    )

    response = hubspot.crm.contacts.basic_api.create(
        simple_public_object_input_for_create=contact_input
    )

    print(f"Contact created with ID: {response.id}")


def list_deals(event):
    for deal in hubspot.crm.deals.get_all():
        print(f"Deal ID: {deal.id}, deal name: {deal.properties.get('dealname')}")



================================================
FILE: kittehub/samples/openai_chatgpt/README.md
================================================
title: OpenAI ChatGPT sample
description: Samples using chatGPT APIs
integrations: ["chatgpt"]
categories: ["AI", "Samples"]



================================================
FILE: kittehub/samples/openai_chatgpt/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup
# of an AutoKitteh project that demonstrates integration with
# OpenAI ChatGPT (https://chat.openai.com).

version: v1

project:
  name: chatgpt_sample

  connections:
    - name: chatgpt_conn
      integration: chatgpt

  triggers:
    - name: on_http_get
      type: webhook
      event_type: post
      filter: data.headers["Content-Type"] == "text/plain"
      call: program.py:on_http_post



================================================
FILE: kittehub/samples/openai_chatgpt/program.py
================================================
"""This program demonstrates AutoKitteh's OpenAI ChatGPT integration.

The program implements a single entry-point function, which is
configured in the "autokitteh.yaml" manifest file to receive HTTP GET requests.

It sends a couple of requests to the ChatGPT API, and prints the responses
in the AutoKitteh session log, along with ChatGPT token usage stats.

API details:
- OpenAI developer platform: https://platform.openai.com/
- Python client library: https://github.com/openai/openai-python

This program isn't meant to cover all available functions and events.
It merely showcases various illustrative, annotated, reusable examples.
"""

from autokitteh.openai import openai_client


MODEL = "gpt-4o-mini"

chatgpt_client = openai_client("chatgpt_conn")


def on_http_post(event):
    """Entry-point function for handling HTTP GET requests in this workflow.

    Example usage:
    - URL: "http://localhost:9980/webhooks/<webhook_slug>"
    - Curl command:
      curl -X POST "<URL>" -H "Content-Type: text/plain" -d "Why do cats purr?"

    Args:
        event: The HTTP event containing request data.
    """
    body = ""
    if event:
        body = event.data.body.bytes.decode("utf-8")

    # Example 1: trivial interaction with ChatGPT.
    msg = {"role": "user", "content": body or "Meow"}
    resp = chatgpt_client.chat.completions.create(model=MODEL, messages=[msg])

    # For educational and debugging purposes, print ChatGPT's response
    # in the AutoKitteh session's log.
    print(resp)

    # Example 2: more verbose interaction with ChatGPT,
    # including the user's text as part of the conversation.
    msgs = [
        {
            "role": "system",
            "content": (
                "You are a poetic assistant, skilled in "
                "explaining complex engineering concepts."
            ),
        },
        {
            "role": "user",
            "content": body
            or (
                "Compose a Shakespearean sonnet about the importance of reliability, "
                "scalability, and durability, in distributed workflows."
            ),
        },
    ]

    resp = chatgpt_client.chat.completions.create(model=MODEL, messages=msgs)

    for choice in resp.choices:
        print(choice.message.content)
    print(f"Usage: `{resp.usage}`")



================================================
FILE: kittehub/samples/runtime_events/README.md
================================================
title: Runtime Events sample
description: Samples using events in AutoKitteh - subscribe(), next_event(), unsubscribe()
integrations: ["autokitteh"]
categories: ["Samples"]



================================================
FILE: kittehub/samples/runtime_events/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup
# of an AutoKitteh project that demonstrates runtime event handling.

version: v1

project:
  name: runtime_events_sample

  triggers:
    - name: meow_webhook
      type: webhook
      event_type: get
      filter: data.url.path.endsWith("/meow")
      call: program.py:on_http_get_meow



================================================
FILE: kittehub/samples/runtime_events/program.py
================================================
"""This program demonstrates AutoKitteh's runtime event handling."""

from datetime import timedelta

import autokitteh


def on_http_get_meow(event):
    """This workflow is triggered by a predefined HTTP GET request event."""
    print("Got a meow, waiting for a woof")

    # Wait (up to 1 minute) for a subsequent webhook
    # event where the URL path ends with "woof".
    filter = "data.url.path.endsWith('/woof')"
    sub = autokitteh.subscribe("meow_webhook", filter)
    delta = timedelta(minutes=1)
    next = autokitteh.next_event(sub, timeout=delta)

    if next:
        print("Got a woof:", next)
    else:
        print("Timeout!")



================================================
FILE: kittehub/samples/scheduler/README.md
================================================
title: Scheduler sample
description: Samples using cron scheduler for workflows
integrations: ["scheduler"]
categories: ["Samples"]



================================================
FILE: kittehub/samples/scheduler/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup
# of an AutoKitteh project that demonstrates integration with a
# cron-like scheduler.

version: v1

project:
  name: scheduler_sample

  vars:
    - name: GITHUB_OWNER
      value:
    - name: GITHUB_REPO
      value:
    - name: OPENED_CUTOFF
      value: 4 # days
    - name: UPDATE_CUTOFF
      value: 1 # days

  connections:
    - name: github_conn
      integration: github

  triggers:
    - name: daily
      schedule: "@daily" # Same as "@midnight", "@every 1d", or "0 0 * * *".
      call: program.py:on_cron_trigger



================================================
FILE: kittehub/samples/scheduler/program.py
================================================
"""This program demonstrates AutoKitteh's scheduler capabilities.

It implements a single entry-point function, configured in the "autokitteh.yaml"
file to receive "scheduler" events, and uses constant values defined in the
"autokitteh.yaml" manifest for each AutoKitteh environment.
"""

from datetime import datetime, timedelta, UTC
import os

from autokitteh.github import github_client


# Set in "autokitteh.yaml"
GITHUB_OWNER = os.getenv("GITHUB_OWNER")
GITHUB_REPO = os.getenv("GITHUB_REPO")
OPENED_CUTOFF = os.getenv("OPENED_CUTOFF")
UPDATE_CUTOFF = os.getenv("UPDATE_CUTOFF")

github = github_client("github_conn")


def on_cron_trigger(_):
    """Handles the AutoKitteh cron schedule trigger."""
    # Fetch open pull requests that are not drafts or WIP
    repo = github.get_repo(f"{GITHUB_OWNER}/{GITHUB_REPO}")
    active_prs = [
        pr
        for pr in repo.get_pulls(state="open")
        if not pr.draft
        and "draft" not in pr.title.lower()
        and "wip" not in pr.title.lower()
    ]

    now = datetime.now(UTC)
    opened_cutoff = now - timedelta(days=int(OPENED_CUTOFF))
    update_cutoff = now - timedelta(days=int(UPDATE_CUTOFF))

    msg = "Daily reminder about stalled PRs:"

    for pr in active_prs:
        stalled_details = _get_stalled_pr_details(pr, now, opened_cutoff, update_cutoff)

        if stalled_details:
            print(f"PR {pr.number} is stalled")
            msg += f"\nPR: `{pr.title}`\n  {pr.url}\n  {stalled_details}\n"
            print(msg)


def _get_stalled_pr_details(pr, now, opened_cutoff, update_cutoff):
    """Returns details if a PR is stalled, otherwise returns an empty string."""
    details = []

    if pr.created_at < opened_cutoff:
        details.append(f"opened {_hours_ago(now, pr.created_at)}h ago")
    if pr.updated_at < update_cutoff:
        details.append(f"last updated {_hours_ago(now, pr.updated_at)}h ago")

    return ", ".join(details)


def _hours_ago(now, past_time):
    """Returns the number of hours between now and a past datetime."""
    delta = now - past_time
    return delta.total_seconds() // 3600



================================================
FILE: kittehub/samples/slack/README.md
================================================
title: Slack sample
description: Samples using Slack APIs
integrations: ["slack"]
categories: ["Samples"]



================================================
FILE: kittehub/samples/slack/approval_message.json.txt
================================================
[
    {
        "type": "header",
        "text": {
            "type":  "plain_text",
            "emoji": true,
            "text":  "Title"
        }
    },
    {
        "type": "divider"
    },
    {
        "type": "section",
        "text": {
            "type": "mrkdwn",
            "text": "Message"
        }
    },
    {
        "type": "divider"
    },
    {
        "type": "actions",
        "elements": [
            {
                "type":  "button",
                "style": "primary",
                "text": {
                    "type":  "plain_text",
                    "emoji": true,
                    "text":  "Approve"
                },
                "value":     "Approve",
                "action_id": "Approve ActionID"
            },
            {
                "type":  "button",
                "style": "danger",
                "text": {
                    "type":  "plain_text",
                    "emoji": true,
                    "text":  "Deny"
                },
                "value":     "Deny",
                "action_id": "Deny ActionID"
            }
        ]
    }
]



================================================
FILE: kittehub/samples/slack/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup
# of an AutoKitteh project that demonstrates 2-way integration with
# Slack (https://slack.com).

version: v1

project:
  name: slack_sample

  connections:
    - name: slack_conn
      integration: slack

  triggers:
    - name: slack_app_mention
      connection: slack_conn
      event_type: app_mention
      call: program.py:on_slack_app_mention
    - name: slack_interaction
      connection: slack_conn
      event_type: interaction
      call: program.py:on_slack_interaction
    - name: slack_message
      connection: slack_conn
      event_type: message
      call: program.py:on_slack_message
    - name: slack_reaction_added
      connection: slack_conn
      event_type: reaction_added
      call: program.py:on_slack_reaction_added
    - name: slack_slash_command
      connection: slack_conn
      event_type: slash_command
      call: program.py:on_slack_slash_command



================================================
FILE: kittehub/samples/slack/message.json
================================================
{
    "blocks": [
        {
            "type": "header",
            "text": {
                "type": "plain_text",
                "text": "This is a header block",
                "emoji": true
            }
        },
        {
            "type": "divider"
        },
        {
            "type": "section",
            "text": {
                "type": "mrkdwn",
                "text": "This is a section block with a button."
            },
            "accessory": {
                "type": "button",
                "text": {
                    "type": "plain_text",
                    "text": "Click Me",
                    "emoji": true
                },
                "value": "click_me_123",
                "url": "https://google.com",
                "action_id": "button-action"
            }
        }
    ]
}



================================================
FILE: kittehub/samples/slack/program.py
================================================
"""This program demonstrates AutoKitteh's 2-way Slack integration.

This program implements multiple entry-point functions that are triggered
by incoming Slack events, as defined in the "autokitteh-python.yaml"
manifest file. These functions also execute various Slack API calls.

Events that this program responds to:
- Mentions of the Slack app in messages (e.g. "Hi @autokitteh")
- Slash commands registered by the Slack app (`/autokitteh <channel name or ID>`)
- New and edited messages and replies
- New emoji reactions

Slack API documentation:
- Python client API: https://slack.dev/python-slack-sdk/api-docs/slack_sdk/web/client.html
- Events API reference: https://api.slack.com/events?filter=Events

This program isn't meant to cover all available functions and events.
It merely showcases a few illustrative, annotated, reusable examples.
"""

from pathlib import Path
import time

import autokitteh
from autokitteh.slack import slack_client


def on_slack_app_mention(event):
    """https://api.slack.com/events/app_mention

    Args:
        event: Slack event data.
    """
    slack = slack_client("slack_conn")

    # Send messages in response to the event:
    # - DM to the user who triggered the event (channel ID = user ID)
    # - Two messages to the channel "#slack-test"
    # See: https://slack.dev/python-slack-sdk/api-docs/slack_sdk/web/client.html#slack_sdk.web.client.WebClient.chat_postMessage
    text = f"You mentioned me in <#{event.data.channel}> and wrote: `{event.data.text}`"
    slack.chat_postMessage(channel=event.data.user, text=text)

    text = text.replace("You", f"<@{event.data.user}>")
    slack.chat_postMessage(channel="#slack-test", text=text)

    text = "Before update :crying_cat_face:"
    resp = slack.chat_postMessage(channel="#slack-test", text=text)

    # Encountered an error? Print debugging information
    # in the AutoKitteh session's log, and finish.
    resp.validate()

    # Update the last sent message, after a few seconds.
    # See: https://slack.dev/python-slack-sdk/api-docs/slack_sdk/web/client.html#slack_sdk.web.client.WebClient.chat_update
    time.sleep(10)
    resp = autokitteh.AttrDict(resp.data)
    text = "After update :smiley_cat:"
    resp = slack.chat_update(channel=resp.channel, ts=resp.ts, text=text)
    resp = autokitteh.AttrDict(resp.data)

    # Reply to the message's thread, after a few seconds.
    time.sleep(5)
    text = "Reply before update :crying_cat_face:"
    resp = slack.chat_postMessage(channel=resp.channel, text=text, thread_ts=resp.ts)
    resp = autokitteh.AttrDict(resp.data)

    # Update the threaded reply message, after a few seconds.
    time.sleep(5)
    text = "Reply after update :smiley_cat:"
    slack.chat_update(channel=resp.channel, ts=resp.ts, text=text)

    # Add a reaction to the threaded reply message.
    # See: https://slack.dev/python-slack-sdk/api-docs/slack_sdk/web/client.html#slack_sdk.web.client.WebClient.reactions_add
    slack.reactions_add(channel=resp.channel, name="blob-clap", timestamp=resp.ts)

    # Retrieve all the replies.
    # See: https://slack.dev/python-slack-sdk/api-docs/slack_sdk/web/client.html#slack_sdk.web.client.WebClient.conversations_replies
    resp = slack.conversations_replies(channel=resp.channel, ts=resp.ts)

    # For educational purposes, print all the replies in the AutoKitteh session's log.
    resp.validate()
    for text in resp.get("messages", default=[]):
        print(text)


def on_slack_message(event):
    """https://api.slack.com/events/message

    Args:
        event: Slack event data.
    """
    slack = slack_client("slack_conn")

    if not event.data.subtype:
        user = f"<@{event.data.user}>"
        if not event.data.thread_ts:
            _on_slack_new_message(slack, event.data, user)
        else:
            # https://api.slack.com/events/message/message_replied
            _on_slack_reply_message(slack, event.data, user)
    elif event.data.subtype == "message_changed":
        user = f"<@{event.data.message.user}>"  # Not the same as above!
        _on_slack_message_changed(slack, event.data, user)


def _on_slack_new_message(slack, data, user):
    """Someone wrote a new message."""
    text = f":point_up: {user} wrote: `{data.text}`"
    slack.chat_postMessage(channel=data.channel, text=text)


def _on_slack_reply_message(slack, data, user):
    """Someone wrote a reply in a thread."""
    text = f":point_up: {user} wrote a reply to <@{data.parent_user_id}>: `{data.text}`"
    ts = data.thread_ts
    slack.chat_postMessage(channel=data.channel, text=text, thread_ts=ts)


def _on_slack_message_changed(slack, data, user):
    """Someone edited a message."""
    old, new = data.previous_message.text, data.message.text
    text = f":point_up: {user} edited a message from `{old}` to `{new}`"

    # Thread TS may or may not be empty, depending on the edited message.
    thread = data.message.thread_ts

    slack.chat_postMessage(channel=data.channel, text=text, thread_ts=thread)


def on_slack_reaction_added(event):
    """https://api.slack.com/events/reaction_added

    Args:
        event: Slack event data.
    """
    # For educational purposes, print the event data in the AutoKitteh session's log.
    print(event.data.user)
    print(event.data.reaction)
    print(event.data.item)


def on_slack_slash_command(event):
    """https://api.slack.com/interactivity/slash-commands

    See also: https://api.slack.com/interactivity/handling#message_responses

    The text after the slash command is expected to be a valid target for a
    Slack message (https://api.slack.com/methods/chat.postMessage#channels):
    Slack user ID ("U"), user DM ID ("D"), multi-person/group DM ID ("G"),
    channel ID ("C"), or channel name (with or without the "#" prefix).

    Note that all targets except "U", "D" and public channels require
    the Slack app to be added in advance.

    Args:
        event: Slack event data.
    """
    slack = slack_client("slack_conn")

    # Retrieve the profile information of the user who triggered this event.
    # See: https://slack.dev/python-slack-sdk/api-docs/slack_sdk/web/client.html#slack_sdk.web.client.WebClient.users_info
    user_info = slack.users_info(user=event.data.user_id)

    # Encountered an error? Print debugging information
    # in the AutoKitteh session's log, and finish.
    user_info.validate()

    profile = autokitteh.AttrDict(user_info.data).user.profile
    text = f"Slack mention: <@{event.data.user_id}>"
    slack.chat_postMessage(channel=event.data.user_id, text=text)
    text = "Full name: " + profile.real_name
    slack.chat_postMessage(channel=event.data.user_id, text=text)
    text = "Email: " + profile.email
    slack.chat_postMessage(channel=event.data.user_id, text=text)

    # Treat the text of the user's slash command as a message target (e.g.
    # channel or user), and send an interactive message to that target.
    blocks = Path("approval_message.json.txt").read_text()
    changes = [
        ("Title", "Question From " + profile.real_name),
        ("Message", "Please select one of these options... :smiley_cat:"),
        ("ActionID", event.data.user_id),
    ]
    for old, new in changes:
        blocks = blocks.replace(old, new)

    slack.chat_postMessage(channel=event.data.text, blocks=blocks)


def on_slack_interaction(event):
    """https://api.slack.com/reference/interaction-payloads/block-actions

    Args:
        event: Slack event data.
    """
    # The Slack ID of the user who sent the question
    # (we stored this in the buttons' action IDs).
    action = autokitteh.AttrDict(event.data.actions[0])
    origin = action.action_id.split()[-1]

    # User selection = action value = button text
    # (our convention, not Slack's, alternatives: action style/text).
    text = f"<@{event.data.user.id}> clicked the `{action.value}` button"
    if action.style == "primary":  # Green button.
        text += " :+1:"
    elif action.style == "danger":  # Red button.
        text += " :-1:"

    slack = slack_client("slack_conn")
    slack.chat_postMessage(channel=origin, text=text)



================================================
FILE: kittehub/samples/twilio/README.md
================================================
title: Twilio sample
description: Samples using Twilio APIs
integrations: ["twilio"]
categories: ["Samples"]



================================================
FILE: kittehub/samples/twilio/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup
# of an AutoKitteh project that demonstrates 2-way integration with
# Twilio (https://www.twilio.com).

version: v1

project:
  name: twilio_sample

  vars:
    - name: FROM_PHONE_NUMBER
      value:

  connections:
    - name: twilio_conn
      integration: twilio

  triggers:
    - name: http_get
      type: webhook
      event_type: get
      call: program.py:on_http_get



================================================
FILE: kittehub/samples/twilio/program.py
================================================
"""This program demonstrates AutoKitteh's Twilio integration.

This program implements a single entry-point function triggered by an
HTTP GET request event, as defined in the "autokitteh.yaml" manifest file.

API details:
- Messaging API overview: https://www.twilio.com/docs/messaging/api
- Voice API overview: https://www.twilio.com/docs/voice/api

It also demonstrates using constant values which are set for each
AutoKitteh environment in the "autokitteh.yaml" manifest file.
"""

import os

from autokitteh.twilio import twilio_client


FROM_PHONE_NUMBER = os.getenv("FROM_PHONE_NUMBER")

t = twilio_client("twilio_conn")


def on_http_get(event):
    """Entry-point for workflow.

    This function is triggered by an HTTP GET request event and is used to
    send SMS and WhatsApp messages via Twilio.

    Example usage:
    curl "http://localhost:9980/webhooks/<webhook_slug>?to=+15551234567"

    The phone number to send the message to must be provided in the query
    parameter 'to'. The message will be sent both as an SMS and a WhatsApp
    message to the specified number.

    Args:
        event (object): An event object containing the request data.
    """
    to = event.data["url"]["query"]["to"]

    # Add a '+' if missing
    if not to.startswith("+"):
        to = f"+{to}"

    # Send SMS text via Twilio
    message = t.messages.create(
        from_=FROM_PHONE_NUMBER,
        to=to,
        body="This is an AutoKitteh demo message, meow!",
    )
    print(f"SMS message sent: {message.sid}")

    # Send a WhatsApp message to the same number
    whatsapp_message = t.messages.create(
        from_="whatsapp:" + FROM_PHONE_NUMBER,
        to="whatsapp:" + to,
        body="This is an AutoKitteh demo message, meow!",
    )
    print(f"WhatsApp message sent: {whatsapp_message.sid}")



================================================
FILE: kittehub/sheets_to_soap/README.md
================================================
title: Google Sheets to SOAP Calculator
description: Reads numeric values from Google Sheets and sends them to a SOAP-based calculator API
integrations: ["sheets"]
categories: ["Productivity", "DevOps"]



================================================
FILE: kittehub/sheets_to_soap/autokitteh.yaml
================================================
# Autokitteh configuration file for the sheets_to_soap project

version: v1

project:
  name: sheets_to_soap
  vars:
    - name: SOAP_WSDL
      value: http://www.dneonline.com/calculator.asmx?WSDL
    - name: SHEET_ID
      value:
    - name: SHEET_RANGE
      value:

  connections:
    - name: sheets_conn
      integration: googlesheets

  triggers:
    - name: webhook
      type: webhook
      event_type: get
      call: program.py:on_trigger



================================================
FILE: kittehub/sheets_to_soap/program.py
================================================
"""Reads pairs of numbers from a Google Sheet and sends them to a SOAP calculator."""

import os

from autokitteh.google import google_sheets_client
from zeep import Client


sheet = google_sheets_client("sheets_conn").spreadsheets().values()

SHEET_ID = os.getenv("SHEET_ID")
SHEET_RANGE = os.getenv("SHEET_RANGE")
SOAP_WSDL = os.getenv("SOAP_WSDL")

client = Client(SOAP_WSDL)


def on_trigger(_):
    """Workflow entry point."""
    response = sheet.get(spreadsheetId=SHEET_ID, range=SHEET_RANGE).execute()
    rows = response.get("values", [])

    if not rows:
        print("No data found.")
        return

    for row in rows:
        a = int(row[0])
        b = int(row[1])

        result = client.service.Add(intA=a, intB=b)
        print(f"{a} + {b} = {result}")



================================================
FILE: kittehub/sheets_to_soap/requirements.txt
================================================
zeep


================================================
FILE: kittehub/slack_discord_sync/README.md
================================================



================================================
FILE: kittehub/slack_discord_sync/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup
# of an AutoKitteh project that mirrors messages between Slack and
# Discord using AutoKitteh integrations.

version: v1

project:
  name: slack_discord_sync

  vars:
    - name: DISCORD_CHANNEL_ID
      value:
    - name: SLACK_CHANNEL_NAME_OR_ID
      value:

  connections:
    - name: discord_conn
      integration: discord
    - name: slack_conn
      integration: slack

  triggers:
    - name: on_discord_message
      connection: discord_conn
      event_type: message_create
      call: program.py:on_discord_message
    - name: on_slack_message
      connection: slack_conn
      call: program.py:on_slack_message



================================================
FILE: kittehub/slack_discord_sync/program.py
================================================
"""Mirror messages between Slack and Discord channels using.

Discord documentation:
- https://discordpy.readthedocs.io/

Note:
The `discord` import is crucial for enabling specific Discord API
configurations, such as intents and error handling, but all functional
API calls are made through the autokitteh `ak_discord` wrapper, which
streamlines authentication and secret management.
"""

import os

from autokitteh import discord as ak_discord
from autokitteh import slack
import discord


DISCORD_CHANNEL_ID = int(os.getenv("DISCORD_CHANNEL_ID", ""))
SLACK_CHANNEL = os.getenv("SLACK_CHANNEL_NAME_OR_ID", "")

# Discord intents that enable the bot to read message content
intents = discord.Intents.default()
intents.message_content = True

client = ak_discord.discord_client("discord_conn", intents)
slack_api = slack.slack_client("slack_conn")

# Stores the latest message received from Slack, to be posted to Discord
slack_message = None


def on_discord_message(event):
    slack_api.chat_postMessage(channel=SLACK_CHANNEL, text=event.data["content"])


def on_slack_message(event):
    global slack_message
    slack_message = event.data["text"]
    client.run(ak_discord.bot_token("discord_conn"))


@client.event
async def on_ready():
    """An asynchronous event triggered when the Discord bot successfully connects.

    It fetches the Discord channel by ID and sends the latest message received
    from Slack to the channel, then closes the client connection.
    """
    try:
        channel = await client.fetch_channel(DISCORD_CHANNEL_ID)
    except discord.DiscordException as e:
        print(f"Could not find Discord channel with ID: {DISCORD_CHANNEL_ID}: {e}")
        return

    await channel.send(slack_message)

    await client.close()



================================================
FILE: kittehub/slack_support/README.md
================================================
title: AI-driven Slack bot for assistance requests
description: Automatically route help requests to the right expert based on topic analysis and expertise matching
integrations: ["slack", "sheets", "googlegemini"]
categories: ["AI", "Productivity"]
 1 | Itay    | U12345678 | cats,dogs
 2 | Haim    | U87654321 | russian
```

This would happen:

![demo](/slack_support/demo.png)

## How It Works

1. Receive a help request from a user
2. Identify the request topic using Gemini AI
3. Assign the request to the appropriate expert based on the expertise table
4. Confirm the expertâ€™s acceptance of the request
5. Track the request until the expert resolves it
6. Remind the expert if the request remains unresolved within a set time

## Cloud Usage

1. Initialize your connections (Google Sheets, Google Gemini, Slack)
2. Set the `DIRECTORY_GOOGLE_SHEET_ID` project variable, in the "VARIABLES" tab, to point to your Google Sheet
3. (Optional) Set the `HELP_REQUEST_TIMEOUT_MINUTES` project variable, in the "VARIABLES" tab, to set the timeout for unclaimed requests
4. Deploy project

## Trigger Workflow

The workflow is triggered when the bot is mentioned in a message within a channel where it is a member. For example:

```
@autokitteh help me with my cat
```

When a topic matches an expert's expertise, the bot notifies them. The expert can use:

- `!take` to claim the request
- `!resolve` to mark it complete

## Self-Hosted Deployment

Follow [these detailed instructions](https://docs.autokitteh.com/get_started/deployment) to deploy the project on a self-hosted server.



================================================
FILE: kittehub/slack_support/autokitteh.yaml
================================================
version: v1

project:
  name: slack_support

  vars:
    - # Google Sheet ID for a sheet that contains a mapping between users and the
      # the topics they can support.
      # Expected google sheet structure:
      #   | A       | B         | C
      # --+---------+-----------+--------------
      # 1 | Gizmo   | U12345678 | topic1,topic2
      # 2 | George  | U87654321 | topic3
      name: DIRECTORY_GOOGLE_SHEET_ID
      value:
    - # Time in minutes to wait for the issue to be picked up before
      # reminder.
      name: HELP_REQUEST_TIMEOUT_MINUTES
      value: 10

  connections:
    - name: myslack
      integration: slack
    - name: mygsheets
      integration: googlesheets
    - name: gemini_conn
      integration: googlegemini

  triggers:
    - name: slack_app_mention
      connection: myslack
      event_type: app_mention
      call: main.py:on_slack_mention



================================================
FILE: kittehub/slack_support/directory.py
================================================
"""Mapping between topics and people who are knowledgeable about them."""

from dataclasses import dataclass
import os

from autokitteh.google import google_sheets_client


DIRECTORY_GOOGLE_SHEET_ID = os.getenv("DIRECTORY_GOOGLE_SHEET_ID", "")

gsheets = google_sheets_client("mygsheets").spreadsheets().values()


@dataclass
class Person:
    """A person in the directory."""

    name: str
    slack_id: str
    topics: list[str]


def load() -> dict[str, list[Person]]:  # topic -> list of people
    vs = (
        gsheets.get(spreadsheetId=DIRECTORY_GOOGLE_SHEET_ID, range="A1:C100")
        .execute()
        .get("values", [])
    )

    ppl = [Person(v[0], v[1], v[2].split(",")) for v in vs]

    topics = {topic for person in ppl for topic in person.topics}

    return {
        topic: [person for person in ppl if topic in person.topics] for topic in topics
    }



================================================
FILE: kittehub/slack_support/gemini.py
================================================
"""Deduce the topic of a given text."""

import json

from autokitteh.google import gemini_client


generation_config = {"response_mime_type": "application/json"}
gemini = gemini_client("gemini_conn", generation_config=generation_config)


def extract_topic(text: str, topics: set[str]) -> str:
    prompt = f"""Topics: {", ".join(topics)}
        Is the following text a request for help with one of these topics?
        Example responses:
        If a request for help and a topic is in the list:
        {{"help": true, "topic": "cats" }}
        If a request for help and topic is not in the list:
        {{"help": true, "topic": None }}
        If not a request for help: {{"help": false}}

        Text to analyze:
        {text}"""

    resp = json.loads(gemini.generate_content(prompt).text)
    return resp.get("help"), resp.get("topic")



================================================
FILE: kittehub/slack_support/main.py
================================================
"""Handles Slack mentions and help requests, sending reminders if unresolved."""

from datetime import datetime, UTC
import os

import autokitteh
from autokitteh.slack import slack_client

import directory
import gemini


HELP_REQUEST_TIMEOUT_MINUTES = int(os.getenv("HELP_REQUEST_TIMEOUT_MINUTES"))

slack_client = slack_client("myslack")


def on_slack_mention(event):
    def send(text):
        """Helper function to just post some text back in the same thread."""
        slack_client.chat_postMessage(
            channel=event.data.channel,
            thread_ts=event.data.ts,
            text=text,
        )

        # prints are used for logging, and can be seen in the console output.
        print(f"sent: '{text}'")

    topics_to_people = directory.load()

    help, topic = gemini.extract_topic(event.data.text, topics_to_people.keys())
    if not help:
        return

    people = topics_to_people.get(topic)
    if not people:
        send(f"Sorry, I don't know who to ask about {topic}.")
        return

    mentions = ", ".join(f"<@{p.slack_id}>" for p in people)

    send(f"""People who can help are: {mentions}.
Responders: please reply in this thread with `!take` or `!resolve`.
If not taken or resolved, I will remind you in {HELP_REQUEST_TIMEOUT_MINUTES}m.
""")

    # From this point on we are interested in any message that is added to the thread.
    # Further below we'll consume the messages and act on them using `next_event`.
    filter = "data.type == 'message' && data.thread_ts == "
    filter += f"'{event.data.ts}' && data.text.startsWith('!')"
    s = autokitteh.subscribe("myslack", filter)

    taken_by = None
    start_time = datetime.now(UTC)

    while True:
        msg = autokitteh.next_event(s, timeout=60)

        if not msg:  # timeout
            dt = (datetime.now(UTC) - start_time).total_seconds()
            print(f"timeout, dt={dt}")

            if not taken_by and dt >= HELP_REQUEST_TIMEOUT_MINUTES * 60:
                send(f"Reminder: {mentions}, please respond.")
                start_time = datetime.now(UTC)
            continue

        cmd = msg.text.strip()[1:]
        if cmd == "resolve":
            send("Issue is now resolved.")
            # this effectively ends the workflow.
            return
        if cmd == "take":
            taken_by = msg.user
            send(f"Thanks <@{msg.user}>, you've taken this issue.")



================================================
FILE: kittehub/task_chain/README.md
================================================



================================================
FILE: kittehub/task_chain/event_driven/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup
# of an AutoKitteh project that runs a sequence of tasks, using an
# event-driven approach.

version: v1

project:
  name: task_chain

  connections:
    - name: slack_conn
      integration: slack

  triggers:
    - name: slack_slash_command
      connection: slack_conn
      event_type: slash_command
      call: program.py:on_slack_slash_command
    - name: slack_interaction
      connection: slack_conn
      event_type: interaction
      call: program.py:on_slack_interaction



================================================
FILE: kittehub/task_chain/event_driven/interactive_message.json.txt
================================================
[
    {
        "type": "header",
        "text": {
            "type": "plain_text",
            "emoji": true,
            "text": ":warning: Workflow Error"
        }
    },
    {
        "type": "divider"
    },
    {
        "type": "section",
        "text": {
            "type": "mrkdwn",
            "text": "MESSAGE"
        }
    },
    {
        "type": "divider"
    },
    {
        "type": "actions",
        "elements": [
            {
                "type": "button",
                "text": {
                    "type": "plain_text",
                    "emoji": true,
                    "text": "Retry"
                },
                "value": "retry",
                "action_id": "RETRY INDEX"
            },
            {
                "type": "button",
                "style": "danger",
                "text": {
                    "type": "plain_text",
                    "emoji": true,
                    "text": "Abort"
                },
                "value": "abort",
                "action_id": "ABORT INDEX"
            }
        ]
    }
]



================================================
FILE: kittehub/task_chain/event_driven/program.py
================================================
"""This module uses an event-driven approach for the task-chain project.

A single workflow runs all the tasks, except retries:

1. First workflow:
   - Trigger: Slack slash command
   - Task 1 -> Task 2 -> Task 3 (error) -> Workflow error
2. Second workflow:
   - Trigger: user clicks the "Retry" button in Slack
   - Task 3 (retry) -> Task 4 -> Successful workflow completion
"""

from pathlib import Path
import random

from autokitteh.slack import slack_client


slack = slack_client("slack_conn")


def step1():
    print("Step 1 is doing stuff...")


def step2():
    print("Step 2 is doing stuff...")


def step3():
    print("Step 3 is doing stuff...")
    if random.choice([True, False]):
        raise RuntimeError("Something bad happened")


def step4():
    print("Step 4 is doing stuff...")


tasks = [step1, step2, step3, step4]


def on_slack_slash_command(event):
    """Use a Slack slash command from a user to start a chain of tasks."""
    run_tasks(0, event.data.user_id)


def run_tasks(start_index, user_id):
    # Note to the interested reader: it's easy to improve this project
    # to traverse a dynamic DAG, instead of a simple static list.
    for i, task in enumerate(tasks):
        if i >= start_index:
            run_retriable_task(task, i, user_id)

    message = "Workflow completed successfully :smiley_cat:"
    slack.chat_postMessage(channel=user_id, text=message)


def run_retriable_task(task, i, user_id):
    try:
        task()
    except Exception as e:
        ask_user_retry_or_abort(task.__name__, e, i, user_id)
        raise e  # Abort the current workflow.

    message = f"Task `{task.__name__}` completed"
    slack.chat_postMessage(channel=user_id, text=message)


def ask_user_retry_or_abort(task_name, error, i, user_id):
    message = f"The task `{task_name}` failed: `{error}`"
    blocks = Path("interactive_message.json.txt").read_text()
    blocks = blocks.replace("MESSAGE", message).replace("INDEX", str(i))
    slack.chat_postMessage(channel=user_id, text="Workflow error", blocks=blocks)


def on_slack_interaction(event):
    """Handle the user's response (retry / abort) in a new workflow."""
    if event.data.actions[0]["value"] == "abort":
        return

    # This workflow's starting point is a retry of the failed task in the aborted one.
    i = int(event.data.actions[0]["action_id"].split()[-1])
    run_tasks(i, event.data.user.id)



================================================
FILE: kittehub/task_chain/single_workflow/advanced/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup
# of an AutoKitteh project that runs a sequence of tasks, using an
# advanced single-workflow approach.

version: v1

project:
  name: task_chain

  connections:
    - name: slack_conn
      integration: slack

  triggers:
    - name: slack_slash_command
      connection: slack_conn
      event_type: slash_command
      call: program.py:on_slack_slash_command



================================================
FILE: kittehub/task_chain/single_workflow/advanced/interactive_message.json.txt
================================================
[
    {
        "type": "header",
        "text": {
            "type": "plain_text",
            "emoji": true,
            "text": ":warning: Workflow Error"
        }
    },
    {
        "type": "divider"
    },
    {
        "type": "section",
        "text": {
            "type": "mrkdwn",
            "text": "MESSAGE"
        }
    },
    {
        "type": "divider"
    },
    {
        "type": "actions",
        "elements": [
            {
                "type": "button",
                "text": {
                    "type": "plain_text",
                    "emoji": true,
                    "text": "Retry"
                },
                "value": "retry",
            },
            {
                "type": "button",
                "style": "danger",
                "text": {
                    "type": "plain_text",
                    "emoji": true,
                    "text": "Abort"
                },
                "value": "abort",
            }
        ]
    }
]



================================================
FILE: kittehub/task_chain/single_workflow/advanced/program.py
================================================
"""This module uses a single-workflow approach for the task-chain project.

A single workflow runs all the tasks, including retry loops.
It handles Slack interactions using runtime event subscriptions.
"""

from pathlib import Path
import random

import autokitteh
from autokitteh.slack import slack_client


slack = slack_client("slack_conn")


def step1():
    print("Step 1 is doing stuff...")


def step2():
    print("Step 2 is doing stuff...")


def step3():
    print("Step 3 is doing stuff...")
    if random.choice([True, False]):
        raise RuntimeError("Something bad happened")


def step4():
    print("Step 4 is doing stuff...")


tasks = [step1, step2, step3, step4]


def on_slack_slash_command(event):
    """Use a Slack slash command from a user to start a chain of tasks."""
    user_id = event.data.user_id

    # Note to the interested reader: it's easy to improve this project
    # to traverse a dynamic DAG, instead of a simple static list.
    success = True
    while len(tasks) > 0 and success:
        success = run_retriable_task(tasks[0], user_id)

    if success:
        message = "Workflow completed successfully :smiley_cat:"
        slack.chat_postMessage(channel=user_id, text=message)


def run_retriable_task(task, user_id) -> bool:
    try:
        task()
    except RuntimeError as e:
        return ask_user_retry_or_abort(task.__name__, e, user_id)

    message = f"Task `{task.__name__}` completed"
    slack.chat_postMessage(channel=user_id, text=message)

    global tasks
    tasks.remove(task)
    return True


def ask_user_retry_or_abort(task_name, error, user_id) -> bool:
    sub = autokitteh.subscribe("slack_conn", 'event_type == "interaction"')

    blocks = Path("interactive_message.json.txt").read_text()
    blocks = blocks.replace("MESSAGE", f"The task `{task_name}` failed: `{error}`")
    slack.chat_postMessage(channel=user_id, text="Workflow error", blocks=blocks)

    # Wait for and handle the user's response in this workflow.
    event = autokitteh.next_event(sub)
    autokitteh.unsubscribe(sub)
    return event.actions[0]["value"] == "retry"



================================================
FILE: kittehub/task_chain/single_workflow/basic/README.md
================================================
title: Fault tolerant workflow with manual Slack approvals
description: Runs a sequence of tasks with fault tolerance. In case of failure, user can decide to terminate or retry from the point of failure.
integrations: ["slack"]
categories: ["Durability"]



================================================
FILE: kittehub/task_chain/single_workflow/basic/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup
# of an AutoKitteh project that runs a sequence of tasks, using a
# basic single-workflow approach.

version: v1

project:
  name: task_chain

  connections:
    - name: slack_conn
      integration: slack

  triggers:
    - name: slack_slash_command
      connection: slack_conn
      event_type: slash_command
      call: program.py:on_slack_slash_command



================================================
FILE: kittehub/task_chain/single_workflow/basic/interactive_message.json.txt
================================================
[
    {
        "type": "header",
        "text": {
            "type": "plain_text",
            "emoji": true,
            "text": ":warning: Workflow Error"
        }
    },
    {
        "type": "divider"
    },
    {
        "type": "section",
        "text": {
            "type": "mrkdwn",
            "text": "MESSAGE"
        }
    },
    {
        "type": "divider"
    },
    {
        "type": "actions",
        "elements": [
            {
                "type": "button",
                "text": {
                    "type": "plain_text",
                    "emoji": true,
                    "text": "Retry"
                },
                "value": "retry",
            },
            {
                "type": "button",
                "style": "danger",
                "text": {
                    "type": "plain_text",
                    "emoji": true,
                    "text": "Abort"
                },
                "value": "abort",
            }
        ]
    }
]



================================================
FILE: kittehub/task_chain/single_workflow/basic/program.py
================================================
"""This module uses a single-workflow approach for the task-chain project.

A single workflow runs all the tasks, including retry loops.
It handles Slack interactions using runtime event subscriptions.
"""

from pathlib import Path
import random

import autokitteh
from autokitteh.slack import slack_client


slack = slack_client("slack_conn")


def step1():
    print("Step 1 is doing stuff...")


def step2():
    print("Step 2 is doing stuff...")


def step3():
    print("Step 3 is doing stuff...")
    if random.choice([True, False]):
        raise RuntimeError("Something bad happened")


def step4():
    print("Step 4 is doing stuff...")


def on_slack_slash_command(event):
    """Use a Slack slash command from a user to start a chain of tasks."""
    user_id = event.data.user_id

    if not run_retriable_task(step1, user_id):
        return
    if not run_retriable_task(step2, user_id):
        return
    if not run_retriable_task(step3, user_id):
        return
    if not run_retriable_task(step4, user_id):
        return

    message = "Workflow completed successfully :smiley_cat:"
    slack.chat_postMessage(channel=user_id, text=message)


def run_retriable_task(task, user_id) -> bool:
    result = True
    while result:
        try:
            task()
            break
        except RuntimeError as e:
            result = ask_user_retry_or_abort(task.__name__, e, user_id)

    if result:
        message = f"Task `{task.__name__}` completed"
        slack.chat_postMessage(channel=user_id, text=message)

    return result


def ask_user_retry_or_abort(task_name, error, user_id) -> bool:
    sub = autokitteh.subscribe("slack_conn", 'event_type == "interaction"')

    blocks = Path("interactive_message.json.txt").read_text()
    blocks = blocks.replace("MESSAGE", f"The task `{task_name}` failed: `{error}`")
    slack.chat_postMessage(channel=user_id, text="Workflow error", blocks=blocks)

    # Wait for and handle the user's response in this workflow.
    event = autokitteh.next_event(sub)
    autokitteh.unsubscribe(sub)
    return event.actions[0]["value"] == "retry"



================================================
FILE: kittehub/tests/convention_test.py
================================================
"""Unit tests for the metadata block in project README files."""

from pathlib import Path
import sys

import pytest


sys.path.append(str(Path(__file__).resolve().parent.parent))


import update_projects_table

import metadata_definitions


ROOT_PATH = Path(__file__).parent.parent


def get_metadata_files(base_path=ROOT_PATH):
    """Helper function to yield README files and their metadata."""
    for readme_file in sorted(Path(base_path).rglob("README.md")):
        metadata = update_projects_table.extract_metadata(readme_file)
        if metadata:
            yield readme_file, metadata


def test_metadata_contains_all_fields():
    for readme_file, metadata in get_metadata_files():
        error = f"Metadata missing in README file: {readme_file}"
        assert all(key in metadata for key in metadata_definitions.METADATA), error


def test_metadtata_contains_at_least_1_integration():
    for readme_file, metadata in get_metadata_files():
        error = f"Metadata must have at least one integration: {readme_file}"
        assert metadata["integrations"], error


def test_metadtata_contains_at_least_1_category():
    for readme_file, metadata in get_metadata_files():
        error = f"Metadata must have at least one category: {readme_file}"
        assert metadata["categories"], error


METADATA_VALID = [
    (metadata_definitions.ALLOWED_CATEGORIES, "categories"),
    (metadata_definitions.ALLOWED_INTEGRATIONS, "integrations"),
]


@pytest.mark.parametrize(("allow_list", "metadata_type"), METADATA_VALID)
def test_metadata_have_only_allowed_values(allow_list, metadata_type):
    for readme_file, metadata in get_metadata_files():
        for item in metadata[metadata_type]:
            error = f"Invalid '{item}' in {metadata_type}: {readme_file}"
            assert item in allow_list, error


TEST_CATEGORIES = [
    (Path(ROOT_PATH / "devops"), "DevOps"),
    (Path(ROOT_PATH / "reliability"), "Reliability"),
    (Path(ROOT_PATH / "samples"), "Samples"),
]


@pytest.mark.parametrize(("folder_path", "category"), TEST_CATEGORIES)
def test_projects_include_required_category(folder_path, category):
    for readme_file, metadata in get_metadata_files(folder_path):
        error = f"Metadata is missing the {category!r} category: {readme_file}"
        assert category in metadata["categories"], error


def test_sample_projects_have_correct_title_format():
    for readme_file, metadata in get_metadata_files(ROOT_PATH / "samples"):
        error = f"Sample projects must have 'sample' in the title: {readme_file}"
        assert metadata["title"].endswith(" sample"), error



================================================
FILE: kittehub/tests/metadata_definitions.py
================================================
"""Define metadata and allowed values for integrations and categories."""

METADATA = ("title", "description", "integrations", "categories")

ALLOWED_INTEGRATIONS = (
    "asana",
    "auth0",
    "autokitteh",
    "aws",
    "calendar",
    "chatgpt",
    "confluence",
    "docs",
    "drive",
    "forms",
    "github",
    "githubcopilot",
    "gmail",
    "googlegemini",
    "height",
    "http",
    "hubspot",
    "jira",
    "linear",
    "scheduler",
    "sheets",
    "slack",
    "sqlite3",
    "zoom",
    "twilio",
)

ALLOWED_CATEGORIES = (
    "AI",
    "CRM",
    "DevOps",
    "Durability",
    "Productivity",
    "Reliability",
    "Samples",
)



================================================
FILE: kittehub/walkthroughs/quickstart/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes
# the minimal setup of an AutoKitteh project.

version: v1

project:
  name: quickstart



================================================
FILE: kittehub/walkthroughs/quickstart/program.py
================================================
"""Handler for manual runs with a simple loop."""

import time


SLEEP_SECONDS = 1
ITERATIONS = 5


def on_manual_run(_):
    for i in range(ITERATIONS):
        print(f"Loop iteration: {i + 1} of {ITERATIONS}")
        time.sleep(SLEEP_SECONDS)



================================================
FILE: kittehub/walkthroughs/send_email/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes
# the minimal setup of an AutoKitteh project.

version: v1

project:
  name: send_email

  connections:
    - name: gmail_conn
      integration: gmail



================================================
FILE: kittehub/walkthroughs/send_email/program.py
================================================
"""Simple workflow for sending emails."""

import base64

from autokitteh.google import gmail_client
from googleapiclient.errors import HttpError


gmail = gmail_client("gmail_conn").users()


def on_manual_run(_):
    profile = gmail.getProfile(userId="me").execute()

    msg = f"""From: {profile["emailAddress"]}
    To: {profile["emailAddress"]}
    Subject: Test from AutoKitteh

    Meow! Just wanted to let you know that your cat overlords are pleased with your
    service today. Keep up the good work with the treats and belly rubs!"""

    msg = msg.replace("\n", "\r\n").replace("    ", "")
    msg = base64.urlsafe_b64encode(msg.encode()).decode()
    try:
        gmail.messages().send(userId="me", body={"raw": msg}).execute()
    except HttpError as e:
        print(f"Error: `{e.reason}`")
        return

    print("Message sent successfully!")



================================================
FILE: kittehub/walkthroughs/send_slack_message/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes
# the minimal setup of an AutoKitteh project.

version: v1

project:
  name: send_slack_message

  vars:
    - name: CHANNEL
      value: general

  connections:
    - name: slack_conn
      integration: slack
    



================================================
FILE: kittehub/walkthroughs/send_slack_message/program.py
================================================
"""Simple workflow that sends a message to Slack."""

import os

from autokitteh.slack import slack_client


CHANNEL = os.getenv("CHANNEL")


def on_manual_run(_):
    slack_client("slack_conn").chat_postMessage(
        channel=CHANNEL,
        text="Meow, world!",
    )



================================================
FILE: kittehub/walkthroughs/webhook/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes
# the minimal setup of an AutoKitteh project.

version: v1

project:
  name: webhook



================================================
FILE: kittehub/walkthroughs/webhook/program.py
================================================
"""A simple workflow that is triggered by a webhook."""


def on_webhook(event):
    print(event)



================================================
FILE: kittehub/webhook_to_jira/README.md
================================================
title: Create Jira ticket from webhook data
description: Create Jira issues automatically from HTTP webhooks
integrations: ["jira", "http"]
categories: ["DevOps"]



================================================
FILE: kittehub/webhook_to_jira/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup of
# an AutoKitteh project that creates Jira issues based on HTTP requests.

version: v1

project:
  name: webhook_to_jira

  connections:
    - name: jira_conn
      integration: jira

  triggers:
    - name: http_get_or_post_request
      type: webhook
      filter: data.method == "GET" || data.method == "POST"
      call: program.py:on_http_request



================================================
FILE: kittehub/webhook_to_jira/program.py
================================================
"""Create Jira issues based on HTTP GET/POST requests.

Atlassian Jira API documentation:
- https://docs.autokitteh.com/integrations/atlassian/jira/python

HTTP API documentation:
- https://docs.autokitteh.com/integrations/http/events
"""

from autokitteh.atlassian import jira_client


def on_http_request(event):
    """Webhook for HTTP GET and POST requests."""
    if event.data.method == "GET":
        _create_jira_issue(event.data.url.query)
        return

    match event.data.headers.get("Content-Type"):
        case "application/json":
            json_body = event.data.body.json  # Or: json.loads(event.data.body.bytes)
            _create_jira_issue(json_body)
        case "application/x-www-form-urlencoded":
            form_body = event.data.body.form  # Or: dict(urllib.parse.parse_qsl(body))
            _create_jira_issue(form_body)


def _create_jira_issue(fields):
    if isinstance(fields["project"], str):
        fields["project"] = {"key": fields["project"]}
    if isinstance(fields["issuetype"], str):
        fields["issuetype"] = {"name": fields["issuetype"]}

    issue = jira_client("jira_conn").issue_create(fields=fields)
    print("Created Jira issue:", issue["key"])



================================================
FILE: kittehub/.github/workflows/ci.yml
================================================
# https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-python
# https://docs.astral.sh/ruff/integrations/#github-actions

name: CI

on:
  push:
    branches: [main]
  pull_request:

jobs:
  lint-format-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
          cache: pip

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Lint & format with ruff
        run: |
          ruff check --output-format github .
          ruff format --check .

      - name: Test with pytest
        run: pytest -v .

      - name: Verify README.md is up to date
        run: |
          # If this check fails, run "python update_projects_table.py", and add "README.md" to this PR.
          python update_projects_table.py
          git diff --name-only --exit-code README.md



================================================
FILE: kittehub/.github/workflows/dist.yml
================================================
name: Dist

on:
  push:
    branches: [main]

jobs:
  dist:
    concurrency:
      group: kittehub-releases-dist
      cancel-in-progress: true
    permissions:
      contents: write
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: build
        run: zip -r dist .
      - uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: release
          branch: release
          push_options: "--force"
          create_branch: true



================================================
FILE: kittehub/.github/workflows/typos.yml
================================================
# https://github.com/crate-ci/typos/blob/master/docs/github-action.md

name: Typos

on: [pull_request]

jobs:
  run:
    name: Spell check with Typos
    runs-on: ubuntu-latest
    steps:
    - name: Check out code
      uses: actions/checkout@v4

    - name: Check spelling
      uses: crate-ci/typos@master
      with:
        config: ./.typos.toml



================================================
FILE: pyak/__init__.py
================================================
"""AutoKitteh Python SDK."""
from . import errors
from .activities import activity, inhibit_activities, register_no_activity
from .attr_dict import AttrDict
from .event import Event
from .events import next_event, start, subscribe, unsubscribe
from .signals import Signal, next_signal, signal
from .errors import AutoKittehError
from .store import get_value, mutate_value, set_value, del_value, list_values_keys, store
__all__ = ['AttrDict', 'errors', 'start', 'AutoKittehError', 'activity',
    'inhibit_activities', 'register_no_activity', 'Event', 'next_event',
    'subscribe', 'unsubscribe', 'next_signal', 'signal', 'Signal',
    'del_value', 'get_value', 'list_values_keys', 'mutate_value',
    'set_value', 'store']



================================================
FILE: pyak/activities.py
================================================
"""Decorator to mark a function as a Temporal activity."""
from typing import Callable
ACTIVITY_ATTR = '__ak_activity__'
INHIBIT_ACTIVITIES_ATTR = '__ak_inhibit_activities__'


def activity(fn: callable) ->callable:
    """Decorator to mark a function as a Temporal activity.

    This forces AutoKitteh to run the function as a single Temporal activity,
    instead of a sequence of activities within a Temporal workflow.

    Use this decorator when you want to run functions with input arguments
    and/or return values that are not compatible with pickle.

    For more details, see:
    https://docs.python.org/3/library/pickle.html#what-can-be-pickled-and-unpickled
    """
    ...


def inhibit_activities(fn: callable) ->callable:
    """Decorator to inhibit the execution of Temporal activities.

    Functions using this decorator will not spawn activities even if otherwise
    activities should have been launched. This is useful for performing operations
    that are required to run even on replay (such as various clients creation) and
    are completely deterministic. The function results are not cached and would be
    rerun in case of replay.

    CAVEAT: Do not use this on functions that take a long time to run (more than a second),
    as they will cause the workflow to timeout.
    """
    ...


_no_activity = set()


def register_no_activity(items: list[Callable]) ->None:
    """Mark items that should not run as activities.

    Items should be callable and hashable. If an item is a class, all methods in the
    class are marked as non-activities.

    This helps speeding up your code, but you might risk non-deterministic behavior.
    """
    ...



================================================
FILE: pyak/anthropic.py
================================================
"""Initialize an Anthropic client, based on an AutoKitteh connection."""
import os
from anthropic import Anthropic
from .connections import check_connection_name
from .errors import ConnectionInitError


def anthropic_client(connection: str) ->Anthropic:
    """Initialize an Anthropic client, based on an AutoKitteh connection.

    API reference:
    https://docs.anthropic.com/claude/reference
    https://github.com/anthropics/anthropic-sdk-python

    Args:
        connection: AutoKitteh connection name.

    Returns:
        Anthropic API client.

    Raises:
        ValueError: AutoKitteh connection name is invalid.
        ConnectionInitError: AutoKitteh connection was not initialized yet.
        anthropic.APIError: Anthropic SDK initialization errors.
    """
    ...



================================================
FILE: pyak/asana.py
================================================
import os
import asana
from .connections import check_connection_name
from .errors import ConnectionInitError


def asana_client(connection: str) ->asana.ApiClient:
    """Initialize an Asana client, based on an AutoKitteh connection.

    API reference:
    https://developers.asana.com/docs/python

    Args:
        connection: AutoKitteh connection name.

    Returns:
        Asana client.

    Raises:
        ValueError: AutoKitteh connection name is invalid.
        ConnectionInitError: AutoKitteh connection was not initialized yet.
    """
    ...



================================================
FILE: pyak/atlassian.py
================================================
"""Initialize an Atlassian client, based on an AutoKitteh connection."""
from datetime import UTC, datetime
import re
import os
from atlassian import Confluence, Jira
from requests_oauthlib import OAuth2Session
from .connections import check_connection_name
from .errors import AtlassianOAuthError, ConnectionInitError, EnvVarError
__TOKEN_URL = 'https://auth.atlassian.com/oauth/token'


def jira_client(connection: str, **kwargs) ->Jira:
    """Initialize an Atlassian Jira client, based on an AutoKitteh connection.

    API reference:
    https://atlassian-python-api.readthedocs.io/jira.html

    Code samples:
    https://github.com/atlassian-api/atlassian-python-api/tree/master/examples/jira

    Args:
        connection: AutoKitteh connection name.
        **kwargs: Additional keyword arguments passed to the Jira client.
            Common options include:
            - 'url': URL of the Jira instance.
            - 'username': Username for Jira authentication.
            - 'password': Password for Jira authentication.
            - 'token': API token for Jira authentication.
            - 'verify_ssl': Boolean to verify SSL certificates.
            For a full list of accepted arguments, see:
            https://github.com/atlassian-api/atlassian-python-api/blob/master/atlassian/rest_client.py#L48

    Returns:
        Atlassian-Python-API Jira client.

    Raises:
        ValueError: AutoKitteh connection name is invalid.
        ConnectionInitError: AutoKitteh connection was not initialized yet.
        EnvVarError: Required environment variable is missing or invalid.
    """
    ...


def confluence_client(connection: str, **kwargs) ->Confluence:
    """Initialize an Atlassian Confluence client, based on an AutoKitteh connection.

    API reference:
    https://atlassian-python-api.readthedocs.io/confluence.html

    Code samples:
    https://github.com/atlassian-api/atlassian-python-api/tree/master/examples/confluence

    Args:
        connection: AutoKitteh connection name.

    Returns:
        Atlassian-Python-API Confluence client.

    Raises:
        ValueError: AutoKitteh connection name is invalid.
        ConnectionInitError: AutoKitteh connection was not initialized yet.
        EnvVarError: Required environment variable is missing or invalid.
        AtlassianOAuthError
    """
    ...


def get_base_url(connection: str) ->(str | None):
    """Get the base URL of an AutoKitteh connection's Atlassian server.

    Args:
        connection: AutoKitteh connection name.

    Returns:
        Base URL of the Atlassian connection, or None if
        the AutoKitteh connection was not initialized yet.

    Raises:
        ValueError: AutoKitteh connection name is invalid.
    """
    ...



================================================
FILE: pyak/attr_dict.py
================================================
"""Helper class to allow attribute access to dictionary keys."""


class AttrDict(dict):
    """Allow attribute access to dictionary keys.

    >>> config = AttrDict({'server': {'port': 8080}, 'debug': True})
    >>> config.server.port
    8080
    >>> config.debug
    True
    """



================================================
FILE: pyak/auth0.py
================================================
import os
from .connections import check_connection_name
from .errors import ConnectionInitError
from auth0.management import Auth0


def auth0_client(connection: str, **kwargs) ->Auth0:
    """Initialize an Auth0 client, based on an AutoKitteh connection.

    API reference:
    https://auth0-python.readthedocs.io/en/latest/

    Args:
        connection: AutoKitteh connection name.

    Returns:
        Auth0 SDK client.

    Raises:
        ConnectionInitError: If the connection is not initialized.
        ValueError: If the connection name is invalid.
    """
    ...



================================================
FILE: pyak/aws.py
================================================
"""Initialize a Boto3 (AWS SDK) client, based on an AutoKitteh connection."""
import os
import boto3
from .connections import check_connection_name


def boto3_client(connection: str, service: str, region: str='', **kwargs):
    """Initialize a Boto3 (AWS SDK) client, based on an AutoKitteh connection.

    API reference:
    https://boto3.amazonaws.com/v1/documentation/api/latest/index.html

    Code samples:
    https://boto3.amazonaws.com/v1/documentation/api/latest/guide/examples.html

    Args:
        connection: AutoKitteh connection name.
        service: AWS service name.
        region: AWS region name.

    Returns:
        Boto3 client.

    Raises:
        ValueError: AutoKitteh connection or AWS service/region names are invalid.
        BotoCoreError: Authentication error.
    """
    ...



================================================
FILE: pyak/connections.py
================================================
"""AutoKitteh connection-related utilities."""
from datetime import UTC, datetime
import re


def check_connection_name(connection: str) ->None:
    """Check that the given AutoKitteh connection name is valid.

    Args:
        connection: AutoKitteh connection name.

    Raises:
        ValueError: The connection name is invalid.
    """
    ...


def encode_jwt(payload: dict[str, int], connection: str, algorithm: str) ->str:
    """Mock function to generate JWTs, overridden by the AutoKitteh runner."""
    ...


def refresh_oauth(integration: str, connection: str) ->tuple[str, datetime]:
    """Mock function to refresh OAuth tokens, overridden by the AutoKitteh runner."""
    ...



================================================
FILE: pyak/discord.py
================================================
import os
import discord
from .connections import check_connection_name
from .errors import ConnectionInitError


def discord_client(connection: str, intents=None, **kwargs) ->discord.Client:
    """Initialize a Discord client, based on an AutoKitteh connection.

    API reference:
    https://discordpy.readthedocs.io/en/stable/api.html

    Args:
        connection: AutoKitteh connection name.
        intents: An object representing the events your bot can receive.

    Returns:
        Discord client.

    Raises:
        ValueError: AutoKitteh connection name is invalid.
        ConnectionInitError: AutoKitteh connection was not initialized yet.
        DiscordException: Connection attempt failed, or connection is unauthorized.
    """
    ...


def bot_token(connection: str):
    ...



================================================
FILE: pyak/errors.py
================================================
"""AutoKitteh SDK errors."""
from google.auth.exceptions import RefreshError


class AutoKittehError(Exception):
    """Generic base class for all errors in the AutoKitteh SDK."""


class ConnectionInitError(AutoKittehError):
    """A required AutoKitteh connection was not initialized yet."""


class EnvVarError(AutoKittehError):
    """A required environment variable is missing or invalid."""


class OAuthRefreshError(AutoKittehError):
    """OAuth token refresh failed."""


class AtlassianOAuthError(AutoKittehError):
    """API calls not supported by OAuth-based Atlassian connections."""



================================================
FILE: pyak/event.py
================================================
"""AutoKitteh Event class"""
from dataclasses import dataclass
from .attr_dict import AttrDict


@dataclass
class Event:
    """AutoKitteh Event as passed to entrypoints."""
    data: AttrDict
    session_id: str



================================================
FILE: pyak/events.py
================================================
"""Un/subscribe and consume AutoKitteh connection events."""
from datetime import timedelta
from uuid import uuid4
from .attr_dict import AttrDict


def subscribe(source: str, filter: str='') ->str:
    """Subscribe to events on connection. Optional filter is a CEL expression.

    Cannot be used in an activity."""
    ...


def unsubscribe(subscription_id: str) ->None:
    """Unsubscribe from events.

    Cannot be used in an activity."""
    ...


def next_event(subscription_id: (str | list[str]), *, timeout: (timedelta |
    int | float)=None) ->AttrDict:
    """Get the next event from the subscription(s).

    If timeout is not None and there are no new events after timeout, this function will
    return None.

    Cannot be used in an activity.
    """
    ...


def start(loc: str, data: (dict | None)=None, memo: (dict | None)=None,
    project: str='') ->str:
    """Start a new session.

    Cannot be used in an activity."""
    ...



================================================
FILE: pyak/github.py
================================================
"""Initialize a GitHub client, based on an AutoKitteh connection."""
import os
import time
from urllib.parse import urljoin
from github import Auth, Consts, Github, GithubIntegration
from .connections import check_connection_name, encode_jwt
from .errors import ConnectionInitError


def github_client(connection: str, **kwargs) ->Github:
    """Initialize a GitHub client, based on an AutoKitteh connection.

    API reference and examples: https://pygithub.readthedocs.io/

    Args:
        connection: AutoKitteh connection name.

    Returns:
        PyGithub client.

    Raises:
        ValueError: AutoKitteh connection name or GitHub app IDs are invalid.
        ConnectionInitError: AutoKitteh connection was not initialized yet.
    """
    ...


class AppAuth(Auth.AppAuth):
    """Generate JWTs without exposing the GitHub app's private key.

    Based on: https://github.com/PyGithub/PyGithub/blob/main/github/Auth.py
    """

    def create_jwt(self, expiration: (int | None)=None) ->str:
        ...



================================================
FILE: pyak/google.py
================================================
"""Initialize Google API clients, based on AutoKitteh connections."""
from datetime import UTC, datetime
import json
import os
import re
from google.auth.exceptions import RefreshError
from google.auth.transport.requests import Request
import google.generativeai as genai
import google.oauth2.credentials as credentials
import google.oauth2.service_account as service_account
from googleapiclient.discovery import build
from .connections import check_connection_name, refresh_oauth
from .errors import ConnectionInitError, OAuthRefreshError


def gmail_client(connection: str, **kwargs):
    """Initialize a Gmail client, based on an AutoKitteh connection.

    API documentation:
    https://docs.autokitteh.com/integrations/google/gmail/python

    Code samples:
    - https://github.com/autokitteh/kittehub/tree/main/samples/google/gmail
    - https://github.com/googleworkspace/python-samples/tree/main/gmail

    Args:
        connection: AutoKitteh connection name.

    Returns:
        Gmail client.

    Raises:
        ValueError: AutoKitteh connection name is invalid.
        ConnectionInitError: AutoKitteh connection was not initialized yet.
        OAuthRefreshError: OAuth token refresh failed.
    """
    ...


def google_calendar_client(connection: str, **kwargs):
    """Initialize a Google Calendar client, based on an AutoKitteh connection.

    API documentation:
    https://docs.autokitteh.com/integrations/google/calendar/python

    Code samples:
    https://github.com/autokitteh/kittehub/tree/main/samples/google/calendar

    Args:
        connection: AutoKitteh connection name.

    Returns:
        Google Calendar client.

    Raises:
        ValueError: AutoKitteh connection name is invalid.
        ConnectionInitError: AutoKitteh connection was not initialized yet.
        OAuthRefreshError: OAuth token refresh failed.
    """
    ...


def google_drive_client(connection: str, **kwargs):
    """Initialize a Google Drive client, based on an AutoKitteh connection.

    API documentation:
    https://docs.autokitteh.com/integrations/google/drive/python

    Code samples:
    https://github.com/googleworkspace/python-samples/tree/main/drive

    Args:
        connection: AutoKitteh connection name.

    Returns:
        Google Drive client.

    Raises:
        ValueError: AutoKitteh connection name is invalid.
        ConnectionInitError: AutoKitteh connection was not initialized yet.
        OAuthRefreshError: OAuth token refresh failed.
    """
    ...


def google_forms_client(connection: str, **kwargs):
    """Initialize a Google Forms client, based on an AutoKitteh connection.

    API documentation:
    https://docs.autokitteh.com/integrations/google/forms/python

    Code samples:
    - https://github.com/autokitteh/kittehub/tree/main/samples/google/forms
    - https://github.com/googleworkspace/python-samples/tree/main/forms

    Args:
        connection: AutoKitteh connection name.

    Returns:
        Google Forms client.

    Raises:
        ValueError: AutoKitteh connection name is invalid.
        ConnectionInitError: AutoKitteh connection was not initialized yet.
        OAuthRefreshError: OAuth token refresh failed.
    """
    ...


def gemini_client(connection: str, **kwargs) ->genai.GenerativeModel:
    """Initialize a Gemini generative AI client, based on an AutoKitteh connection.

    API reference:
    - https://ai.google.dev/gemini-api/docs
    - https://github.com/google-gemini/generative-ai-python/blob/main/docs/api/google/generativeai/GenerativeModel.md

    Code samples:
    - https://ai.google.dev/gemini-api/docs#explore-the-api
    - https://ai.google.dev/gemini-api/docs/text-generation?lang=python
    - https://github.com/google-gemini/generative-ai-python/tree/main/samples
    - https://github.com/google-gemini/cookbook

    Args:
        connection: AutoKitteh connection name.

    Returns:
        An initialized GenerativeModel instance.

    Raises:
        ValueError: AutoKitteh connection name is invalid.
        ConnectionInitError: AutoKitteh connection was not initialized yet.
    """
    ...


def google_sheets_client(connection: str, **kwargs):
    """Initialize a Google Sheets client, based on an AutoKitteh connection.

    API documentation:
    https://docs.autokitteh.com/integrations/google/sheets/python

    Code samples:
    - https://github.com/autokitteh/kittehub/tree/main/samples/google/sheets
    - https://github.com/googleworkspace/python-samples/tree/main/sheets

    Args:
        connection: AutoKitteh connection name.

    Returns:
        Google Sheets client.

    Raises:
        ValueError: AutoKitteh connection name is invalid.
        ConnectionInitError: AutoKitteh connection was not initialized yet.
        OAuthRefreshError: OAuth token refresh failed.
    """
    ...


def google_creds(integration: str, connection: str, scopes: list[str], **kwargs
    ):
    """Initialize credentials for a Google APIs client, for service discovery.

    This function supports both AutoKitteh connection modes:
    users (with OAuth 2.0), and GCP service accounts (with a JSON key).

    Code samples:
    https://github.com/googleworkspace/python-samples

    For subsequent usage details, see:
    https://googleapis.github.io/google-api-python-client/docs/epy/googleapiclient.discovery-module.html#build

    Args:
        integration: AutoKitteh integration name.
        connection: AutoKitteh connection name.
        scopes: List of OAuth permission scopes.

    Returns:
        Google API credentials, ready for usage
        in "googleapiclient.discovery.build()".

    Raises:
        ValueError: AutoKitteh connection name is invalid.
        ConnectionInitError: AutoKitteh connection was not initialized yet.
        OAuthRefreshError: OAuth token refresh failed.
    """
    ...


def google_id(url: str) ->str:
    """Extract the Google Doc/Form/Sheet ID from a URL. This function is idempotent.

    Example: 'https://docs.google.com/.../d/1a2b3c4d5e6f/edit' --> '1a2b3c4d5e6f'
    """
    ...



================================================
FILE: pyak/height.py
================================================
"""Initialize a Height client, based on an AutoKitteh connection."""
from requests import Session
from .oauth2_session import OAuth2Session


def height_client(connection: str) ->Session:
    """Initialize an Height client, based on an AutoKitteh connection.

    API reference:
    https://height-api.xyz/openapi/

    Args:
        connection: AutoKitteh connection name.

    Returns:
        Requests session object.

    Raises:
        ValueError: AutoKitteh connection name is invalid.
        ConnectionInitError: AutoKitteh connection was not initialized yet.
    """
    ...



================================================
FILE: pyak/hubspot.py
================================================
"""Initialize a HubSpot client, based on an AutoKitteh connection."""
import os
from hubspot import HubSpot
from .connections import check_connection_name, refresh_oauth
from .errors import ConnectionInitError, OAuthRefreshError


def hubspot_client(connection: str, **kwargs) ->HubSpot:
    """Initialize a HubSpot client, based on an AutoKitteh connection.

    Args:
        connection: AutoKitteh connection name.

    Returns:
        HubSpot SDK client.

    Raises:
        ValueError: AutoKitteh connection name is invalid.
        ConnectionInitError: AutoKitteh connection was not initialized yet.
        OAuthRefreshError: OAuth token refresh failed.
    """
    ...



================================================
FILE: pyak/kubernetes.py
================================================
import json
import os
from types import ModuleType
from kubernetes import client, config
from .connections import check_connection_name
from .errors import ConnectionInitError


def kubernetes_client(connection: str) ->ModuleType:
    """Initialize a Kubernetes client, based on an AutoKitteh connection.

    API reference:
    https://github.com/kubernetes-client/python
    https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.30/

    Args:
        connection: AutoKitteh connection name.

    Returns:
        Kubernetes API client.

    Raises:
        ValueError: AutoKitteh connection name is invalid.
        ConnectionInitError: If the connection config is missing or invalid,
            or if an unexpected error occurs during client initialization.

    """
    ...



================================================
FILE: pyak/linear.py
================================================
"""Initialize a Linear client, based on an AutoKitteh connection."""
from requests import Session
from .oauth2_session import OAuth2Session


def linear_client(connection: str) ->Session:
    """Initialize a Linear client, based on an AutoKitteh connection.

    API reference:
    https://linear.app/developers/graphql

    Args:
        connection: AutoKitteh connection name.

    Returns:
        Requests session object.

    Raises:
        ValueError: AutoKitteh connection name is invalid.
        ConnectionInitError: AutoKitteh connection was not initialized yet.
    """
    ...



================================================
FILE: pyak/microsoft.py
================================================
"""Initialize Microsoft Graph SDK clients, based on AutoKitteh connections."""
from datetime import datetime, timedelta, UTC
import os
from azure.core import credentials
from azure import identity
from msgraph import GraphServiceClient
from .connections import check_connection_name, refresh_oauth
from .errors import ConnectionInitError
DEFAULT_REFRESH_BUFFER_TIME = timedelta(minutes=5)


def teams_client(connection: str, **kwargs) ->GraphServiceClient:
    """Initialize a Microsoft Teams client, based on an AutoKitteh connection.

    API documentation:
    https://docs.autokitteh.com/integrations/microsoft/teams/python

    Args:
        connection: AutoKitteh connection name.

    Returns:
        Microsoft Graph client.

    Raises:
        ValueError: AutoKitteh connection name or auth type are invalid.
        ConnectionInitError: AutoKitteh connection was not initialized yet.
        OAuthRefreshError: OAuth token refresh failed.
    """
    ...


class OAuthTokenProvider(credentials.TokenCredential):
    """OAuth 2.0 token wrapper for Microsoft Graph clients."""

    def get_token(self, *scopes: str, **kwargs) ->credentials.AccessToken:
        ...



================================================
FILE: pyak/oauth2_session.py
================================================
import requests
from os import getenv
from .connections import refresh_oauth
from .connections import check_connection_name
from .errors import ConnectionInitError


class OAuth2Session(requests.Session):
    """Encapsulates arequests session, based on an AutoKitteh connection.

    - Automatically sets the Authorization header with an OAuth token.
    - Automatically refreshes an OAuth token if a refresh token is
      initialized in the connection.
    """



================================================
FILE: pyak/openai.py
================================================
"""Initialize an OpenAI client, based on an AutoKitteh connection."""
import os
from openai import OpenAI
from .connections import check_connection_name
from .errors import ConnectionInitError


def openai_client(connection: str) ->OpenAI:
    """Initialize an OpenAI client, based on an AutoKitteh connection.

    API reference:
    https://platform.openai.com/docs/api-reference/
    https://github.com/openai/openai-python/blob/main/api.md

    Args:
        connection: AutoKitteh connection name.

    Returns:
        OpenAI API client.

    Raises:
        ValueError: AutoKitteh connection name is invalid.
        ConnectionInitError: AutoKitteh connection was not initialized yet.
        OpenAIError: Connection attempt failed, or connection is unauthorized.
    """
    ...



================================================
FILE: pyak/packages.py
================================================
import re
import sys
from subprocess import run


def install(*packages):
    """Install Python packages using pip.

    A package can be either a package requirement specifier
    (see https://pip.pypa.io/en/stable/reference/requirement-specifiers/)
    or a tuple of (package specifier, import name) in case the import name differs from
    the package name (e.g. Package `pillow` import imported as `PIL`).

    Examples:
    >>> install('requests', 'numpy')
    >>> install('requests ~= 2.32', 'numpy == 2.0.0')
    >>> install(['pillow ~= 10.4', 'PIL'])
    """
    ...



================================================
FILE: pyak/salesforce.py
================================================
"""Initialize a Salesforce client, based on an AutoKitteh connection."""
import os
from simple_salesforce import Salesforce
from .connections import check_connection_name
from .errors import ConnectionInitError


def salesforce_client(connection: str, **kwargs) ->Salesforce:
    """Initialize a Salesforce client, based on an AutoKitteh connection.

    Args:
        connection: AutoKitteh connection name.

    Returns:
        Salesforce client.

    Raises:
        ValueError: AutoKitteh connection name is invalid.
        ConnectionInitError: AutoKitteh connection was not initialized yet.
        SalesforceApiError: Connection attempt failed, or connection is unauthorized.
    """
    ...



================================================
FILE: pyak/signals.py
================================================
"""Send and receive signals."""
from datetime import timedelta
from dataclasses import dataclass


@dataclass
class Signal:
    name: str
    payload: any = None


def signal(session_id: str, name: str, payload: any=None) ->None:
    """Signal a session.

    Cannot be used in an activity."""
    ...


def next_signal(name: (str | list[str]), *, timeout: (timedelta | int |
    float)=None) ->(Signal | None):
    """Get the next signal.

    Cannot be used in an activity."""
    ...



================================================
FILE: pyak/slack.py
================================================
"""Slack client initialization, and other helper functions."""
import os
import re
from slack_sdk.web.client import WebClient
from .connections import check_connection_name
from .errors import ConnectionInitError


def slack_client(connection: str, **kwargs) ->WebClient:
    """Initialize a Slack client, based on an AutoKitteh connection.

    API reference:
    https://slack.dev/python-slack-sdk/api-docs/slack_sdk/web/client.html

    This function doesn't initialize a Socket Mode client because the
    AutoKitteh connection already has one to receive incoming events.

    Args:
        connection: AutoKitteh connection name.

    Returns:
        Slack SDK client.

    Raises:
        ValueError: AutoKitteh connection name is invalid.
        ConnectionInitError: AutoKitteh connection was not initialized yet.
        SlackApiError: Connection attempt failed, or connection is unauthorized.
    """
    ...


def normalize_channel_name(name: str) ->str:
    """Convert arbitrary text into a valid Slack channel name.

    See: https://api.slack.com/methods/conversations.create#naming

    Args:
        name: Desired name for a Slack channel.

    Returns:
        Valid Slack channel name.
    """
    ...



================================================
FILE: pyak/store.py
================================================
from collections.abc import MutableMapping
from typing import Any
from enum import StrEnum
_local_dev_store = {}


class Store(MutableMapping):
    """Store it a dict like interface to ak store.

    Values must be pickleable, see
    https://docs.python.org/3/library/pickle.html#what-can-be-pickled-and-unpickled
    """


store = Store()


class Op(StrEnum):
    """Enum for operation types."""
    SET = 'set'
    GET = 'get'
    DEL = 'del'


def mutate_value(key: str, op: Op, *args: list[Any]) ->Any:
    """Mutate a stored value.

    Args:
        key: Key of the value to mutate.
        op: Operation to perform on the value.
        args: Additional arguments for the operation.

    Returns:
        Any: Result of the operation, if applicable.

    Raises:
        AutoKittehError: Value is too large.
    """
    ...


def get_value(key: str) ->Any:
    """Get a stored value.

    Args:
        key: Key of the value to retrieve.

    Returns:
        Any: The stored value, or None if not found.
    """
    ...


def set_value(key: str, value: Any) ->None:
    """Set a stored value.

    Args:
        key: Key of the value to set.
        value: Value to store. If Value is None, it will be deleted. Value must be serializable.

    Returns:
        None.

    Raises:
        AutoKittehError: Value is too large.
    """
    ...


def del_value(key: str) ->None:
    """Delete a stored value.

    Args:
        key: Key of the value to set.

    Returns:
        None.
    """
    ...


def list_values_keys() ->list[str]:
    """List all stored keys.

    Returns:
        list[str]: Sorted list of all keys in the store.
    """
    ...



================================================
FILE: pyak/twilio.py
================================================
"""Initialize a Twilio client, based on an AutoKitteh connection."""
import os
from twilio.rest import Client
from .connections import check_connection_name
from .errors import ConnectionInitError


def twilio_client(connection: str) ->Client:
    """Initialize a Twilio client, based on an AutoKitteh connection.

    API reference:
    https://www.twilio.com/docs/libraries/python

    Args:
        connection: AutoKitteh connection name.

    Returns:
        Twilio client.

    Raises:
        ValueError: AutoKitteh connection name is invalid.
        ConnectionInitError: AutoKitteh connection was not initialized yet.
    """
    ...



================================================
FILE: pyak/zoom.py
================================================
"""Initialize a Zoom client, based on an AutoKitteh connection."""
from requests import Session
from .oauth2_session import OAuth2Session


def zoom_client(connection: str) ->Session:
    """Initialize a Zoom client, based on an AutoKitteh connection.

    API reference:
    https://developers.zoom.us/docs/api/

    Args:
        connection: AutoKitteh connection name.

    Returns:
        Requests session object.

    Raises:
        ValueError: AutoKitteh connection name is invalid.
        ConnectionInitError: AutoKitteh connection was not initialized yet.
    """
    ...



================================================
FILE: samples/reviewkitteh/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup of
# an AutoKitteh project that integrates GitHub, Google Sheets, and Slack.

version: v1

project:
  name: reviewkitteh

  vars:
    - name: SLACK_CHANNEL_ID
      value:
    - name: GOOGLE_SHEET_ID
      value:
    - name: ORG_DOMAIN
      value:

  connections:
    - name: github_conn
      integration: github
    - name: googlesheets_conn
      integration: googlesheets
    - name: slack_conn
      integration: slack

  triggers:
    - name: github_pull_request
      connection: github_conn
      event_type: pull_request
      filter: data.action == "opened" || data.action == "reopened"
      call: program.py:on_github_pull_request



================================================
FILE: samples/reviewkitteh/program.py
================================================
"""Listen for GitHub pull requests and meow at random people.

This program listens for GitHub pull request events and posts a message
to a Slack channel when a pull request is opened or reopened. It then polls
the pull request until it is closed or merged, updating the message with the
current state of the pull request. Every 15 seconds, it also reads a random
name from a Google Sheet and pages that person in the Slack channel.
"""

from datetime import datetime, UTC
import os
import random
import time

from autokitteh.github import github_client
from autokitteh.google import google_sheets_client
from autokitteh.slack import slack_client


CHANNEL_ID = os.getenv("SLACK_CHANNEL_ID", "")
SHEET_ID = os.getenv("GOOGLE_SHEET_ID", "")
ORG_DOMAIN = os.getenv("ORG_DOMAIN", "")

github = github_client("github_conn")
googlesheets = google_sheets_client("googlesheets_conn").spreadsheets().values()
slack = slack_client("slack_conn")


def on_github_pull_request(event):
    """Workflow's entry-point."""
    pr = event.data.pull_request
    msg = f"{pr.html_url} [{pr.state}]"
    ts = slack.chat_postMessage(channel=CHANNEL_ID, text=msg)["ts"]

    i = 0

    while pr.state not in ("closed", "merged"):
        _log(f"Polling #{i}")
        time.sleep(5)

        repo = github.get_repo(event.data.repository.full_name)
        pr = repo.get_pull(pr.number)
        msg = f"{pr.html_url} meow [{pr.state}]"
        slack.chat_update(channel=CHANNEL_ID, ts=ts, text=msg)

        i += 1

        if i % 3 == 0:
            # Spreadsheet contains a list of usernames.
            result = googlesheets.get(spreadsheetId=SHEET_ID, range="A1:A5").execute()
            rows = result.get("values", [])
            the_chosen_one = random.choice(rows)[0]
            _log(f"Meowing at {the_chosen_one}")

            user_email = f"{the_chosen_one}@{ORG_DOMAIN}"
            user = slack.users_lookupByEmail(email=user_email)["user"]
            msg = f"Paging <@{user['id']}>"
            slack.chat_postMessage(channel=CHANNEL_ID, text=msg, thread_ts=ts)


def _log(msg):
    print(f"[{datetime.now(UTC)}] {msg}")



================================================
FILE: samples/slack/approval_message.json.txt
================================================
[
    {
        "type": "header",
        "text": {
            "type":  "plain_text",
            "emoji": true,
            "text":  "Title"
        }
    },
    {
        "type": "divider"
    },
    {
        "type": "section",
        "text": {
            "type": "mrkdwn",
            "text": "Message"
        }
    },
    {
        "type": "divider"
    },
    {
        "type": "actions",
        "elements": [
            {
                "type":  "button",
                "style": "primary",
                "text": {
                    "type":  "plain_text",
                    "emoji": true,
                    "text":  "Approve"
                },
                "value":     "Approve",
                "action_id": "Approve ActionID"
            },
            {
                "type":  "button",
                "style": "danger",
                "text": {
                    "type":  "plain_text",
                    "emoji": true,
                    "text":  "Deny"
                },
                "value":     "Deny",
                "action_id": "Deny ActionID"
            }
        ]
    }
]



================================================
FILE: samples/slack/autokitteh.yaml
================================================
# This YAML file is a declarative manifest that describes the setup
# of an AutoKitteh project that demonstrates 2-way integration with
# Slack (https://slack.com).

version: v1

project:
  name: slack_sample

  connections:
    - name: slack_conn
      integration: slack

  triggers:
    - name: slack_app_mention
      connection: slack_conn
      event_type: app_mention
      call: program.py:on_slack_app_mention
    - name: slack_interaction
      connection: slack_conn
      event_type: interaction
      call: program.py:on_slack_interaction
    - name: slack_message
      connection: slack_conn
      event_type: message
      call: program.py:on_slack_message
    - name: slack_reaction_added
      connection: slack_conn
      event_type: reaction_added
      call: program.py:on_slack_reaction_added
    - name: slack_slash_command
      connection: slack_conn
      event_type: slash_command
      call: program.py:on_slack_slash_command



================================================
FILE: samples/slack/message.json
================================================
{
    "blocks": [
        {
            "type": "header",
            "text": {
                "type": "plain_text",
                "text": "This is a header block",
                "emoji": true
            }
        },
        {
            "type": "divider"
        },
        {
            "type": "section",
            "text": {
                "type": "mrkdwn",
                "text": "This is a section block with a button."
            },
            "accessory": {
                "type": "button",
                "text": {
                    "type": "plain_text",
                    "text": "Click Me",
                    "emoji": true
                },
                "value": "click_me_123",
                "url": "https://google.com",
                "action_id": "button-action"
            }
        }
    ]
}



================================================
FILE: samples/slack/program.py
================================================
"""This program demonstrates AutoKitteh's 2-way Slack integration.

This program implements multiple entry-point functions that are triggered
by incoming Slack events, as defined in the "autokitteh-python.yaml"
manifest file. These functions also execute various Slack API calls.

Events that this program responds to:
- Mentions of the Slack app in messages (e.g. "Hi @autokitteh")
- Slash commands registered by the Slack app (`/autokitteh <channel name or ID>`)
- New and edited messages and replies
- New emoji reactions

Slack API documentation:
- Python client API: https://slack.dev/python-slack-sdk/api-docs/slack_sdk/web/client.html
- Events API reference: https://api.slack.com/events?filter=Events

This program isn't meant to cover all available functions and events.
It merely showcases a few illustrative, annotated, reusable examples.
"""

from pathlib import Path
import time

import autokitteh
from autokitteh.slack import slack_client


def on_slack_app_mention(event):
    """https://api.slack.com/events/app_mention

    Args:
        event: Slack event data.
    """
    slack = slack_client("slack_conn")

    # Send messages in response to the event:
    # - DM to the user who triggered the event (channel ID = user ID)
    # - Two messages to the channel "#slack-test"
    # See: https://slack.dev/python-slack-sdk/api-docs/slack_sdk/web/client.html#slack_sdk.web.client.WebClient.chat_postMessage
    text = f"You mentioned me in <#{event.data.channel}> and wrote: `{event.data.text}`"
    slack.chat_postMessage(channel=event.data.user, text=text)

    text = text.replace("You", f"<@{event.data.user}>")
    slack.chat_postMessage(channel="#slack-test", text=text)

    text = "Before update :crying_cat_face:"
    resp = slack.chat_postMessage(channel="#slack-test", text=text)

    # Encountered an error? Print debugging information
    # in the AutoKitteh session's log, and finish.
    resp.validate()

    # Update the last sent message, after a few seconds.
    # See: https://slack.dev/python-slack-sdk/api-docs/slack_sdk/web/client.html#slack_sdk.web.client.WebClient.chat_update
    time.sleep(10)
    resp = autokitteh.AttrDict(resp.data)
    text = "After update :smiley_cat:"
    resp = slack.chat_update(channel=resp.channel, ts=resp.ts, text=text)
    resp = autokitteh.AttrDict(resp.data)

    # Reply to the message's thread, after a few seconds.
    time.sleep(5)
    text = "Reply before update :crying_cat_face:"
    resp = slack.chat_postMessage(channel=resp.channel, text=text, thread_ts=resp.ts)
    resp = autokitteh.AttrDict(resp.data)

    # Update the threaded reply message, after a few seconds.
    time.sleep(5)
    text = "Reply after update :smiley_cat:"
    slack.chat_update(channel=resp.channel, ts=resp.ts, text=text)

    # Add a reaction to the threaded reply message.
    # See: https://slack.dev/python-slack-sdk/api-docs/slack_sdk/web/client.html#slack_sdk.web.client.WebClient.reactions_add
    slack.reactions_add(channel=resp.channel, name="blob-clap", timestamp=resp.ts)

    # Retrieve all the replies.
    # See: https://slack.dev/python-slack-sdk/api-docs/slack_sdk/web/client.html#slack_sdk.web.client.WebClient.conversations_replies
    resp = slack.conversations_replies(channel=resp.channel, ts=resp.ts)

    # For educational purposes, print all the replies in the AutoKitteh session's log.
    resp.validate()
    for text in resp.get("messages", default=[]):
        print(text)


def on_slack_message(event):
    """https://api.slack.com/events/message

    Args:
        event: Slack event data.
    """
    slack = slack_client("slack_conn")

    if not event.data.subtype:
        user = f"<@{event.data.user}>"
        if not event.data.thread_ts:
            _on_slack_new_message(slack, event.data, user)
        else:
            # https://api.slack.com/events/message/message_replied
            _on_slack_reply_message(slack, event.data, user)
    elif event.data.subtype == "message_changed":
        user = f"<@{event.data.message.user}>"  # Not the same as above!
        _on_slack_message_changed(slack, event.data, user)


def _on_slack_new_message(slack, data, user):
    """Someone wrote a new message."""
    text = f":point_up: {user} wrote: `{data.text}`"
    slack.chat_postMessage(channel=data.channel, text=text)


def _on_slack_reply_message(slack, data, user):
    """Someone wrote a reply in a thread."""
    text = f":point_up: {user} wrote a reply to <@{data.parent_user_id}>: `{data.text}`"
    ts = data.thread_ts
    slack.chat_postMessage(channel=data.channel, text=text, thread_ts=ts)


def _on_slack_message_changed(slack, data, user):
    """Someone edited a message."""
    old, new = data.previous_message.text, data.message.text
    text = f":point_up: {user} edited a message from `{old}` to `{new}`"

    # Thread TS may or may not be empty, depending on the edited message.
    thread = data.message.thread_ts

    slack.chat_postMessage(channel=data.channel, text=text, thread_ts=thread)


def on_slack_reaction_added(event):
    """https://api.slack.com/events/reaction_added

    Args:
        event: Slack event data.
    """
    # For educational purposes, print the event data in the AutoKitteh session's log.
    print(event.data.user)
    print(event.data.reaction)
    print(event.data.item)


def on_slack_slash_command(event):
    """https://api.slack.com/interactivity/slash-commands

    See also: https://api.slack.com/interactivity/handling#message_responses

    The text after the slash command is expected to be a valid target for a
    Slack message (https://api.slack.com/methods/chat.postMessage#channels):
    Slack user ID ("U"), user DM ID ("D"), multi-person/group DM ID ("G"),
    channel ID ("C"), or channel name (with or without the "#" prefix).

    Note that all targets except "U", "D" and public channels require
    the Slack app to be added in advance.

    Args:
        event: Slack event data.
    """
    slack = slack_client("slack_conn")

    # Retrieve the profile information of the user who triggered this event.
    # See: https://slack.dev/python-slack-sdk/api-docs/slack_sdk/web/client.html#slack_sdk.web.client.WebClient.users_info
    user_info = slack.users_info(user=event.data.user_id)

    # Encountered an error? Print debugging information
    # in the AutoKitteh session's log, and finish.
    user_info.validate()

    profile = autokitteh.AttrDict(user_info.data).user.profile
    text = f"Slack mention: <@{event.data.user_id}>"
    slack.chat_postMessage(channel=event.data.user_id, text=text)
    text = "Full name: " + profile.real_name
    slack.chat_postMessage(channel=event.data.user_id, text=text)
    text = "Email: " + profile.email
    slack.chat_postMessage(channel=event.data.user_id, text=text)

    # Treat the text of the user's slash command as a message target (e.g.
    # channel or user), and send an interactive message to that target.
    blocks = Path("approval_message.json.txt").read_text()
    changes = [
        ("Title", "Question From " + profile.real_name),
        ("Message", "Please select one of these options... :smiley_cat:"),
        ("ActionID", event.data.user_id),
    ]
    for old, new in changes:
        blocks = blocks.replace(old, new)

    slack.chat_postMessage(channel=event.data.text, blocks=blocks)


def on_slack_interaction(event):
    """https://api.slack.com/reference/interaction-payloads/block-actions

    Args:
        event: Slack event data.
    """
    # The Slack ID of the user who sent the question
    # (we stored this in the buttons' action IDs).
    action = autokitteh.AttrDict(event.data.actions[0])
    origin = action.action_id.split()[-1]

    # User selection = action value = button text
    # (our convention, not Slack's, alternatives: action style/text).
    text = f"<@{event.data.user.id}> clicked the `{action.value}` button"
    if action.style == "primary":  # Green button.
        text += " :+1:"
    elif action.style == "danger":  # Red button.
        text += " :-1:"

    slack = slack_client("slack_conn")
    slack.chat_postMessage(channel=origin, text=text)


